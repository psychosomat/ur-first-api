# **2.2장: Planet 모델 생성**
**학습 시간:** 45분

---

#### **1. Laravel의 모델: 우주 객체의 설계도**
MVC(Model-View-Controller) 아키텍처에서 **모델**은 다음과 같습니다:

- 📦 데이터 컨테이너 (행성 매개변수)
- 🔌 데이터베이스 작업 인터페이스
- 🛡️ 애플리케이션 비즈니스 로직의 중심

> 💡 **우주 비유:**
> `Planet` 모델 = 지상 통제 센터(ЦУП) 컴퓨터의 행성 설계도. 이를 통해 다음을 수행할 수 있습니다:

> - 카탈로그에 새로운 행성 생성 (`INSERT`)
> - 화성 데이터 가져오기 (`SELECT`)
> - 대기 정보 업데이트 (`UPDATE`)

---

#### **2. 모델 및 마이그레이션 생성**
Laravel은 Artisan CLI를 사용합니다. 이것은 프로젝트의 "제어판"입니다.

**1단계: 마이그레이션과 함께 모델 생성**
```bash
php artisan make:model Planet -m
```

**생성된 파일:**
```
app/
  └── Models/
      └── Planet.php    ← 모델
database/
  └── migrations/
      └── 2025_08_04_000000_create_planets_table.php  ← 마이그레이션
```

**Artisan 플래그:**

- `-m` → 마이그레이션 생성
- `-c` → 컨트롤러 생성
- `-r` → 리소스 컨트롤러

> 💡 **전문가 팁:** 이러한 플래그를 조합하여 최대 효율을 얻을 수 있습니다. `php artisan make:model Planet -mcr` 명령어는 모델, 마이그레이션, 그리고 이 모델을 관리하는 리소스 컨트롤러를 동시에 생성합니다. 이는 많은 시간을 절약해줍니다.

---

#### **3. Planet 모델 설정**
`app/Models/Planet.php` 파일을 엽니다:
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Planet extends Model
{
    // 테이블 이름 (기본값: 'planets')
	// Laravel은 테이블 이름이 모델 이름의 snake_case 형태의 복수형(Planet -> planets)이라고 자동으로 가정합니다.
       //따라서 이 속성은 필수는 아니지만, 명확성을 위해 유용합니다.
    protected $table = 'planets';

    // 대량 할당이 허용된 필드
    protected $fillable = [
        'name',
        'description',
        'size_km',
        'solar_system',
        'image_url'
    ];

    // 자동 형 변환을 위한 데이터 타입
    protected $casts = [
        'size_km' => 'integer'
    ];
}
```

**속성 설명:**

| 속성         | 값                         | 데이터 예시              |
|------------------|----------------------------------|----------------------------|
| `$table`         | DB의 테이블 이름                 | `planets`                  |
| `$fillable`      | 대량 할당을 위한 필드    | `name`, `size_km`          |
| `$casts`         | 자동 타입 변환 | `size_km: integer`       |

---

#### **4. 행성 테이블 설계**
마이그레이션을 편집하기 전에 "행성"의 구조를 정의해 봅시다:

| 필드             | 데이터 타입       | 설명                     | 예시 값       |
|------------------|------------------|------------------------------|-----------------------|
| `id`             | BIGINT (PK)      | 고유 ID                | 1                     |
| `name`           | VARCHAR(255)     | 행성 이름             | "화성"                |
| `description`    | TEXT             | 설명                     | "붉은 행성..."  |
| `size_km`        | INTEGER          | 직경 (km)                 | 6779                  |
| `solar_system`   | VARCHAR(100)     | 태양계            | "태양계"   |
| `image_url`      | VARCHAR(2048)    | 사진 URL (null 허용)   | "https://..."         |
| `created_at`     | TIMESTAMP        | 생성 날짜                | 2025-08-04 12:00:00   |
| `updated_at`     | TIMESTAMP        | 업데이트 날짜              | 2025-08-05 09:30:00   |

---

#### **5. 마이그레이션 편집**
`database/migrations/..._create_planets_table.php` 파일을 엽니다:

```php
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreatePlanetsTable extends Migration
{
    public function up()
    {
        Schema::create('planets', function (Blueprint $table) {
            $table->id(); // BIGINT 자동 증분

            $table->string('name')->unique();
            $table->text('description');
            $table->integer('size_km');
            $table->string('solar_system', 100);
            $table->string('image_url', 2048)->nullable();

            $table->timestamps(); // created_at + updated_at
        });
    }

    public function down()
    {
        Schema::dropIfExists('planets');
    }
}
```

**핵심 사항:**

- `->unique()` → 이름의 고유성 보장
- `->nullable()` → 필드가 비어 있을 수 있음
- `timestamps()` → 날짜 자동 관리

---

#### **6. 마이그레이션 실행 (사전)**
2.3장에서 실행하겠지만, 어떻게 보일지 미리 살펴봅시다:
```bash
php artisan migrate
```

**예상 출력:**
```
Migrating: 2025_08_04_000000_create_planets_table
Migrated:  2025_08_04_000000_create_planets_table (32.15ms)
```

**pgAdmin 4에서 확인:**

1. `space_api` 데이터베이스 → Schemas → Tables를 엽니다.
2. `planets` 테이블이 여러분이 정의한 필드들과 함께 나타나야 합니다.

---

#### **7. 대체 접근 방식: 코드 생성기**
개발 속도를 높이기 위해 다음 패키지를 사용할 수 있습니다:

- **Laravel Blueprint** - YAML 설명을 기반으로 모델/마이그레이션 생성
- **InfyOm Laravel Generator** - DB 스키마 기반의 생성기

**Blueprint 예시:**
```yaml
models:
  Planet:
    name: string:255
    description: text
    size_km: integer
    solar_system: string:100
    image_url: string:2048? # '?' 기호는 필드가 nullable임을 의미합니다.
```

---

#### **복습 퀴즈**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. 모델 및 관련 마이그레이션을 생성하는 Artisan 명령어:</p>
      <label><input type="radio" name="q1" value="a"> a) php artisan make:model Planet -m</label>
      <label><input type="radio" name="q1" value="b"> b) php artisan create:model Planet</label>
      <label><input type="radio" name="q1" value="c"> c) php artisan model:new Planet --m</label>
    </div>
    <div class="question">
      <p>2. 모델의 `$fillable` 속성이 필요한 이유:</p>
      <label><input type="radio" name="q2" value="a"> a) 대량 할당으로부터 보호</label>
      <label><input type="radio" name="q2" value="b"> b) 데이터 자동 암호화</label>
      <label><input type="radio" name="q2" value="c"> c) 외래 키 설명</label>
    </div>
    <div class="question">
      <p>3. 마이그레이션에서 nullable()은 다음을 의미합니다:</p>
      <label><input type="radio" name="q3" value="a"> a) 필수 필드</label>
      <label><input type="radio" name="q3" value="b"> b) 필드가 비어 있을 수 있음</label>
      <label><input type="radio" name="q3" value="c"> c) 필드가 삭제됩니다</label>
    </div>
    <div class="question">
      <p>4. 행성의 긴 설명을 위한 필드 유형:</p>
      <label><input type="radio" name="q4" value="a"> a) string</label>
      <label><input type="radio" name="q4" value="b"> b) text</label>
      <label><input type="radio" name="q4" value="c"> c) varchar</label>
    </div>
    <div class="question">
      <p>5. `timestamps()` 메서드는 다음을 생성합니다:</p>
      <label><input type="radio" name="q5" value="a"> a) created_at만</label>
      <label><input type="radio" name="q5" value="b"> b) created_at 및 updated_at</label>
      <label><input type="radio" name="q5" value="c"> c) id, created_at, updated_at</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">확인</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'a', q3: 'b', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>결과:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>문제 ${question.slice(1)}: <span style="color:green;">정답입니다!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>문제 ${question.slice(1)}: <span style="color:red;">오답입니다.</span> 정답: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>문제 ${question.slice(1)}: <span style="color:orange;">답변 없음.</span></li>`;
      }
    }
resultsHTML += `</ul><p><b>귀하의 점수: ${Object.keys(correctAnswers).length}개 중 ${score}점</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 장 요약:**
행성의 "디지털 트윈"을 만들었습니다! 이제 프로젝트에는 다음이 포함됩니다:

- 🪐 비즈니스 로직이 포함된 `Planet` 모델
- 📊 PostgreSQL 내 `planets` 테이블용 마이그레이션
- 🛠️ 설정된 모델 속성(`fillable`, `casts`)

**데이터베이스를 준비하세요!** 다음 장에서는 마이그레이션을 실행하고 첫 행성들로 우주를 채울 것입니다.

> **📌 확인:**

> `Planet.php` 및 `..._create_planets_table.php` 파일이 올바른 디렉터리에 생성되었는지 확인하세요.

> **⚠️ Artisan에 오류가 발생하면:**

> - 프로젝트 폴더 안에 있는지 확인하세요.
> - 종속성이 설치되었는지 확인하세요 (`composer install`).
> - Windows의 경우: PHP와 Composer를 PATH에 추가하세요.
