# **Cap√≠tulo 5.4: Trabajar con tokens CSRF**
**Tiempo de estudio:** 30 minutos

---

### **1. ¬øQu√© es un ataque CSRF? El "secuestro" de tu nave**

Imagina que has iniciado sesi√≥n en el panel de control de tu flota espacial (`space-api.test`). En una pesta√±a adyacente, abres un sitio web inofensivo con gatitos (`evil-cats.com`). En este sitio web hay un formulario oculto que env√≠a autom√°ticamente una solicitud a tu sitio web a la direcci√≥n `POST /api/planets/1/delete`.

Dado que ya est√°s autenticado en `space-api.test`, tu navegador adjuntar√° amablemente todas tus cookies a esta solicitud. El servidor Laravel ver√° una sesi√≥n v√°lida y pensar√° que fuiste t√∫ quien decidi√≥ dar de baja el planeta. **El planeta ser√° eliminado sin tu conocimiento.**

Esto es **CSRF (Cross-Site Request Forgery)** ‚Äî un ataque en el que un atacante obliga al navegador de un usuario autenticado a realizar una acci√≥n no deseada en un sitio de confianza.

> üí° **Analog√≠a espacial:**

> Eres el capit√°n de una nave, y tienes una tarjeta de acceso (sesi√≥n/cookie). El atacante no puede robar tu tarjeta. Pero puede enga√±arte para que la acerques a un terminal de desmantelamiento de recursos mientras est√°s distra√≠do. El token CSRF es como un c√≥digo PIN que debes ingresar junto con la tarjeta. El atacante no sabe el c√≥digo PIN, y su ataque falla.

---

### **2. ¬øC√≥mo protege Laravel contra CSRF?**

Laravel protege por defecto todas las solicitudes web "inseguras" (POST, PUT, PATCH, DELETE) utilizando un **token CSRF**.

1.  Al generar una p√°gina, Laravel crea un token √∫nico y aleatorio para la sesi√≥n del usuario.
2.  Este token se incrusta en los formularios HTML.
3.  Al enviar el formulario, el token se env√≠a junto con la solicitud.
4.  En el servidor, el middleware `VerifyCsrfToken` compara el token de la solicitud con el token almacenado en la sesi√≥n.
5.  **Si los tokens no coinciden, Laravel interrumpe la solicitud con un error 419 (Session Expired/Page Expired).**

**Importante:** Las rutas API en `routes/api.php` **no** est√°n protegidas por CSRF, ya que asumen un mecanismo de autenticaci√≥n diferente (por ejemplo, tokens de Sanctum), y no sesiones basadas en cookies. Nuestro problema actual se refiere espec√≠ficamente a las rutas web y las p√°ginas que creamos en `routes/web.php`.

---

### **3. Uso del token CSRF en formularios HTML**
Este es el escenario m√°s simple. Laravel proporciona una directiva Blade especial para esto.

**Ejemplo: Formulario para crear un planeta**
Creemos un formulario simple en el archivo `resources/views/planets/create.blade.php`:

```html
<h2>Formulario de lanzamiento de nuevo planeta</h2>
<form action="/planets" method="POST">
    @csrf {{-- ¬°Aqu√≠ est√° la magia! --}}

    <label for="name">Nombre:</label>
    <input type="text" id="name" name="name" required>

    <label for="solar_system">Sistema solar:</label>
    <input type="text" id="solar_system" name="solar_system" required>

    {{-- ... otros campos ... --}}

    <button type="submit">Lanzar</button>
</form>
```

La directiva `@csrf` generar√° autom√°ticamente un campo oculto en el formulario:
```html
<input type="hidden" name="_token" value="j2aK3dLf4gH5...—É–Ω–∏–∫–∞–ª—å–Ω—ã–π_—Ç–æ–∫–µ–Ω...">
```

Esto es suficiente para proteger formularios HTML est√°ndar.

---

### **4. Uso del token CSRF en solicitudes AJAX/Fetch**

En el cap√≠tulo anterior, enviamos una solicitud `DELETE` usando JavaScript. Ahora Laravel la bloquear√° con un error 419. Necesitamos a√±adir el token CSRF en los encabezados de nuestra solicitud Fetch.

**Paso 1: Hacer el token disponible para JavaScript**

A√±ade la metaetiqueta con el token en el `<head>` de tu plantilla maestra `resources/views/app.blade.php`. Esta es una pr√°ctica est√°ndar en Laravel.

```blade
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    {{-- A√±adimos el token CSRF en la metaetiqueta --}}
    <meta name="csrf-token" content="{{ csrf_token() }}">

    {{-- ... --}}
</head>
```

La funci√≥n `csrf_token()` devuelve el token actual.

**Paso 2: Modificamos JavaScript para enviar el token**

Ahora, en nuestro `public/js/planets.js` podemos leer este token y a√±adirlo a los encabezados de todas las solicitudes "inseguras".

```javascript
// ... en el archivo public/js/planets.js ...

document.addEventListener('DOMContentLoaded', () => {
    // Obtenemos el token de la metaetiqueta
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const deleteButtons = document.querySelectorAll('.delete-btn');

    deleteButtons.forEach(button => {
        button.addEventListener('click', async (event) => {
            // ... l√≥gica de confirmaci√≥n ...

            try {
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-TOKEN': csrfToken // <-- ¬°A√±adimos el token en los encabezados!
                    }
                });

                // ... el resto de la l√≥gica de procesamiento de la respuesta ...
            } catch (error) {
                // ...
            }
        });
    });
});
```

-   El nombre del encabezado `X-CSRF-TOKEN` es el est√°ndar que Laravel verifica por defecto.

Ahora nuestras solicitudes AJAX tambi√©n est√°n protegidas. Intenta eliminar el planeta de nuevo ‚Äî esta vez la solicitud se ejecutar√° correctamente.

---

### **Cuestionario para consolidar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. ¬øQu√© tipo de ataque previene el token CSRF?</p>
      <label><input type="radio" name="q1" value="a"> a) Inyecciones SQL</label>
      <label><input type="radio" name="q1" value="b"> b) Cross-site scripting</label>
      <label><input type="radio" name="q1" value="c"> c) Falsificaci√≥n de petici√≥n en sitios cruzados</label>
    </div>
    <div class="question">
      <p>2. ¬øQu√© directiva Blade a√±ade un campo oculto con el token CSRF a un formulario?</p>
      <label><input type="radio" name="q2" value="a"> a) @token</label>
      <label><input type="radio" name="q2" value="b"> b) @csrf</label>
      <label><input type="radio" name="q2" value="c"> c) @form_token</label>
    </div>
    <div class="question">
      <p>3. ¬øQu√© suceder√° si se env√≠a una solicitud POST sin un token CSRF a una ruta web?</p>
      <label><input type="radio" name="q3" value="a"> a) Error 500 (Internal Server Error)</label>
      <label><input type="radio" name="q3" value="b"> b) Error 403 (Forbidden)</label>
      <label><input type="radio" name="q3" value="c"> c) Error 419 (Page Expired / Session Expired)</label>
    </div>
    <div class="question">
      <p>4. ¬øQu√© encabezado HTTP est√°ndar se utiliza para enviar el token CSRF en solicitudes AJAX?</p>
      <label><input type="radio" name="q4" value="a"> a) Authorization</label>
      <label><input type="radio" name="q4" value="b"> b) X-CSRF-TOKEN</label>
      <label><input type="radio" name="q4" value="c"> c) Content-Type</label>
    </div>
    <div class="question">
      <p>5. ¬øPor qu√© las rutas API (`routes/api.php`) no utilizan la protecci√≥n CSRF por defecto?</p>
      <label><input type="radio" name="q5" value="a"> a) Porque est√°n dise√±adas para autenticaci√≥n sin estado</label>
      <label><input type="radio" name="q5" value="b"> b) Es un error en Laravel, deben habilitarse manualmente</label>
      <label><input type="radio" name="q5" value="c"> c) Porque las solicitudes API no pueden ser falsificadas</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'c', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---
**üöÄ Resumen del cap√≠tulo:**

Has instalado un "sistema de identificaci√≥n amigo-enemigo" en tu nave espacial, protegi√©ndola de ataques CSRF. Has aprendido a:

-   Comprender la esencia y el peligro de los ataques CSRF.
-   Proteger formularios HTML est√°ndar con la directiva `@csrf`.
-   Transferir el token CSRF a JavaScript a trav√©s de una metaetiqueta.
-   Incluir el token en las cabeceras de las solicitudes AJAX/Fetch para su ejecuci√≥n exitosa.

**Tus interfaces web ahora no solo son interactivas, sino tambi√©n seguras.** En el siguiente cap√≠tulo, completaremos la creaci√≥n de nuestra interfaz web, viendo c√≥mo organizar correctamente el enrutamiento para las p√°ginas web.
