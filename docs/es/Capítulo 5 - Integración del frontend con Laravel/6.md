# **Capítulo 5.6: Visualización de Datos con Blade + Fetch**
**Tiempo de estudio:** 50 minutos

---

### **1. Enfoque Híbrido: Lo mejor de dos mundos**

Podemos construir una página de dos maneras:

1.  **Renderizado Completo del Lado del Servidor (SSR):** Laravel genera todo el HTML, incluyendo la lista de planetas. Para cualquier actualización (eliminación, adición), la página se recarga completamente.
2.  **Renderizado Completo del Lado del Cliente (CSR):** Laravel entrega un "shell" HTML vacío, y JavaScript solicita todos los datos a la API y los renderiza en el cliente. (Este es el enfoque de Aplicación de Página Única - SPA).

**Nuestra elección es un enfoque híbrido:**

-   **Primera carga (SSR):** Laravel entrega inmediatamente la página con la lista de planetas ya preparada. Esto es rápido y bueno para el SEO. El usuario ve el contenido al instante.
-   **Acciones posteriores (CSR):** JavaScript intercepta las acciones del usuario (clics en botones) e interactúa con la API, actualizando solo las partes necesarias de la página, sin una recarga completa.

> 💡 **Analogía espacial:**

> Al entrar en el puente, se te entrega inmediatamente el mapa de navegación principal, impreso en el Centro de Control de Misión (SSR). Ya lo tienes en tus manos, no hay que esperar. Pero luego activas el "modo en vivo" en tu tableta (CSR), y esta comienza a recibir actualizaciones de los satélites en tiempo real, redibujando objetos en tu mapa.

---

### **2. Paso 1: Preparación de la página**

Trabajaremos con nuestra página de lista de planetas `resources/views/planets/index.blade.php`. Ya es capaz de mostrar los datos pasados desde el controlador. Ahora le añadiremos elementos de control que funcionarán a través de JS.

**Añadimos un botón "Actualizar lista" y un contenedor para notificaciones:**
```html
    <div class="controls">
        <h2>Lista de todos los planetas conocidos</h2>
        <button id="refresh-btn">Actualizar vía API</button>
    </div>
    <div id="notification-area" class="notification"></div>
    <hr>
    {{-- Este div será nuestro contenedor para la actualización dinámica --}}
    <div id="planet-list-container" class="planet-list">
        {{-- Incluimos la vista "hija" que renderiza la lista inicial --}}
        @include('planets.partials.list', ['planets' => $planets])
    </div>
```

Presta atención a `@include('planets.partials.list', ...)`. Hemos movido la lógica de visualización de la lista a un archivo separado y reutilizable.

---

### **Paso 2: Creación de una vista "parcial" (Partial) reutilizable**

Mover las partes repetidas a archivos separados es una buena práctica.

Crea el archivo `resources/views/planets/partials/list.blade.php`:

```blade
@forelse($planets as $planet)
    <div class="planet-card" id="planet-card-{{ $planet->id }}">
        <h3>{{ $planet->name }}</h3>
        <p>Sistema solar: {{ $planet->solar_system }}</p>
        <p>Diámetro: {{ number_format($planet->size_km, 0, '.', ' ') }} km</p>
        <a href="{{ route('planets.show', $planet) }}">Saber más &rarr;</a>
        <button class="delete-btn" data-id="{{ $planet->id }}" data-url="{{ route('api.planets.destroy', $planet) }}">
            Desmantelar
        </button>
    </div>
@empty
    <p>No hay ningún planeta en la base de datos.</p>
@endforelse
```

-   **Importante:** Ten en cuenta que la URL para el botón de eliminar ahora se genera para la ruta de la API: `route('api.planets.destroy', $planet)`. Para ello, asegúrate de tener un recurso nombrado en `routes/api.php`: `Route::apiResource('planets', ...)->name('api.planets');`

---

### **Paso 3: Escritura de JavaScript para la actualización dinámica**

Ahora lo más interesante. Crearemos un JavaScript que, al presionar un botón, solicitará una lista fresca de planetas a la API y la volverá a dibujar.

Crea el archivo `public/js/planet-manager.js` y conéctalo en `layouts/app.blade.php`.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refresh-btn');
    const planetListContainer = document.getElementById('planet-list-container');
    const notificationArea = document.getElementById('notification-area');

    // Función para mostrar notificaciones
    function showNotification(message, isError = false) {
        notificationArea.textContent = message;
        notificationArea.className = isError ? 'notification error' : 'notification success';
        setTimeout(() => {
            notificationArea.textContent = '';
            notificationArea.className = 'notification';
        }, 3000);
    }

    // Función para dibujar una sola tarjeta de planeta
    function createPlanetCardHtml(planet) {
        // IMPORTANTE: Generamos el mismo HTML que en nuestra vista parcial
        return `
            <div class="planet-card" id="planet-card-${planet.id}">
                <h3>${planet.name}</h3>
                <p>Sistema solar: ${planet.solar_system}</p>
                <p>Diámetro: ${new Intl.NumberFormat().format(planet.size_km)} km</p>
                <a href="/planets/${planet.id}">Saber más &rarr;</a>
                <button class="delete-btn" data-id="${planet.id}" data-url="/api/planets/${planet.id}">
                    Desmantelar (JS)
                </button>
            </div>
        `;
    }

    // Función para solicitar y volver a dibujar la lista de planetas
    async function fetchAndRenderPlanets() {
        showNotification('Solicitando datos frescos de los satélites orbitales...');
        try {
            const response = await fetch('/api/planets', {
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) {
                throw new Error('Error de red al obtener los datos.');
            }

            const planets = await response.json(); // Laravel por defecto devolverá { data: [...] } para un recurso paginado

            planetListContainer.innerHTML = ''; // Limpiamos la lista antigua

            if (planets.data.length === 0) {
                planetListContainer.innerHTML = '<p>No hay ningún planeta en la base de datos.</p>';
            } else {
                planets.data.forEach(planet => {
                    const cardHtml = createPlanetCardHtml(planet);
                    planetListContainer.innerHTML += cardHtml;
                });
            }
            showNotification('¡Datos actualizados con éxito!', false);
        } catch (error) {
            console.error('Error al actualizar la lista de planetas:', error);
            showNotification(error.message, true);
        }
    }

    // Adjuntamos el manejador al botón
    if (refreshBtn) {
        refreshBtn.addEventListener('click', fetchAndRenderPlanets);
    }

    // Aquí se podría mover la lógica de eliminación del capítulo anterior,
    // para que todo el JS esté en un solo lugar.
});
```

---

### **3. Verificación Final**

1.  **Inicia el servidor** (`php artisan serve` o asegúrate de que Herd esté funcionando).
2.  **Recrea la base de datos,** si es necesario: `php artisan migrate:fresh --seed`.
3.  **Abre la página `/planets`** en el navegador.
    -   Deberías ver inmediatamente la lista de planetas generada por el servidor.
4.  **Haz clic en el botón "Actualizar vía API"**.
    -   Verás una notificación de carga.
    -   La lista debería desaparecer por un momento y reaparecer, pero esta vez será generada por JavaScript basándose en los datos obtenidos de la API.

¡Has implementado con éxito el modelo híbrido!

---

### **Cuestionario para consolidar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. ¿Qué es un enfoque de renderizado híbrido (SSR + CSR)?</p>
      <label><input type="radio" name="q1" value="a"> a) Primero se renderiza una página vacía, luego JS carga todo el contenido</label>
      <label><input type="radio" name="q1" value="b"> b) El servidor entrega una página completamente lista, y esta nunca cambia en el cliente</label>
      <label><input type="radio" name="q1" value="c"> c) El servidor entrega una página lista para una carga inicial rápida, y las actualizaciones posteriores ocurren en el cliente a través de JS</label>
    </div>
    <div class="question">
      <p>2. ¿Cuál es la principal ventaja del renderizado inicial en el servidor (SSR)?</p>
      <label><input type="radio" name="q2" value="a"> a) Reducción de la carga en el servidor</label>
      <label><input type="radio" name="q2" value="b"> b) Renderizado rápido del contenido inicial para el usuario y buena indexación SEO</label>
      <label><input type="radio" name="q2" value="c"> c) Simplificación del código JavaScript</label>
    </div>
    <div class="question">
      <p>3. ¿Por qué se utiliza `@include('planets.partials.list')` en el ejemplo?</p>
      <label><input type="radio" name="q3" value="a"> a) Es un requisito de Blade para bucles</label>
      <label><input type="radio" name="q3" value="b"> b) Para la reutilización de código y la separación de la lógica de visualización de la lista</label>
      <label><input type="radio" name="q3" value="c"> c) Para la carga asíncrona de una parte de la página</label>
    </div>
    <div class="question">
      <p>4. En el código JavaScript, duplicamos la estructura HTML de la tarjeta. ¿Cuál podría ser una forma más avanzada de evitar esto?</p>
      <label><input type="radio" name="q4" value="a"> a) Solicitar a la API no JSON, sino HTML ya renderizado para una sola tarjeta</label>
      <label><input type="radio" name="q4" value="b"> b) Usar motor de plantillas JavaScript (como Mustache, Handlebars) o frameworks (Vue, React)</label>
      <label><input type="radio" name="q4" value="c"> c) Ambas opciones son correctas</label>
    </div>
    <div class="question">
      <p>5. ¿Por qué es importante que la API (`/api/planets`) y el código JavaScript (`createPlanetCardHtml`) generen datos/HTML consistentes?</p>
      <label><input type="radio" name="q5" value="a"> a) De lo contrario, el usuario verá un "salto" o cambio en la interfaz al actualizar a través de la API</label>
      <label><input type="radio" name="q5" value="b"> b) Esto es un requisito de la especificación Fetch API</label>
      <label><input type="radio" name="q5" value="c"> c) De lo contrario, Laravel devolverá un error 500</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'c', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¡Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 ¡Felicitaciones por completar el Capítulo 5!**

Has recorrido un largo camino desde los fundamentos de Blade hasta la creación de páginas híbridas interactivas. Has aprendido a:

-   Crear y usar plantillas y diseños de Blade.
-   Organizar rutas web y controladores para operaciones CRUD.
-   Proteger formularios web y solicitudes AJAX con tokens CSRF.
-   Integrar JavaScript para la interacción dinámica con la API sin recargar la página.

**Tu Centro de Control de Vuelo es completamente funcional, seguro e interactivo.** Estás listo para la siguiente gran etapa: comparar este enfoque con otros frameworks y aprender las mejores prácticas para producción.
