# **Cap칤tulo 5.6: Visualizaci칩n de Datos con Blade + Fetch**
**Tiempo de estudio:** 50 minutos

---

### **1. Enfoque H칤brido: Lo mejor de dos mundos**

Podemos construir una p치gina de dos maneras:

1.  **Renderizado Completo del Lado del Servidor (SSR):** Laravel genera todo el HTML, incluyendo la lista de planetas. Para cualquier actualizaci칩n (eliminaci칩n, adici칩n), la p치gina se recarga completamente.
2.  **Renderizado Completo del Lado del Cliente (CSR):** Laravel entrega un "shell" HTML vac칤o, y JavaScript solicita todos los datos a la API y los renderiza en el cliente. (Este es el enfoque de Aplicaci칩n de P치gina 칔nica - SPA).

**Nuestra elecci칩n es un enfoque h칤brido:**

-   **Primera carga (SSR):** Laravel entrega inmediatamente la p치gina con la lista de planetas ya preparada. Esto es r치pido y bueno para el SEO. El usuario ve el contenido al instante.
-   **Acciones posteriores (CSR):** JavaScript intercepta las acciones del usuario (clics en botones) e interact칰a con la API, actualizando solo las partes necesarias de la p치gina, sin una recarga completa.

> 游눠 **Analog칤a espacial:**

> Al entrar en el puente, se te entrega inmediatamente el mapa de navegaci칩n principal, impreso en el Centro de Control de Misi칩n (SSR). Ya lo tienes en tus manos, no hay que esperar. Pero luego activas el "modo en vivo" en tu tableta (CSR), y esta comienza a recibir actualizaciones de los sat칠lites en tiempo real, redibujando objetos en tu mapa.

---

### **2. Paso 1: Preparaci칩n de la p치gina**

Trabajaremos con nuestra p치gina de lista de planetas `resources/views/planets/index.blade.php`. Ya es capaz de mostrar los datos pasados desde el controlador. Ahora le a침adiremos elementos de control que funcionar치n a trav칠s de JS.

**A침adimos un bot칩n "Actualizar lista" y un contenedor para notificaciones:**
```html
    <div class="controls">
        <h2>Lista de todos los planetas conocidos</h2>
        <button id="refresh-btn">Actualizar v칤a API</button>
    </div>
    <div id="notification-area" class="notification"></div>
    <hr>
    {{-- Este div ser치 nuestro contenedor para la actualizaci칩n din치mica --}}
    <div id="planet-list-container" class="planet-list">
        {{-- Incluimos la vista "hija" que renderiza la lista inicial --}}
        @include('planets.partials.list', ['planets' => $planets])
    </div>
```

Presta atenci칩n a `@include('planets.partials.list', ...)`. Hemos movido la l칩gica de visualizaci칩n de la lista a un archivo separado y reutilizable.

---

### **Paso 2: Creaci칩n de una vista "parcial" (Partial) reutilizable**

Mover las partes repetidas a archivos separados es una buena pr치ctica.

Crea el archivo `resources/views/planets/partials/list.blade.php`:

```blade
@forelse($planets as $planet)
    <div class="planet-card" id="planet-card-{{ $planet->id }}">
        <h3>{{ $planet->name }}</h3>
        <p>Sistema solar: {{ $planet->solar_system }}</p>
        <p>Di치metro: {{ number_format($planet->size_km, 0, '.', ' ') }} km</p>
        <a href="{{ route('planets.show', $planet) }}">Saber m치s &rarr;</a>
        <button class="delete-btn" data-id="{{ $planet->id }}" data-url="{{ route('api.planets.destroy', $planet) }}">
            Desmantelar
        </button>
    </div>
@empty
    <p>No hay ning칰n planeta en la base de datos.</p>
@endforelse
```

-   **Importante:** Ten en cuenta que la URL para el bot칩n de eliminar ahora se genera para la ruta de la API: `route('api.planets.destroy', $planet)`. Para ello, aseg칰rate de tener un recurso nombrado en `routes/api.php`: `Route::apiResource('planets', ...)->name('api.planets');`

---

### **Paso 3: Escritura de JavaScript para la actualizaci칩n din치mica**

Ahora lo m치s interesante. Crearemos un JavaScript que, al presionar un bot칩n, solicitar치 una lista fresca de planetas a la API y la volver치 a dibujar.

Crea el archivo `public/js/planet-manager.js` y con칠ctalo en `layouts/app.blade.php`.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refresh-btn');
    const planetListContainer = document.getElementById('planet-list-container');
    const notificationArea = document.getElementById('notification-area');

    // Funci칩n para mostrar notificaciones
    function showNotification(message, isError = false) {
        notificationArea.textContent = message;
        notificationArea.className = isError ? 'notification error' : 'notification success';
        setTimeout(() => {
            notificationArea.textContent = '';
            notificationArea.className = 'notification';
        }, 3000);
    }

    // Funci칩n para dibujar una sola tarjeta de planeta
    function createPlanetCardHtml(planet) {
        // IMPORTANTE: Generamos el mismo HTML que en nuestra vista parcial
        return `
            <div class="planet-card" id="planet-card-${planet.id}">
                <h3>${planet.name}</h3>
                <p>Sistema solar: ${planet.solar_system}</p>
                <p>Di치metro: ${new Intl.NumberFormat().format(planet.size_km)} km</p>
                <a href="/planets/${planet.id}">Saber m치s &rarr;</a>
                <button class="delete-btn" data-id="${planet.id}" data-url="/api/planets/${planet.id}">
                    Desmantelar (JS)
                </button>
            </div>
        `;
    }

    // Funci칩n para solicitar y volver a dibujar la lista de planetas
    async function fetchAndRenderPlanets() {
        showNotification('Solicitando datos frescos de los sat칠lites orbitales...');
        try {
            const response = await fetch('/api/planets', {
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) {
                throw new Error('Error de red al obtener los datos.');
            }

            const planets = await response.json(); // Laravel por defecto devolver치 { data: [...] } para un recurso paginado

            planetListContainer.innerHTML = ''; // Limpiamos la lista antigua

            if (planets.data.length === 0) {
                planetListContainer.innerHTML = '<p>No hay ning칰n planeta en la base de datos.</p>';
            } else {
                planets.data.forEach(planet => {
                    const cardHtml = createPlanetCardHtml(planet);
                    planetListContainer.innerHTML += cardHtml;
                });
            }
            showNotification('춰Datos actualizados con 칠xito!', false);
        } catch (error) {
            console.error('Error al actualizar la lista de planetas:', error);
            showNotification(error.message, true);
        }
    }

    // Adjuntamos el manejador al bot칩n
    if (refreshBtn) {
        refreshBtn.addEventListener('click', fetchAndRenderPlanets);
    }

    // Aqu칤 se podr칤a mover la l칩gica de eliminaci칩n del cap칤tulo anterior,
    // para que todo el JS est칠 en un solo lugar.
});
```

---

### **3. Verificaci칩n Final**

1.  **Inicia el servidor** (`php artisan serve` o aseg칰rate de que Herd est칠 funcionando).
2.  **Recrea la base de datos,** si es necesario: `php artisan migrate:fresh --seed`.
3.  **Abre la p치gina `/planets`** en el navegador.
    -   Deber칤as ver inmediatamente la lista de planetas generada por el servidor.
4.  **Haz clic en el bot칩n "Actualizar v칤a API"**.
    -   Ver치s una notificaci칩n de carga.
    -   La lista deber칤a desaparecer por un momento y reaparecer, pero esta vez ser치 generada por JavaScript bas치ndose en los datos obtenidos de la API.

춰Has implementado con 칠xito el modelo h칤brido!

---

### **Cuestionario para consolidar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. 쯈u칠 es un enfoque de renderizado h칤brido (SSR + CSR)?</p>
      <label><input type="radio" name="q1" value="a"> a) Primero se renderiza una p치gina vac칤a, luego JS carga todo el contenido</label>
      <label><input type="radio" name="q1" value="b"> b) El servidor entrega una p치gina completamente lista, y esta nunca cambia en el cliente</label>
      <label><input type="radio" name="q1" value="c"> c) El servidor entrega una p치gina lista para una carga inicial r치pida, y las actualizaciones posteriores ocurren en el cliente a trav칠s de JS</label>
    </div>
    <div class="question">
      <p>2. 쮺u치l es la principal ventaja del renderizado inicial en el servidor (SSR)?</p>
      <label><input type="radio" name="q2" value="a"> a) Reducci칩n de la carga en el servidor</label>
      <label><input type="radio" name="q2" value="b"> b) Renderizado r치pido del contenido inicial para el usuario y buena indexaci칩n SEO</label>
      <label><input type="radio" name="q2" value="c"> c) Simplificaci칩n del c칩digo JavaScript</label>
    </div>
    <div class="question">
      <p>3. 쯇or qu칠 se utiliza `@include('planets.partials.list')` en el ejemplo?</p>
      <label><input type="radio" name="q3" value="a"> a) Es un requisito de Blade para bucles</label>
      <label><input type="radio" name="q3" value="b"> b) Para la reutilizaci칩n de c칩digo y la separaci칩n de la l칩gica de visualizaci칩n de la lista</label>
      <label><input type="radio" name="q3" value="c"> c) Para la carga as칤ncrona de una parte de la p치gina</label>
    </div>
    <div class="question">
      <p>4. En el c칩digo JavaScript, duplicamos la estructura HTML de la tarjeta. 쮺u치l podr칤a ser una forma m치s avanzada de evitar esto?</p>
      <label><input type="radio" name="q4" value="a"> a) Solicitar a la API no JSON, sino HTML ya renderizado para una sola tarjeta</label>
      <label><input type="radio" name="q4" value="b"> b) Usar motor de plantillas JavaScript (como Mustache, Handlebars) o frameworks (Vue, React)</label>
      <label><input type="radio" name="q4" value="c"> c) Ambas opciones son correctas</label>
    </div>
    <div class="question">
      <p>5. 쯇or qu칠 es importante que la API (`/api/planets`) y el c칩digo JavaScript (`createPlanetCardHtml`) generen datos/HTML consistentes?</p>
      <label><input type="radio" name="q5" value="a"> a) De lo contrario, el usuario ver치 un "salto" o cambio en la interfaz al actualizar a trav칠s de la API</label>
      <label><input type="radio" name="q5" value="b"> b) Esto es un requisito de la especificaci칩n Fetch API</label>
      <label><input type="radio" name="q5" value="c"> c) De lo contrario, Laravel devolver치 un error 500</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'c', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">춰Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**游 춰Felicitaciones por completar el Cap칤tulo 5!**

Has recorrido un largo camino desde los fundamentos de Blade hasta la creaci칩n de p치ginas h칤bridas interactivas. Has aprendido a:

-   Crear y usar plantillas y dise침os de Blade.
-   Organizar rutas web y controladores para operaciones CRUD.
-   Proteger formularios web y solicitudes AJAX con tokens CSRF.
-   Integrar JavaScript para la interacci칩n din치mica con la API sin recargar la p치gina.

**Tu Centro de Control de Vuelo es completamente funcional, seguro e interactivo.** Est치s listo para la siguiente gran etapa: comparar este enfoque con otros frameworks y aprender las mejores pr치cticas para producci칩n.
