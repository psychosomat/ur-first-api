# **Capítulo 4.5: Async/await vs Promise**
**Tiempo de estudio:** 30 minutos

---

#### **1. Asincronía: Dos formas de gestionar la "comunicación espacial"**
Imagina que el Centro de Control de Misiones (MCC) envía una orden a Marte. La respuesta tardará varios minutos en llegar. ¿Cómo organizar el trabajo durante ese tiempo?

**Método 1: "Protocolo de devolución de llamada" (Promise con `.then()`)**
Envías una orden y das una instrucción: "**CUANDO** llegue la respuesta, **ENTONCES** ejecuta esta función". Esto se asemeja a una cadena de eventos.

**Método 2: "Modo de espera" (Async/await)**
Dices: "Esperaré la respuesta a esta orden, pero no bloquearé otros paneles de control". Es como si pausaras la ejecución de *esta tarea específica*, permitiendo que el resto del MCC siga funcionando.

Ambos métodos resuelven la misma tarea: gestionar operaciones asíncronas. `async/await` es simplemente una sintaxis más moderna y legible que funciona "sobre" las promesas.

> 💡 **Analogía espacial:**

> - **Promise con `.then()`**: Es como escribir en un post-it: "Cuando el rover de Marte envíe una foto, pásala al departamento de análisis".
> - **Async/await**: Es como decirle a un asistente: "Espera la foto del rover de Marte, mientras yo me ocupo de los cálculos para el lanzamiento de un nuevo cohete".

---

#### **2. Promise con `.then()`: Cadena de comandos clásica**
Esta es la forma fundamental de trabajar con la asincronía en JavaScript, que utilizamos en el capítulo 4.1.

**Recordemos nuestro primer código:**
```javascript
function getIssPositionWithPromises() {
    console.log('Enviando solicitud mediante el protocolo "Promise"...');

    fetch('http://api.open-notify.org/iss-now.json')
        .then(response => {
            // Etapa 1: Respuesta recibida
            if (!response.ok) {
                throw new Error(`Error HTTP: ${response.status}`);
            }
            return response.json(); // Devolvemos una nueva promesa
        })
        .then(data => {
            // Etapa 2: Datos parseados
            console.log('Datos recibidos mediante el protocolo "Promise":', data.iss_position);
        })
        .catch(error => {
            // Etapa 3 (Error): Algo salió mal en alguna de las etapas
            console.error('Fallo de comunicación mediante el protocolo "Promise":', error);
        });

    console.log('...comando enviado, el MCC sigue trabajando...');
}
```

**Ventajas:**

- Cadena de acciones explícita.
- Adecuado para operaciones secuenciales simples.

**Desventajas:**

- **"Infierno de las devoluciones de llamada" (Callback Hell):** Con un gran número de operaciones asíncronas anidadas, el código puede convertirse en una "escalera" de `.then()` difícil de leer.
- El manejo de errores puede ser menos intuitivo.

---

#### **3. Async/await: Estilo síncrono moderno**
`async/await` es "azúcar sintáctico" sobre las promesas, que permite escribir código asíncrono como si fuera síncrono.

**Reglas de uso:**

1.  La palabra clave `await` solo se puede usar **dentro de una función** marcada como `async`.
2.  `await` se coloca antes de una llamada que devuelve una promesa (por ejemplo, `fetch()` o `response.json()`).
3.  `await` "pausa" la ejecución de la función `async` hasta que la promesa se resuelva y devuelve su resultado.

**El mismo código, reescrito con `async/await`:**
```javascript
async function getIssPositionWithAsyncAwait() {
    console.log('Enviando solicitud mediante el protocolo "Async/await"...');

    try {
        // Etapa 1: Esperamos la respuesta del servidor
        const response = await fetch('http://api.open-notify.org/iss-now.json');

        if (!response.ok) {
            throw new Error(`Error HTTP: ${response.status}`);
        }

        // Etapa 2: Esperamos a que el cuerpo de la respuesta se convierta a JSON
        const data = await response.json();

        console.log('Datos recibidos mediante el protocolo "Async/await":', data.iss_position);
    } catch (error) {
        // Etapa 3 (Error): Capturamos cualquier error del bloque try
        console.error('Fallo de comunicación mediante el protocolo "Async/await":', error);
    }

    console.log('...comando enviado, el MCC sigue trabajando...');
}
```

**Ventajas:**

- **Legibilidad:** El código se ve casi como código síncrono normal, es fácil de leer de arriba abajo.
- **Manejo de errores:** Se utiliza el bloque `try...catch` estándar y familiar.
- **Depuración:** Es mucho más fácil de depurar, ya que se pueden establecer puntos de interrupción (breakpoints) en cada línea con `await`.

**Desventajas:**

- Es fácil olvidar `await` o `async`, lo que provocará errores.

---

#### **4. ¿Cuándo usar qué protocolo?**

| Situación | Enfoque recomendado | ¿Por qué? |
|---|---|---|
| **La mayoría de los casos** | **`async/await`** | El código es más limpio, más fácil de leer y depurar. Es el estándar moderno. |
| **Cadena simple de 1-2 acciones** | Promise con `.then()` | Funciona bien, el código sigue siendo compacto. |
| **Ejecución paralela de múltiples solicitudes** | `Promise.all()` | Este método permite ejecutar varias promesas simultáneamente y esperar a que todas se completen. `async/await` se combina perfectamente con él. |

**Ejemplo con `Promise.all()`:**
```javascript
async function getParallelData() {
    try {
        // Iniciamos ambas solicitudes simultáneamente
        const [shipsResponse, launchesResponse] = await Promise.all([
            fetch('https://api.spacexdata.com/v4/rockets'),
            fetch('https://api.spacexdata.com/v4/launches/latest')
        ]);

        if (!shipsResponse.ok || !launchesResponse.ok) {
            throw new Error('¡Una de las solicitudes falló!');
        }

        const rockets = await shipsResponse.json();
        const latestLaunch = await launchesResponse.json();

        console.log(`Total de cohetes en la flota: ${rockets.length}`);
        console.log(`Último lanzamiento: ${latestLaunch.name}`);
    } catch (error) {
        console.error('Error al obtener datos paralelos:', error);
    }
}
```

---

#### **Cuestionario de refuerzo**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. `async/await` es...</p>
      <label><input type="radio" name="q1" value="a"> a) Un reemplazo para las promesas que funciona de manera diferente</label>
      <label><input type="radio" name="q1" value="b"> b) Una sintaxis más conveniente para trabajar con promesas</label>
      <label><input type="radio" name="q1" value="c"> c) Una forma de hacer que JavaScript sea síncrono</label>
    </div>
    <div class="question">
      <p>2. ¿Qué palabra clave es obligatoria para una función dentro de la cual se utiliza `await`?</p>
      <label><input type="radio" name="q2" value="a"> a) `promise`</label>
      <label><input type="radio" name="q2" value="b"> b) `function`</label>
      <label><input type="radio" name="q2" value="c"> c) `async`</label>
    </div>
    <div class="question">
      <p>3. La principal ventaja de `async/await` sobre `.then()`:</p>
      <label><input type="radio" name="q3" value="a"> a) Mayor velocidad de ejecución</label>
      <label><input type="radio" name="q3" value="b"> b) Mejor legibilidad del código y manejo conveniente de errores a través de `try...catch`</label>
      <label><input type="radio" name="q3" value="c"> c) Funciona en navegadores antiguos sin polyfills</label>
    </div>
    <div class="question">
      <p>4. ¿Qué ocurrirá si se olvida `await` antes de `fetch()` dentro de una función `async`?</p>
      <label><input type="radio" name="q4" value="a"> a) El código se ejecutará sin errores, pero la variable contendrá una promesa en lugar del resultado</label>
      <label><input type="radio" name="q4" value="b"> b) JavaScript emitirá un error de sintaxis</label>
      <label><input type="radio" name="q4" value="c"> c) La página se "colgará" esperando una respuesta</label>
    </div>
    <div class="question">
      <p>5. `Promise.all()` se utiliza para:</p>
      <label><input type="radio" name="q5" value="a"> a) Ejecutar promesas estrictamente en orden</label>
      <label><input type="radio" name="q5" value="b"> b) Iniciar varias promesas en paralelo y esperar a que todas se completen</label>
      <label><input type="radio" name="q5" value="c"> c) Elegir la más rápida de varias promesas</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¡Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 Resumen del capítulo:**

Has aprendido dos sintaxis para gestionar operaciones asíncronas y entendido por qué `async/await` es la preferida en la mayoría de los proyectos modernos.

- 🔗 Has refrescado tus conocimientos sobre **Promise con `.then()`**.
- 🛠️ Has comprendido en profundidad cómo funciona **`async/await`** y sus ventajas.
- ⚡ Has aprendido sobre `Promise.all` para ejecutar peticiones paralelas.

**¡Protocolos de comunicación aprendidos!** En el capítulo final de esta sección, uniremos todos nuestros conocimientos y construiremos nuestro "Centro de Control de Vuelo", creando una interfaz completa para todas las operaciones CRUD.

> **📌 Práctica:**

> - Reescribe todas las funciones en tu `app.js` que aún utilizan `.then()` al sintaxis `async/await`.
> - Intenta añadir otra petición en `Promise.all()` (por ejemplo, a `https://api.spacexdata.com/v4/starlink`) y muestra los datos.

> **⚠️ Si hay errores:**

> - `await is only valid in async functions`: Asegúrate de que la función donde utilizas `await` esté marcada como `async`.
> - La variable contiene `[object Promise]`: Has olvidado poner `await` delante de la función que devuelve una promesa.
```
