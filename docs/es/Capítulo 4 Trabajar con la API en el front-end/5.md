# **Cap√≠tulo 4.5: Async/await vs Promise**
**Tiempo de estudio:** 30 minutos

---

#### **1. Asincron√≠a: Dos formas de gestionar la "comunicaci√≥n espacial"**
Imagina que el Centro de Control de Misiones (MCC) env√≠a una orden a Marte. La respuesta tardar√° varios minutos en llegar. ¬øC√≥mo organizar el trabajo durante ese tiempo?

**M√©todo 1: "Protocolo de devoluci√≥n de llamada" (Promise con `.then()`)**
Env√≠as una orden y das una instrucci√≥n: "**CUANDO** llegue la respuesta, **ENTONCES** ejecuta esta funci√≥n". Esto se asemeja a una cadena de eventos.

**M√©todo 2: "Modo de espera" (Async/await)**
Dices: "Esperar√© la respuesta a esta orden, pero no bloquear√© otros paneles de control". Es como si pausaras la ejecuci√≥n de *esta tarea espec√≠fica*, permitiendo que el resto del MCC siga funcionando.

Ambos m√©todos resuelven la misma tarea: gestionar operaciones as√≠ncronas. `async/await` es simplemente una sintaxis m√°s moderna y legible que funciona "sobre" las promesas.

> üí° **Analog√≠a espacial:**

> - **Promise con `.then()`**: Es como escribir en un post-it: "Cuando el rover de Marte env√≠e una foto, p√°sala al departamento de an√°lisis".
> - **Async/await**: Es como decirle a un asistente: "Espera la foto del rover de Marte, mientras yo me ocupo de los c√°lculos para el lanzamiento de un nuevo cohete".

---

#### **2. Promise con `.then()`: Cadena de comandos cl√°sica**
Esta es la forma fundamental de trabajar con la asincron√≠a en JavaScript, que utilizamos en el cap√≠tulo 4.1.

**Recordemos nuestro primer c√≥digo:**
```javascript
function getIssPositionWithPromises() {
    console.log('Enviando solicitud mediante el protocolo "Promise"...');

    fetch('http://api.open-notify.org/iss-now.json')
        .then(response => {
            // Etapa 1: Respuesta recibida
            if (!response.ok) {
                throw new Error(`Error HTTP: ${response.status}`);
            }
            return response.json(); // Devolvemos una nueva promesa
        })
        .then(data => {
            // Etapa 2: Datos parseados
            console.log('Datos recibidos mediante el protocolo "Promise":', data.iss_position);
        })
        .catch(error => {
            // Etapa 3 (Error): Algo sali√≥ mal en alguna de las etapas
            console.error('Fallo de comunicaci√≥n mediante el protocolo "Promise":', error);
        });

    console.log('...comando enviado, el MCC sigue trabajando...');
}
```

**Ventajas:**

- Cadena de acciones expl√≠cita.
- Adecuado para operaciones secuenciales simples.

**Desventajas:**

- **"Infierno de las devoluciones de llamada" (Callback Hell):** Con un gran n√∫mero de operaciones as√≠ncronas anidadas, el c√≥digo puede convertirse en una "escalera" de `.then()` dif√≠cil de leer.
- El manejo de errores puede ser menos intuitivo.

---

#### **3. Async/await: Estilo s√≠ncrono moderno**
`async/await` es "az√∫car sint√°ctico" sobre las promesas, que permite escribir c√≥digo as√≠ncrono como si fuera s√≠ncrono.

**Reglas de uso:**

1.  La palabra clave `await` solo se puede usar **dentro de una funci√≥n** marcada como `async`.
2.  `await` se coloca antes de una llamada que devuelve una promesa (por ejemplo, `fetch()` o `response.json()`).
3.  `await` "pausa" la ejecuci√≥n de la funci√≥n `async` hasta que la promesa se resuelva y devuelve su resultado.

**El mismo c√≥digo, reescrito con `async/await`:**
```javascript
async function getIssPositionWithAsyncAwait() {
    console.log('Enviando solicitud mediante el protocolo "Async/await"...');

    try {
        // Etapa 1: Esperamos la respuesta del servidor
        const response = await fetch('http://api.open-notify.org/iss-now.json');

        if (!response.ok) {
            throw new Error(`Error HTTP: ${response.status}`);
        }

        // Etapa 2: Esperamos a que el cuerpo de la respuesta se convierta a JSON
        const data = await response.json();

        console.log('Datos recibidos mediante el protocolo "Async/await":', data.iss_position);
    } catch (error) {
        // Etapa 3 (Error): Capturamos cualquier error del bloque try
        console.error('Fallo de comunicaci√≥n mediante el protocolo "Async/await":', error);
    }

    console.log('...comando enviado, el MCC sigue trabajando...');
}
```

**Ventajas:**

- **Legibilidad:** El c√≥digo se ve casi como c√≥digo s√≠ncrono normal, es f√°cil de leer de arriba abajo.
- **Manejo de errores:** Se utiliza el bloque `try...catch` est√°ndar y familiar.
- **Depuraci√≥n:** Es mucho m√°s f√°cil de depurar, ya que se pueden establecer puntos de interrupci√≥n (breakpoints) en cada l√≠nea con `await`.

**Desventajas:**

- Es f√°cil olvidar `await` o `async`, lo que provocar√° errores.

---

#### **4. ¬øCu√°ndo usar qu√© protocolo?**

| Situaci√≥n | Enfoque recomendado | ¬øPor qu√©? |
|---|---|---|
| **La mayor√≠a de los casos** | **`async/await`** | El c√≥digo es m√°s limpio, m√°s f√°cil de leer y depurar. Es el est√°ndar moderno. |
| **Cadena simple de 1-2 acciones** | Promise con `.then()` | Funciona bien, el c√≥digo sigue siendo compacto. |
| **Ejecuci√≥n paralela de m√∫ltiples solicitudes** | `Promise.all()` | Este m√©todo permite ejecutar varias promesas simult√°neamente y esperar a que todas se completen. `async/await` se combina perfectamente con √©l. |

**Ejemplo con `Promise.all()`:**
```javascript
async function getParallelData() {
    try {
        // Iniciamos ambas solicitudes simult√°neamente
        const [shipsResponse, launchesResponse] = await Promise.all([
            fetch('https://api.spacexdata.com/v4/rockets'),
            fetch('https://api.spacexdata.com/v4/launches/latest')
        ]);

        if (!shipsResponse.ok || !launchesResponse.ok) {
            throw new Error('¬°Una de las solicitudes fall√≥!');
        }

        const rockets = await shipsResponse.json();
        const latestLaunch = await launchesResponse.json();

        console.log(`Total de cohetes en la flota: ${rockets.length}`);
        console.log(`√öltimo lanzamiento: ${latestLaunch.name}`);
    } catch (error) {
        console.error('Error al obtener datos paralelos:', error);
    }
}
```

---

#### **Cuestionario de refuerzo**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. `async/await` es...</p>
      <label><input type="radio" name="q1" value="a"> a) Un reemplazo para las promesas que funciona de manera diferente</label>
      <label><input type="radio" name="q1" value="b"> b) Una sintaxis m√°s conveniente para trabajar con promesas</label>
      <label><input type="radio" name="q1" value="c"> c) Una forma de hacer que JavaScript sea s√≠ncrono</label>
    </div>
    <div class="question">
      <p>2. ¬øQu√© palabra clave es obligatoria para una funci√≥n dentro de la cual se utiliza `await`?</p>
      <label><input type="radio" name="q2" value="a"> a) `promise`</label>
      <label><input type="radio" name="q2" value="b"> b) `function`</label>
      <label><input type="radio" name="q2" value="c"> c) `async`</label>
    </div>
    <div class="question">
      <p>3. La principal ventaja de `async/await` sobre `.then()`:</p>
      <label><input type="radio" name="q3" value="a"> a) Mayor velocidad de ejecuci√≥n</label>
      <label><input type="radio" name="q3" value="b"> b) Mejor legibilidad del c√≥digo y manejo conveniente de errores a trav√©s de `try...catch`</label>
      <label><input type="radio" name="q3" value="c"> c) Funciona en navegadores antiguos sin polyfills</label>
    </div>
    <div class="question">
      <p>4. ¬øQu√© ocurrir√° si se olvida `await` antes de `fetch()` dentro de una funci√≥n `async`?</p>
      <label><input type="radio" name="q4" value="a"> a) El c√≥digo se ejecutar√° sin errores, pero la variable contendr√° una promesa en lugar del resultado</label>
      <label><input type="radio" name="q4" value="b"> b) JavaScript emitir√° un error de sintaxis</label>
      <label><input type="radio" name="q4" value="c"> c) La p√°gina se "colgar√°" esperando una respuesta</label>
    </div>
    <div class="question">
      <p>5. `Promise.all()` se utiliza para:</p>
      <label><input type="radio" name="q5" value="a"> a) Ejecutar promesas estrictamente en orden</label>
      <label><input type="radio" name="q5" value="b"> b) Iniciar varias promesas en paralelo y esperar a que todas se completen</label>
      <label><input type="radio" name="q5" value="c"> c) Elegir la m√°s r√°pida de varias promesas</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumen del cap√≠tulo:**

Has aprendido dos sintaxis para gestionar operaciones as√≠ncronas y entendido por qu√© `async/await` es la preferida en la mayor√≠a de los proyectos modernos.

- üîó Has refrescado tus conocimientos sobre **Promise con `.then()`**.
- üõ†Ô∏è Has comprendido en profundidad c√≥mo funciona **`async/await`** y sus ventajas.
- ‚ö° Has aprendido sobre `Promise.all` para ejecutar peticiones paralelas.

**¬°Protocolos de comunicaci√≥n aprendidos!** En el cap√≠tulo final de esta secci√≥n, uniremos todos nuestros conocimientos y construiremos nuestro "Centro de Control de Vuelo", creando una interfaz completa para todas las operaciones CRUD.

> **üìå Pr√°ctica:**

> - Reescribe todas las funciones en tu `app.js` que a√∫n utilizan `.then()` al sintaxis `async/await`.
> - Intenta a√±adir otra petici√≥n en `Promise.all()` (por ejemplo, a `https://api.spacexdata.com/v4/starlink`) y muestra los datos.

> **‚ö†Ô∏è Si hay errores:**

> - `await is only valid in async functions`: Aseg√∫rate de que la funci√≥n donde utilizas `await` est√© marcada como `async`.
> - La variable contiene `[object Promise]`: Has olvidado poner `await` delante de la funci√≥n que devuelve una promesa.
```
