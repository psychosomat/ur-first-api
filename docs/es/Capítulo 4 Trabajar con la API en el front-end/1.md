# **Cap√≠tulo 4.1: Fundamentos de la API Fetch**
**Tiempo de estudio:** 45 minutos

---

#### **1. API Fetch: La "Antena Principal" del Centro de Control de Misiones**
Imagina que en tu Centro de Control de Misiones tienes una **enorme antena de radio** para comunicarte con las naves espaciales. Puedes ajustarla a la frecuencia correcta, enviar un comando y esperar una respuesta.

La **API Fetch** es una "antena incorporada" similar en los navegadores modernos. Es una interfaz est√°ndar de JavaScript para realizar solicitudes HTTP a los servidores. Permite:

- üì° Enviar "comandos" (GET, POST, PUT, DELETE) a nuestra API.
- üõ∞Ô∏è Recibir "telemetr√≠a" (datos JSON) del servidor.
- ‚öôÔ∏è Trabajar de forma as√≠ncrona, sin "congelar" la interfaz de usuario mientras se espera una respuesta.

> üí° **Analog√≠a espacial:**

> `fetch()` es el comando "¬°Antena, establecer comunicaci√≥n!". Le pasas:

> - **Coordenadas del objetivo** (URL de nuestra API).
> - **Tipo de comando** (m√©todo: GET, POST).
> - **Contenido del comando** (cuerpo de la solicitud, cabeceras).

> En respuesta, no recibes los datos directamente, sino una **promesa (Promise)** de que los datos llegar√°n.

---

#### **2. Asincron√≠a: Comunicaci√≥n a velocidades de la luz**
La comunicaci√≥n con una nave espacial lejana lleva tiempo. No puedes simplemente detener todo el trabajo del Centro de Control de Misiones y esperar a que llegue una respuesta. Env√≠as un comando y **contin√∫as trabajando**, y cuando la respuesta llega, el sistema te notifica.

Esto es la **asincron√≠a**. JavaScript no bloquea la ejecuci√≥n del resto del c√≥digo mientras espera una respuesta del servidor. Para gestionar este proceso, la API Fetch utiliza **Promesas (Promises)**.

Una **Promesa (Promise)** es un "recibo" de que has enviado una solicitud. Tiene tres estados:

- **`pending` (pendiente):** La se√±al a√∫n est√° en camino.
- **`fulfilled` (cumplida):** ¬°Respuesta recibida con √©xito!
- **`rejected` (rechazada):** Ocurri√≥ un error (por ejemplo, sin conexi√≥n).

---

#### **3. Primera solicitud: Averiguar d√≥nde est√° la ISS**
Vamos a enviar nuestra primera solicitud usando `fetch`. Utilizaremos un simple archivo HTML y etiquetas `<script>`.

**Paso 1: Crear `index.html`**
Crea un archivo `index.html` en una nueva carpeta (por ejemplo, `frontend_fleet_control`).
```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Centro de Control de Misiones - Fetch API</title>
</head>
<body>
    <h1>Estado de la comunicaci√≥n con la ISS</h1>
    <div id="iss-status">Esperando datos...</div>

    <script>
        // Nuestro c√≥digo JavaScript ir√° aqu√≠
    </script>
</body>
</html>
```

**Paso 2: Escribir c√≥digo con `fetch`**
Dentro de la etiqueta `<script>`, a√±adiremos nuestra primera solicitud `fetch` a la API p√∫blica de Open Notify.
```javascript
// index.html -> <script>

const issApiUrl = 'http://api.open-notify.org/iss-now.json';
const statusDiv = document.getElementById('iss-status');

console.log('Enviando solicitud para obtener las coordenadas de la ISS...');

fetch(issApiUrl)
    .then(response => {
        // El primer .then() maneja la propia respuesta HTTP
        console.log('¬°Respuesta recibida del servidor!', response);
        // Convertimos el cuerpo de la respuesta a JSON, esto tambi√©n es una operaci√≥n as√≠ncrona
        return response.json();
    })
    .then(data => {
        // El segundo .then() recibe los datos JSON ya parseados
        console.log('¬°Datos convertidos a JSON con √©xito!', data);
        const position = data.iss_position;
        statusDiv.innerHTML = `La ISS se encuentra actualmente aqu√≠:
                               <strong>Latitud:</strong> ${position.latitude},
                               <strong>Longitud:</strong> ${position.longitude}`;
    })
    .catch(error => {
        // .catch() se activar√° si ocurre un error de red
        console.error('¬°Error de comunicaci√≥n con la ISS!', error);
        statusDiv.textContent = 'No se pudieron obtener los datos. Comprueba tu conexi√≥n.';
    });
```

- **`fetch(url)`:** Env√≠a una solicitud GET. Devuelve una promesa.
- **`.then(callback)`:** Se ejecuta cuando la promesa se resuelve (`fulfilled`) con √©xito. El primer `.then` recibe un objeto `Response`.
- **`response.json()`:** M√©todo que lee el cuerpo de la respuesta y lo parsea como JSON. ¬°Tambi√©n devuelve una promesa!
- **`.catch(callback)`:** Se ejecuta si la promesa es rechazada (`rejected`), por ejemplo, debido a un error de red.

**Paso 3: Abrir en el navegador**
Simplemente abre el archivo `index.html` en tu navegador. Deber√≠as ver c√≥mo "Esperando datos..." cambia a las coordenadas actuales de la ISS. Abre la consola del desarrollador (F12) para ver los logs.

---

#### **4. "¬øQu√© pasa si...": Manejo de errores del servidor**
¬øQu√© pasa si solicitamos una URL inexistente?
`fetch('http://api.open-notify.org/non-existent-endpoint')`

Fetch est√° dise√±ado de tal manera que `.catch()` solo se activar√° en caso de **errores de red** (sin internet, DNS no encontrado). Sin embargo, las respuestas con c√≥digos `404` o `500` para `fetch` son una **respuesta recibida con √©xito**! Simplemente contiene un c√≥digo de error.

**La forma correcta de verificar:**
```javascript
fetch('http://api.open-notify.org/non-existent-endpoint')
    .then(response => {
        // Verificamos la propiedad .ok, que es true para estados 200-299
        if (!response.ok) {
            // Si la respuesta no es "OK", creamos nuestro propio error para pasar a .catch()
            throw new Error(`¬°Error HTTP! Estado: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error('Ocurri√≥ un error al ejecutar la solicitud:', error);
    });
```

- `response.ok`: Este es tu principal indicador de √©xito.
- `throw new Error()`: Fallamos manualmente la cadena de promesas para entrar en el bloque `.catch`.

---

#### **Cuestionario de repaso**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. La API Fetch es...</p>
      <label><input type="radio" name="q1" value="a"> a) Una librer√≠a externa que hay que descargar</label>
      <label><input type="radio" name="q1" value="b"> b) Una interfaz integrada en el navegador para solicitudes HTTP</label>
      <label><input type="radio" name="q1" value="c"> c) Un lenguaje de programaci√≥n para trabajar con la red</label>
    </div>
    <div class="question">
      <p>2. ¬øQu√© devuelve la llamada `fetch(url)`?</p>
      <label><input type="radio" name="q2" value="a"> a) Datos JSON directamente</label>
      <label><input type="radio" name="q2" value="b"> b) Un objeto `Promise` (promesa)</label>
      <label><input type="radio" name="q2" value="c"> c) Una p√°gina HTML</label>
    </div>
    <div class="question">
      <p>3. El m√©todo `.then()` en una cadena de promesas se llama cuando...</p>
      <label><input type="radio" name="q3" value="a"> a) Ocurre un error de red</label>
      <label><input type="radio" name="q3" value="b"> b) La solicitud se ha completado con √©xito</label>
      <label><input type="radio" name="q3" value="c"> c) El usuario cierra la pesta√±a</label>
    </div>
    <div class="question">
      <p>4. El m√©todo `response.json()` es necesario para...</p>
      <label><input type="radio" name="q4" value="a"> a) Convertir el cuerpo de la respuesta en un objeto JavaScript</label>
      <label><input type="radio" name="q4" value="b"> b) Verificar si la respuesta es un JSON v√°lido</label>
      <label><input type="radio" name="q4" value="c"> c) Enviar datos al servidor en formato JSON</label>
    </div>
    <div class="question">
      <p>5. ¬øC√≥mo verificar correctamente que el servidor no devolvi√≥ un error (por ejemplo, 404)?</p>
      <label><input type="radio" name="q5" value="a"> a) Verificar la propiedad `response.ok`</label>
      <label><input type="radio" name="q5" value="b"> b) Ver si el bloque `.catch()` se activa</label>
      <label><input type="radio" name="q5" value="c"> c) Verificar que `response.status` sea igual a "OK"</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
```
if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Su resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumen del cap√≠tulo:**

Ha configurado la "antena principal" de su MCC y ha aprendido a enviar solicitudes y recibir respuestas.

- üì° Ha dominado la sintaxis b√°sica de `fetch()`.
- üõ∞Ô∏è Ha entendido qu√© son las **Promesas (Promises)** y c√≥mo trabajar con `.then()` y `.catch()`.
- ‚öôÔ∏è Ha aprendido a procesar correctamente las respuestas del servidor, verificando `response.ok`.

**¬°Conexi√≥n establecida!** En el pr√≥ximo cap√≠tulo, conectaremos nuestro MCC a la API de la flota espacial que hemos creado con FastAPI, y aprenderemos a obtener y mostrar la lista de nuestras naves.

> **üìå Verificaci√≥n:**

> - Aseg√∫rese de que su archivo `index.html` muestre correctamente las coordenadas de la ISS.
> - Intente romper intencionalmente la URL y observe en la consola del desarrollador qu√© error se muestra.

> **‚ö†Ô∏è Si el c√≥digo no funciona:**

> - **Error CORS:** Si intenta hacer una solicitud a su API local de FastAPI (por ejemplo, `http://127.0.0.1:8000`) desde un archivo abierto como `file:///...`, el navegador bloquear√° la solicitud debido a la pol√≠tica de seguridad CORS. Resolveremos este problema en el pr√≥ximo cap√≠tulo. Por ahora, estamos usando APIs p√∫blicas que lo permiten.
> - **HTTP/HTTPS:** `http://api.open-notify.org` funciona con HTTP. Algunos navegadores pueden advertirlo. Si est√° trabajando desde un sitio HTTPS, las solicitudes a recursos HTTP pueden ser bloqueadas.
