# **Cap√≠tulo 4.4: Gesti√≥n de errores**
**Tiempo de estudio:** 45 minutos

---

#### **1. Gesti√≥n de errores: Protocolos de emergencia del Centro de Control de Misiones (CCM)**
En el espacio, no todo puede salir seg√∫n lo planeado: una llamarada solar puede interrumpir las comunicaciones, el ordenador de a bordo de la nave puede fallar y un comando desde la Tierra puede contener coordenadas incorrectas.

La **gesti√≥n de errores en el frontend** son los **protocolos de emergencia** de su CCM. Deben:

- üö® Evitar que toda la interfaz "explote" debido a un solo comando fallido.
- üì° Comunicar claramente al operador (usuario) qu√© sali√≥ mal.
- üîß Sugerir posibles acciones futuras.

> üí° **Analog√≠a espacial:**

> Si la nave env√≠a una se√±al `500 Internal Server Error`, en la pantalla del CCM no deber√≠a aparecer "Error cr√≠tico de JavaScript en la l√≠nea 57". En su lugar, deber√≠a ser: "üö® **¬°Fallo a bordo de la nave!** Los ingenieros ya han sido notificados. Intente repetir el comando m√°s tarde."

---

#### **2. Tipos de "anomal√≠as c√≥smicas"**
En el frontend, nos encontramos con tres tipos principales de errores al trabajar con la API:

1.  **Errores de red:** La conexi√≥n con el servidor no se ha establecido. La antena no funciona, el cable est√° cortado. `fetch` "caer√°" en el bloque `.catch()`.
2.  **Errores del cliente (4xx):** El comando desde la Tierra era incorrecto. ID inv√°lido, error de validaci√≥n. El servidor responde, pero con un estado `4xx`.
3.  **Errores del servidor (5xx):** Fallo en la propia nave. Problema en el c√≥digo de la API. El servidor responde, pero con un estado `500+`.

Ya hemos empezado a gestionarlos con `try...catch` y la comprobaci√≥n de `response.ok`. Ahora, hag√°moslo de forma centralizada.

---

#### **3. Funci√≥n manejadora centralizada**
Repetir el mismo c√≥digo `try...catch` en cada funci√≥n es una mala pr√°ctica. Crearemos un "envoltorio" universal para nuestras peticiones `fetch`.

**Paso 1: Creamos `api.js`**
Cree un nuevo archivo `api.js` junto a `app.js`. En √©l, trasladaremos toda la l√≥gica de interacci√≥n con la API.
```javascript
// api.js

const API_BASE_URL = 'http://127.0.0.1:8000';

/**
 * Funci√≥n universal para realizar peticiones a la API.
 * Gestiona errores y devuelve JSON.
 * @param {string} endpoint - Punto final de la API, por ejemplo, '/spaceships'
 * @param {object} options - Par√°metros para fetch (method, headers, body)
 */
async function apiRequest(endpoint, options = {}) {
    const url = `${API_BASE_URL}${endpoint}`;

    try {
        const response = await fetch(url, options);

        // Si la respuesta no es JSON en absoluto, lanzamos un error inmediatamente
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            // Excepci√≥n para una petici√≥n DELETE exitosa que no tiene cuerpo
            if (response.status === 204) return null;

            throw new TypeError(`Respuesta no-JSON recibida del servidor: ${response.statusText}`);
        }

        const data = await response.json();

        if (!response.ok) {
            // Si el servidor devolvi√≥ un JSON con un error (por ejemplo, detalle de FastAPI)
            const errorMessage = data.detail || `¬°Error HTTP! Estado: ${response.status}`;
            throw new Error(errorMessage);
        }

        return data;

    } catch (error) {
        console.error(`Error en la petici√≥n API a ${endpoint}:`, error);
        // "Relanzamos" el error para que pueda ser capturado en la UI
        throw error;
    }
}
```

**Paso 2: Conectamos `api.js` en `index.html`**
Es importante conectarlo **ANTES** de `app.js`, ya que `app.js` utilizar√° sus funciones.
```html
<!-- index.html -->
<body>
    <!-- ... -->
    <script src="api.js"></script>
    <script src="app.js"></script>
</body>
```

**Paso 3: Refactorizamos `app.js`**
Ahora reescribiremos nuestras funciones usando el nuevo `apiRequest`.
```javascript
// app.js

// const API_BASE_URL = ...; // Esta l√≠nea puede eliminarse, ahora est√° en api.js

// ...

async function fetchAndDisplayFleet() {
    try {
        fleetList.innerHTML = '<li>Cargando telemetr√≠a...</li>';
        const ships = await apiRequest('/spaceships'); // <-- ¬°Usamos nuestro envoltorio!

        fleetList.innerHTML = '';
        if (ships.length === 0) {
            fleetList.innerHTML = '<li>No hay ninguna nave en el registro.</li>';
            return;
        }

        ships.forEach(ship => { /* ... el resto del c√≥digo de visualizaci√≥n ... */ });
    } catch (error) {
        fleetList.innerHTML = `<li>üî¥ Error al cargar la flota: ${error.message}</li>`;
    }
}

async function createShip(event) {
    event.preventDefault();
    const shipData = { /* ... recolecci√≥n de datos del formulario ... */ };

    try {
        createStatusMessage.textContent = 'Enviando comando de lanzamiento...';
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(shipData)
        };
        const newShip = await apiRequest('/spaceships', options); // <-- ¬°Usamos nuestro envoltorio!

        createStatusMessage.textContent = `üöÄ ¬°Lanzamiento exitoso! ID asignado a la nave: ${newShip.id}`;
        createShipForm.reset();
        fetchAndDisplayFleet();
    } catch (error) {
        createStatusMessage.textContent = `üî¥ Error: ${error.message}`;
    }
}

// ¬°Reescriba el resto de las funciones (fetchShipById, deleteShip) de manera an√°loga!
```
Ahora toda la l√≥gica para gestionar errores de red, verificar `response.ok` y parsear JSON se encuentra en un solo lugar, y el c√≥digo en `app.js` se ha vuelto mucho m√°s limpio y legible.

---

#### **4. Mostrar errores al usuario**
Una buena interfaz no solo debe escribir el error en la consola, sino mostrarlo al usuario de forma comprensible.

**Ejemplo: Mejora de `createShip`**
Nuestro c√≥digo ya lo hace: `createStatusMessage.textContent = ...`. Pero podemos mejorarlo a√∫n m√°s creando una funci√≥n universal para mostrar notificaciones.

**A√±adimos a `app.js`:**
```javascript
// app.js
function showNotification(message, isError = false) {
    const notificationArea = document.getElementById('create-status-message'); // o otro elemento
    notificationArea.textContent = message;
    notificationArea.style.color = isError ? 'red' : 'green';
}

// Usar en createShip:
async function createShip(event) {
    // ...
    try {
        // ...
        const newShip = await apiRequest('/spaceships', options);
        showNotification(`üöÄ ¬°Lanzamiento exitoso! ID: ${newShip.id}`);
        // ...
    } catch (error) {
        showNotification(`üî¥ Error: ${error.message}`, true);
    }
}
```
Ahora tenemos un mecanismo unificado para mostrar tanto mensajes de √©xito como errores.

---

#### **Cuestionario de repaso**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. El bloque `.catch()` en la promesa `fetch` se activar√° si...</p>
      <label><input type="radio" name="q1" value="a"> a) El servidor devuelve un error 404 Not Found</label>
      <label><input type="radio" name="q1" value="b"> b) Ocurre un error de red (por ejemplo, no hay internet)</label>
      <label><input type="radio" name="q1" value="c"> c) El servidor devuelve un error 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. ¬øPor qu√© es necesaria una funci√≥n manejadora centralizada para las peticiones de la API?</p>
      <label><input type="radio" name="q2" value="a"> a) Para evitar la duplicaci√≥n de c√≥digo de gesti√≥n de errores y hacer la l√≥gica de la UI m√°s limpia</label>
      <label><input type="radio" name="q2" value="b"> b) Para que todas las peticiones se env√≠en simult√°neamente</label>
      <label><input type="radio" name="q2" value="c"> c) Es un requisito del est√°ndar Fetch API</label>
    </div>
    <div class="question">
      <p>3. `response.headers.get('content-type')` se usa para...</p>
      <label><input type="radio" name="q3" value="a"> a) Establecer un encabezado en la petici√≥n saliente</label>
      <label><input type="radio" name="q3" value="b"> b) Verificar el tipo de contenido en la respuesta recibida del servidor</label>
      <label><input type="radio" name="q3" value="c"> c) Obtener todos los tipos de contenido disponibles</label>
    </div>
    <div class="question">
      <p>4. `throw new Error(...)` dentro de `try...catch` o `.then()` se usa para...</p>
      <label><input type="radio" name="q4" value="a"> a) Detener la ejecuci√≥n de todo JavaScript en la p√°gina</label>
      <label><input type="radio" name="q4" value="b"> b) "Fallar" la promesa y pasar el control al bloque `.catch()` m√°s cercano</label>
      <label><input type="radio" name="q4" value="c"> c) Mostrar un mensaje en `alert`</label>
    </div>
    <div class="question">
      <p>5. ¬øPor qu√© es importante mostrar los errores al usuario y no solo en la consola?</p>
      <label><input type="radio" name="q5" value="a"> a) Porque la mayor√≠a de los usuarios no miran la consola</label>
      <label><input type="radio" name="q5" value="b"> b) Para que la interfaz sea comprensible y predecible</label>
      <label><input type="radio" name="q5" value="c"> c) Ambas opciones son correctas</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'b', q4: 'b', q5: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';
for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });
      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Su resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumen del cap√≠tulo:**

Usted ha fortalecido su MCC (Centro de Control de Misi√≥n) creando protocolos de emergencia fiables.

- üõ°Ô∏è Usted comprende la diferencia entre errores de red, de cliente y de servidor.
- ‚öôÔ∏è Usted ha creado una funci√≥n `apiRequest` centralizada para manejar todas las solicitudes, evitando la duplicaci√≥n de c√≥digo.
- üì° Su interfaz ahora es capaz de informar correctamente al usuario sobre los errores, haci√©ndola m√°s amigable y confiable.

**¬°Escudos de emergencia levantados!** Pero, ¬øqu√© es mejor: las cadenas `.then()` o el moderno `async/await`? En el pr√≥ximo cap√≠tulo, analizaremos ambos enfoques y entenderemos cu√°ndo usar cada uno.

> **üìå Verificaci√≥n:**

> - Verifique que su c√≥digo en `app.js` haya sido refactorizado con √©xito y utilice la nueva funci√≥n `apiRequest`.
> - Intente detener el servidor FastAPI y haga clic en el bot√≥n "Solicitar datos". Deber√≠a ver un error de conexi√≥n en la p√°gina.
> - Intente crear una nave con datos inv√°lidos. Deber√≠a ver un mensaje de error de validaci√≥n que proviene de FastAPI.

> **‚ö†Ô∏è Si hay errores:**

> - `apiRequest is not defined`: Aseg√∫rese de haber conectado `api.js` en `index.html` **antes** de `app.js`.
> - Verifique la consola del navegador en busca de otros errores de sintaxis en JavaScript.
