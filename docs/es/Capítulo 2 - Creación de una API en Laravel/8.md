# **Cap√≠tulo 2.8: Pruebas de API**
**Tiempo de estudio:** 1 hora

---

#### **1. ¬øPor qu√© son necesarias las pruebas?**

Imagine que construy√≥ una nave espacial. Antes de enviarla a Marte, realiza miles de verificaciones en la Tierra. Las pruebas en programaci√≥n son lo mismo. Ellas:

-   **Dan confianza:** Puede cambiar el c√≥digo y, si las pruebas pasan, significa que no ha roto nada.
-   **Ahorran tiempo:** En lugar de "hacer clic" manualmente en todo en Postman despu√©s de cada cambio, ejecuta un solo comando y este verifica todo por usted en segundos.
-   **Sirven como documentaci√≥n:** Las buenas pruebas muestran c√≥mo debe funcionar su API.

---

#### **2. Configuraci√≥n del "Laboratorio" de pruebas**

Laravel hace que la configuraci√≥n de pruebas sea incre√≠blemente sencilla. Por defecto, utiliza una configuraci√≥n separada para no afectar su base de datos principal.

**Base de datos para pruebas:**
Por defecto, Laravel utiliza una base de datos **en memoria** (`:memory:`). Este es el m√©todo m√°s r√°pido, ya que no es necesario escribir nada en el disco. La base de datos se crea antes de las pruebas y se destruye despu√©s de ellas. ¬°Ni siquiera necesitamos configurar nada para esto!

**Creaci√≥n de archivo de prueba:**
Creemos un archivo especial para las pruebas relacionadas con los planetas.

```bash
php artisan make:test PlanetApiTest
```

Este comando crear√° el archivo `tests/Feature/PlanetApiTest.php`. La palabra `Feature` significa que probaremos la funcionalidad en general (por ejemplo, "¬øpuede el usuario crear un planeta?"), y no una peque√±a clase individual.

---

#### **3. Anatom√≠a de un test: Preparaci√≥n, Acci√≥n, Verificaci√≥n**

Abra `tests/Feature/PlanetApiTest.php`. Dentro escribiremos nuestra primera prueba. Una buena prueba siempre consta de tres partes (Arrange, Act, Assert).

```php
<?php

namespace Tests\Feature;

use App\Models\Planet; // ¬°No olvide importar el modelo!
use Illuminate\Foundation\Testing\RefreshDatabase; // ¬°Herramienta esencial!
use Tests\TestCase;

class PlanetApiTest extends TestCase
{
    // Este trait "m√°gicamente" limpia y recrea
    // nuestra base de datos de prueba antes de cada test.
    // Esto garantiza que los tests no se afecten entre s√≠.
    use RefreshDatabase;

    /**
     * Test: el endpoint para obtener la lista de planetas funciona correctamente.
     * ¬°Los nombres de los tests deben ser significativos!
     */
    public function test_can_get_all_planets(): void
    {
        // 1. PREPARACI√ìN (Arrange)
        // Creamos 3 planetas falsos en nuestra base de datos de prueba
        // usando la factor√≠a que creamos anteriormente.
        Planet::factory()->count(3)->create();

        // 2. ACCI√ìN (Act)
        // Simulamos una solicitud GET real a nuestra API.
        $response = $this->getJson('/api/planets');

        // 3. VERIFICACI√ìN (Assert)
        // Verificamos que todo sali√≥ como se esperaba.
        $response->assertStatus(200); // Esperamos que el servidor haya respondido "200 OK"
        $response->assertJsonCount(3); // Esperamos que haya exactamente 3 planetas en la respuesta
    }
}
```
**Puntos clave:**

-   `use RefreshDatabase`: Este trait es su mejor amigo. Garantiza que cada test comience con una "pizarra limpia", con una base de datos vac√≠a.
-   `Planet::factory()`: Las factor√≠as son ideales para crear datos de prueba.
-   `$this->getJson()`: Este es un m√©todo especial de Laravel para enviar solicitudes API dentro de los tests.
-   `assert...()`: Estas son "afirmaciones" o "verificaciones". Si al menos una de ellas no se cumple, el test fallar√°.

---

#### **4. Pruebas de operaciones b√°sicas (CRUD)**

Escribamos tests para la creaci√≥n, actualizaci√≥n y eliminaci√≥n de planetas.

**A. Test de creaci√≥n de un planeta (POST)**

```php
<?php
public function test_can_create_a_planet(): void
{
    // 1. Preparaci√≥n: preparamos los datos para el nuevo planeta
    $planetData = [
        'name' => 'Kepler-186f',
        'description' => 'La primera exoplaneta del tama√±o de la Tierra en la zona habitable.',
        'size_km' => 14000,
        'solar_system' => 'Kepler-186'
    ];

    // 2. Acci√≥n: enviamos una solicitud POST con los datos
    $response = $this->postJson('/api/planets', $planetData);

    // 3. Verificaci√≥n
    $response->assertStatus(201); // Esperamos el estado "201 Created"
    $response->assertJsonFragment(['name' => 'Kepler-186f']); // Verificamos que el nombre creado est√© en la respuesta

    // La verificaci√≥n m√°s importante: ¬ørealmente los datos llegaron a la base de datos?
    $this->assertDatabaseHas('planets', [
        'name' => 'Kepler-186f'
    ]);
}
```

**B. Test de eliminaci√≥n de un planeta (DELETE)**
```php
<?php
public function test_can_delete_a_planet(): void
{
    // 1. Preparaci√≥n: creamos el planeta que vamos a eliminar
    $planet = Planet::factory()->create();

    // 2. Acci√≥n: enviamos una solicitud DELETE
    $response = $this->deleteJson("/api/planets/{$planet->id}");

    // 3. Verificaci√≥n
    $response->assertStatus(204); // Esperamos "204 No Content" - eliminaci√≥n exitosa

    // Verificamos que el registro realmente haya desaparecido de la base de datos
    $this->assertDatabaseMissing('planets', [
        'id' => $planet->id
    ]);
}
```

---

#### **5. Pruebas de escenarios "malos"**

Probar casos exitosos es bueno. ¬°Pero es a√∫n m√°s importante probar los errores!

**A. Test de error de validaci√≥n**
```php
<?php
public function test_creation_fails_with_invalid_data(): void
{
    // 2. Acci√≥n: enviamos datos intencionadamente incorrectos
    $response = $this->postJson('/api/planets', ['name' => '']); // Nombre vac√≠o

    // 3. Verificaci√≥n
    $response->assertStatus(422); // Esperamos "422 Unprocessable Entity"
    $response->assertJsonValidationErrors('name'); // Esperamos que el error est√© espec√≠ficamente en el campo 'name'
}
```

**B. Test de "no encontrado" (404)**
```php
<?php
public function test_returns_404_for_non_existent_planet(): void
{
    // 2. Acci√≥n: solicitamos un planeta con un ID inexistente
    $response = $this->getJson('/api/planets/99999');

    // 3. Verificaci√≥n
    $response->assertStatus(404); // Esperamos "404 Not Found"
}
```

---

#### **6. Ejecuci√≥n de tests**

Ahora que los tests est√°n escritos, ejecutarlos es muy sencillo. Ejecute en la terminal:

```bash
php artisan test
```

Laravel encontrar√° todos sus tests y los ejecutar√° uno por uno. Si todo sale bien, ver√° una salida verde. Si alg√∫n test falla, ver√° una salida roja con una descripci√≥n detallada del error, lo que le permitir√° corregirlo r√°pidamente.

**Para ejecutar solo un archivo espec√≠fico:**
```bash
php artisan test tests/Feature/PlanetApiTest.php
```

---

#### **8. Cobertura de c√≥digo (Code Coverage)**
**Paso 1: Instalaci√≥n de Xdebug**

Para recopilar informaci√≥n sobre la cobertura del c√≥digo se requiere la extensi√≥n de PHP ‚Äî [Xdebug](https://xdebug.org/wizard).
>Env√≠e su `php -i` al wizard y siga las instrucciones.

**Paso 2: Configuraci√≥n de `phpunit.xml`**
```xml
<phpunit ... >
    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">./app</directory>
        </include>
    </coverage>
</phpunit>
```

**Paso 3: Ejecuci√≥n con informe**
```bash
php artisan test --coverage-html=coverage
```
Informe: Abra `coverage/index.html` en el navegador

---

#### **9. Integraci√≥n con Postman**
**Automatizaci√≥n a trav√©s de Newman:**

1. Exporte la colecci√≥n de Postman a `tests/Postman/SpaceApi.postman_collection.json`
2. Instale Newman:
```bash
npm install -g newman
```
3. Agregue el script a `composer.json`:
```json
"scripts": {
    "test:postman": "newman run tests/Postman/SpaceApi.postman_collection.json"
}
```
4. Ejecuci√≥n:
```bash
composer test:postman
```

---

#### **Cuestionario para afianzar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Comando para crear una clase de prueba:</p>
      <label><input type="radio" name="q1" value="a"> a) php artisan make:test</label>
      <label><input type="radio" name="q1" value="b"> b) php artisan generate:test</label>
      <label><input type="radio" name="q1" value="c"> c) php artisan test:create</label>
    </div>
    <div class="question">
      <p>2. El trait RefreshDatabase se utiliza para:</p>
      <label><input type="radio" name="q2" value="a"> a) Limpiar la BD despu√©s de las pruebas</label>
      <label><input type="radio" name="q2" value="b"> b) Rellenar la BD con datos de prueba</label>
      <label><input type="radio" name="q2" value="c"> c) Crear la estructura de la BD</label>
    </div>
    <div class="question">
      <p>3. M√©todo para verificar la estructura JSON:</p>
      <label><input type="radio" name="q3" value="a"> a) assertJsonFormat()</label>
      <label><input type="radio" name="q3" value="b"> b) assertJsonStructure()</label>
      <label><input type="radio" name="q3" value="c"> c) assertJsonSchema()</label>
    </div>
    <div class="question">
      <p>4. Las f√°bricas en Laravel son necesarias para:</p>
      <label><input type="radio" name="q4" value="a"> a) Generaci√≥n de datos de prueba</label>
      <label><input type="radio" name="q4" value="b"> b) Creaci√≥n de migraciones</label>
      <label><input type="radio" name="q4" value="c"> c) Manejo de errores</label>
    </div>
    <div class="question">
      <p>5. Herramienta para ejecutar colecciones de Postman desde la CLI:</p>
      <label><input type="radio" name="q5" value="a"> a) Newman</label>
      <label><input type="radio" name="q5" value="b"> b) Postman CLI</label>
      <label><input type="radio" name="q5" value="c"> c) Artisan</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'a', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

**üöÄ Resumen del cap√≠tulo:**

¬°Has completado el ciclo completo de pruebas previas al vuelo! Ahora tu API:

- ‚úÖ Configurar el entorno de prueba sin esfuerzo adicional
- üõ°Ô∏è Escribir pruebas siguiendo el principio "Preparaci√≥n-Acci√≥n-Verificaci√≥n".
- üìä Probar tanto escenarios exitosos (CRUD) como errores (validaci√≥n, 404).
- üîÅ Ejecutar pruebas con un solo comando y tener confianza en tu c√≥digo.

**¬°La nave espacial est√° lista para el lanzamiento!** Has completado la secci√≥n sobre la creaci√≥n de API en Laravel.

> **üìå Verificaci√≥n final:**

> 1. Ejecuta `php artisan test`
> 2. Aseg√∫rate de que todas las pruebas pasen (¬°luz verde!)
> 3. Revisa el informe de cobertura

> **‚ö†Ô∏è Si las pruebas fallan:**

> - Verifica el funcionamiento de la API a trav√©s de Postman
> - Aseg√∫rate de que la base de datos de prueba est√© configurada
> - Usa `dd($response->content())` para depurar

**¬°Felicidades por completar el Cap√≠tulo 2!** No solo has creado una API, has creado una "nave espacial" fiable y probada, lista para futuras misiones.

> **üåå Pr√≥ximos pasos:**

> 1. Configuraci√≥n de autenticaci√≥n (Sanctum)
> 2. Documentaci√≥n de la API con Swagger
> 3. Despliegue en el servidor (Forge, VPS)
> 4. Escritura del frontend en Vue/React

**¬°√âxito en el lanzamiento de tu misi√≥n espacial! En el pr√≥ximo cap√≠tulo, veremos la creaci√≥n de una API desde cero** üöÄ
