# **Cap√≠tulo 2.6: Validaci√≥n de Datos**
**Tiempo de estudio:** 50 minutos

---

#### **1. Validaci√≥n: Un escudo de escala c√≥smica**
La **validaci√≥n** es la verificaci√≥n de los datos entrantes para asegurar que cumplen con ciertas reglas. Sin ella:

- üöÄ Datos incorrectos pueden "destruir" tu base de datos
- üåå Los atacantes pueden inyectar c√≥digo malicioso
- ü™ê Los usuarios recibir√°n errores incomprensibles

> üí° **Analog√≠a c√≥smica:**
> Validaci√≥n = Sistema de defensa de una estaci√≥n espacial:

> - Verifica la "carga" (datos) antes del acoplamiento
> - Rechaza objetos peligrosos
> - Filtra la basura espacial

---

#### **2. D√≥nde validar en la API de Laravel**
Enfoques principales:

1. **En el controlador** (r√°pido, pero desordena el c√≥digo)
2. **Form Request** (recomendado, arquitectura limpia)

---

#### **3. Validaci√≥n en el controlador**
Usamos el m√©todo `validate()` del objeto Request:
```php
<?php
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ]);

    // ... creaci√≥n de planeta
}
```

**Reglas de validaci√≥n populares:**

| Regla              | Descripci√≥n                          | Ejemplo                     |
|----------------------|-----------------------------------|----------------------------|
| `required`           | Campo obligatorio                 | `'name' => 'required'`     |
| `string`             | Valor de cadena                | `'description' => 'string'`|
| `integer`            | N√∫mero entero                       | `'size_km' => 'integer'`   |
| `min:value`          | Valor/longitud m√≠nima        | `'size_km' => 'min:100'`   |
| `max:value`          | Valor/longitud m√°xima       | `'name' => 'max:255'`      |
| `unique:table,column`| √önico en la tabla            | `'name' => 'unique:planets'` |
| `url`                | URL correcta                    | `'image_url' => 'url'`     |
| `boolean`            | true/false/1/0                    | `'is_habitable' => 'boolean'` |

---

#### **4. Mensajes de error personalizados**
Cambiamos los textos de error est√°ndar:
```php
<?php
$validated = $request->validate(
    [
        'name' => 'required|unique:planets',
        'size_km' => 'min:1000'
    ],
    [
        'name.required' => '¬°El nombre del planeta es obligatorio!',
        'name.unique' => 'Ya existe un planeta con ese nombre en el cat√°logo',
        'size_km.min' => 'El di√°metro del planeta no puede ser inferior a 1000 km'
    ]
);
```

**Ejemplo de respuesta en caso de error (autom√°ticamente 422 Unprocessable Entity):**
```json
{
    "message": "Los datos proporcionados no son v√°lidos.",
    "errors": {
        "name": ["Ya existe un planeta con ese nombre en el cat√°logo"],
        "size_km": ["El di√°metro del planeta no puede ser inferior a 1000 km"]
    }
}
```

---

#### **5. Creaci√≥n de un Form Request**
Para una validaci√≥n compleja, creamos una clase separada:

**Paso 1: Generaci√≥n**
```bash
php artisan make:request StorePlanetRequest
```

**Paso 2: Editamos `app/Http/Requests/StorePlanetRequest.php`**
```php
<?php
public function authorize()
{
    return true; // Para API, normalmente true
}

public function rules()
{
    return [
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ];
}

public function messages()
{
    return [
        'name.unique' => '¬°Ya existe un planeta con este nombre!',
        'size_km.min' => 'El di√°metro no puede ser inferior a 100 km'
    ];
}
```

**Paso 3: Usamos en el controlador**
```php
<?php
use App\Http\Requests\StorePlanetRequest;

public function store(StorePlanetRequest $request)
{
    // ¬°Los datos ya han sido validados!
    $validated = $request->validated();
    $planet = Planet::create($validated);
    return response()->json($planet, 201);
}
```

---

Entendido. La tarea es adaptar el cap√≠tulo para que est√© en plena conformidad con Laravel 10/11/12, eliminando toda menci√≥n de conceptos y flags obsoletos, en particular `--invokable`, y dejando solo el c√≥digo actual. Sin tocar nada m√°s.

Aceptado. Aqu√≠ est√° la versi√≥n corregida de la secci√≥n 6, que refleja con precisi√≥n la realidad de las versiones modernas del framework.

---

#### **6. Reglas de Validaci√≥n Personalizadas**
Crearemos una regla para verificar la "sensatez" del nombre de un planeta. Las reglas est√°ndar de Laravel no pueden verificar si un nombre est√° "prohibido", as√≠ que escribiremos nuestra propia l√≥gica.

**Paso 1: Generaci√≥n de la regla**

Laravel proporciona un comando Artisan para crear un "esqueleto" de la clase de la regla. Lo ejecutaremos en la terminal:

```bash
php artisan make:rule ValidPlanetName
```

**Paso 2: Editamos `app/Rules/ValidPlanetName.php`**

Abre el archivo creado. Su estructura es simple y clara. Nuestra tarea es implementar la l√≥gica dentro del m√©todo `validate`.

```php
<?php

namespace App\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;

class ValidPlanetName implements ValidationRule
{
    /**
     * Ejecuta la regla de validaci√≥n.
     *
     * @param  \Closure(string): \Illuminate\Translation\PotentiallyTranslatedString  $fail
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        // Nuestra "lista negra" de nombres
        $forbidden = ['–ó–µ–º–ª—è 2.0', '–ù–∏–±–∏—Ä—É', '–ü–ª–∞–Ω–µ—Ç–∞ X'];

        // Verificamos si el valor introducido est√° en nuestra lista,
        // ignorando may√∫sculas/min√∫sculas.
        if (in_array(strtolower($value), array_map('strtolower', $forbidden))) {
            // Si la validaci√≥n falla, llamamos a la funci√≥n $fail
            // con el texto del error que ver√° el usuario.
            $fail('¬°Este nombre de planeta est√° prohibido!');
        }
    }
}
```

**Paso 3: Usamos en el Form Request**

Ahora nuestra regla personalizada est√° lista para ser usada. Podemos incluirla en cualquier Form Request, simplemente creando una nueva instancia de nuestra clase.

Abrimos `app/Http/Requests/StorePlanetRequest.php` y a√±adimos `new ValidPlanetName` al array de reglas para el campo `name`.

```php
<?php
// app/Http/Requests/StorePlanetRequest.php

namespace App\Http\Requests;

use App\Rules\ValidPlanetName; // <-- No olvides importar la clase
use Illuminate\Foundation\Http\FormRequest;

class StorePlanetRequest extends FormRequest
{
    // ... (m√©todo authorize)

    public function rules(): array
    {
        return [
            'name' => [
                'sometimes',
                'string',
                'max:255',
                'unique:planets',
                new ValidPlanetName, // <-- Aqu√≠ est√° nuestra regla personalizada
            ],
            'description' => 'sometimes|string',
            'size_km' => 'sometimes|integer|min:100|max:500000',
            'solar_system' => 'sometimes|string|max:100',
            'image_url' => 'nullable|url|max:2048',
            'is_habitable' => 'sometimes|boolean'
        ];
    }

    // ... (m√©todo messages)
}
```
Listo. Ahora, al crear un planeta, Laravel aplicar√° secuencialmente todas las reglas al campo `name` y, al llegar a `new ValidPlanetName`, ejecutar√° nuestra l√≥gica personalizada.

---

#### **7. Validaci√≥n para actualizaci√≥n (Update)**
Particularidades al actualizar datos:

> Al actualizar un registro, las reglas de validaci√≥n suelen ser diferentes. La caracter√≠stica principal es la verificaci√≥n de unicidad, que debe ignorar el registro que se est√° actualizando.

**Paso 1: Creamos un Form Request separado para la actualizaci√≥n**
 ```bash
 php artisan make:request UpdatePlanetRequest
 ```
**Paso 2: Editamos `app/Http/Requests/UpdatePlanetRequest.php`**
```php
<?php
use Illuminate\Validation\Rule;

public function authorize(): bool
{
    return true;
}
public function rules(): array
{
	$planet = $this->route('planet'); // Obtenemos el modelo de la ruta

     return [
         'name' => [
             'sometimes', // Validar solo si el campo est√° presente en la solicitud
             'required',
             'string',
             'max:255',
             Rule::unique('planets')->ignore($planetId),
         ],
         'description'  => 'sometimes|required|string',
         'size_km'      => 'sometimes|required|integer|min:100|max:500000',
         // ... otros campos con 'sometimes'
     ];
 }
```
**Paso 3: Usamos en el controlador**
```php
<?php
 use App\Http\Requests\UpdatePlanetRequest;

 public function update(UpdatePlanetRequest $request, Planet $planet)
 {
     $validated = $request->validated();
     $planet->update($validated);
     return response()->json($planet);
 }
```

---

#### **8. Pruebas de validaci√≥n en Postman**
**Escenario 1: Error de unicidad del nombre**
```json
POST /api/planets
{
    "name": "–ú–∞—Ä—Å",
    "description": "Planeta rojo, objetivo de futuras colonizaciones",
    "size_km": 6779,
    "solar_system": "Solar System",
    "is_habitable": false
}
```
**Respuesta esperada:**
```json
{
    "message": "Los datos proporcionados no son v√°lidos.",
    "errors": {
        "name": ["¬°Ya existe un planeta con este nombre!"]
    }
}
```

**Escenario 2: Di√°metro incorrecto**
```json
{
    "name": "Planeta Guisante",
    "size_km": 50 // < min:100
}
```
**Respuesta esperada:**
```json
"errors": {
    "size_km": ["El di√°metro no puede ser inferior a 100 km"]
}
```

---

#### **Cuestionario para consolidar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
}
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Estado HTTP en errores de validaci√≥n:</p>
      <label><input type="radio" name="q1" value="a"> a) 400 Bad Request</label>
      <label><input type="radio" name="q1" value="b"> b) 422 Unprocessable Entity</label>
      <label><input type="radio" name="q1" value="c"> c) 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. Regla para verificar la unicidad:</p>
      <label><input type="radio" name="q2" value="a"> a) unique:table</label>
      <label><input type="radio" name="q2" value="b"> b) distinct</label>
      <label><input type="radio" name="q2" value="c"> c) only:table</label>
    </div>
    <div class="question">
      <p>3. ¬øD√≥nde es mejor ubicar reglas de validaci√≥n complejas?</p>
      <label><input type="radio" name="q3" value="a"> a) En el controlador</label>
      <label><input type="radio" name="q3" value="b"> b) En el modelo</label>
      <label><input type="radio" name="q3" value="c"> c) En el Form Request</label>
    </div>
    <div class="question">
      <p>4. El m√©todo `authorize()` en Form Request debe devolver:</p>
      <label><input type="radio" name="q4" value="a"> a) false</label>
      <label><input type="radio" name="q4" value="b"> b) true</label>
      <label><input type="radio" name="q4" value="c"> c) null</label>
    </div>
    <div class="question">
      <p>5. La regla sometimes significa:</p>
      <label><input type="radio" name="q5" value="a"> a) El campo es obligatorio</label>
      <label><input type="radio" name="q5" value="b"> b) El campo se valida solo si est√° presente</label>
      <label><input type="radio" name="q5" value="c"> c) El campo se ignora</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'c', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumen del cap√≠tulo:**

Has establecido un potente sistema de protecci√≥n para tu API espacial:

- üõ°Ô∏è Reglas de validaci√≥n b√°sicas y personalizadas
- üìù Mensajes de error legibles
- üß© Form Request para escenarios complejos
- ‚öôÔ∏è Reglas √∫nicas para la actualizaci√≥n de datos

**¬°Tu universo ahora est√° protegido!** A continuaci√≥n, aprenderemos a manejar "accidentes espaciales": los errores del servidor.

> **üìå Verificaci√≥n:**

> 1. Crea un Form Request para la actualizaci√≥n de planetas
> 2. A√±ade una regla personalizada para la verificaci√≥n del nombre
> 3. Prueba los errores a trav√©s de Postman

> **‚ö†Ô∏è Si la validaci√≥n no funciona:**

> - Verifica la conexi√≥n del Form Request en el controlador
> - Aseg√∫rate de que `authorize()` devuelva true
> - Para la unicidad al actualizar, usa `Rule::unique`