# **Cap√≠tulo 3.6: Manejo de errores y validaci√≥n**
**Tiempo de estudio:** 50 minutos

---

#### **1. Manejo de errores: Los "escudos de emergencia" de una nave espacial**
Incluso en la nave m√°s perfecta, pueden ocurrir situaciones imprevistas:

-   **Comando incorrecto del Centro de Control:** El cliente envi√≥ datos incorrectos.
-   **P√©rdida de conexi√≥n con el m√≥dulo:** Recurso no encontrado en la base de datos.
-   **Fallo en el reactor:** Error interno del servidor.

**El manejo adecuado de errores** es un sistema de "escudos de emergencia". Evita que la nave se desintegre y, en su lugar, env√≠a una se√±al clara al Centro de Control sobre lo que sali√≥ mal.

> üí° **Analog√≠a espacial:**

> En lugar de simplemente transmitir una se√±al de "¬°ACCIDENTE!" al Centro de Control, una buena computadora de a bordo enviar√° un informe estructurado:
> ```json
> {
>   "error_code": "ENGINE_OVERHEAT",
>   "message": "La temperatura del motor #2 super√≥ la norma",
>   "suggested_action": "Activar el sistema de enfriamiento"
> }
> ```
> Esto permite a los ingenieros en la Tierra comprender r√°pidamente el problema y tomar medidas.

---

#### **2. Validaci√≥n Pydantic: La "computadora de a bordo" integrada**
Ya nos hemos encontrado con la magia de Pydantic. Si intentas crear una nave con un tipo de datos incorrecto (por ejemplo, `launch_year` como cadena de texto), FastAPI devolver√° autom√°ticamente un error `422 Unprocessable Entity` con una descripci√≥n detallada de qu√© campo y por qu√© no pas√≥ la validaci√≥n.

**Ejemplo de solicitud a `POST /spaceships`:**
```json
{
  "name": "X-Wing",
  "type": "Caza",
  "launch_year": "hace mucho tiempo",  // <-- ¬°Tipo incorrecto!
  "status": "En servicio"
}
```

**Respuesta autom√°tica de FastAPI:**
```json
{
  "detail": [
    {
      "loc": [
        "body",
        "launch_year"
      ],
      "msg": "el valor no es un entero v√°lido",
      "type": "type_error.integer"
    }
  ]
}
```
¬°Esto es incre√≠blemente potente! No necesitas escribir c√≥digo para verificar tipos: FastAPI y Pydantic lo hacen por ti.

---

#### **3. Manejo de "Recurso no encontrado": Excepci√≥n `HTTPException`**
Ya hemos utilizado esto en las operaciones CRUD. `HTTPException` es la forma est√°ndar de FastAPI de interrumpir la ejecuci√≥n de una solicitud y devolver inmediatamente una respuesta de error al cliente.

**Recordemos el c√≥digo de `GET /spaceships/{ship_id}`:**
```python
# main.py
from fastapi import FastAPI, HTTPException # Aseg√∫rate de que HTTPException est√© importado

# ...

@app.get("/spaceships/{ship_id}", response_model=Spaceship, tags=["Naves espaciales"])
def get_spaceship(ship_id: int):
    ship = db_spaceships.get(ship_id)
    if not ship:
        # Si la nave no se encuentra, "lanzamos" una excepci√≥n 404
        raise HTTPException(status_code=404, detail=f"Nave espacial con ID {ship_id} no encontrada")
    return ship
```

-   `raise HTTPException(...)`: Esta llamada detiene la ejecuci√≥n de la funci√≥n.
-   `status_code=404`: Establece el estado HTTP de la respuesta.
-   `detail`: Mensaje que se enviar√° al cliente en el cuerpo de la respuesta JSON.

---

#### **4. Validadores personalizados: "Verificaciones especiales" antes del lanzamiento**
¬øQu√© pasa si queremos a√±adir nuestra propia l√≥gica de negocio m√°s compleja? Por ejemplo, prohibir el lanzamiento de naves con el nombre "Estrella de la Muerte".

Para ello, Pydantic cuenta con una poderosa herramienta: los **validadores**.

**Paso 1: A√±adir un validador al modelo `SpaceshipCreate`**
```python
# main.py
from pydantic import BaseModel, Field, validator

class SpaceshipCreate(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)
    type: str
    launch_year: int = Field(..., gt=1950)
    status: str

    @validator('name')
    def name_must_not_be_forbidden(cls, v):
        """Verifica que el nombre de la nave no est√© en la lista de nombres prohibidos."""
        if 'Death Star' in v:
            raise ValueError('¬°Nombres como "Estrella de la Muerte" est√°n prohibidos por decreto imperial!')
        return v.title() # De paso, ponemos la primera letra del nombre en may√∫scula
```

-   `@validator('name')`: Un decorador que "vincula" esta funci√≥n al campo `name`.
-   `cls, v`: El m√©todo recibe la clase misma (`cls`) y el valor del campo (`v`).
-   `raise ValueError(...)`: Si la validaci√≥n falla, lanzamos una excepci√≥n est√°ndar de Python. FastAPI la interceptar√° y la convertir√° en un bonito error `422`.
-   `return v.title()`: Si todo est√° bien, **debemos devolver el valor obligatoriamente**. Incluso podemos modificarlo sobre la marcha (por ejemplo, convertirlo a un formato est√°ndar).

**Paso 2: Probar**
Reinicia `uvicorn` e intenta crear una nave con un nombre prohibido a trav√©s de `/docs`. ¬°Recibir√°s un error `422` con tu mensaje personalizado!

---

#### **5. Manejo global de errores: El "protocolo de emergencia" de la estaci√≥n**
A veces es necesario interceptar errores inesperados (por ejemplo, un fallo de conexi√≥n a una base de datos real) y devolver un formato de respuesta √∫nico y estandarizado.

Para ello se utiliza el decorador `@app.exception_handler`.

**Ejemplo: Interceptaci√≥n de todos los errores `ValueError`**
```python
# main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# ...

@app.exception_handler(ValueError)
async def value_error_exception_handler(request: Request, exc: ValueError):
    """
    Manejador global para todos los errores ValueError,
    para devolver un JSON estandarizado.
    """
    return JSONResponse(
        status_code=400,
        content={"message": f"Error en los datos: {str(exc)}"},
    )
```

-   `@app.exception_handler(ValueError)`: Le dice a FastAPI que esta funci√≥n debe manejar todos los `ValueError` que no hayan sido interceptados previamente.
-   `async def ...`: Los manejadores de excepciones deben ser as√≠ncronos (`async`).
-   `JSONResponse`: Permite un control total sobre el cuerpo y el estado de la respuesta.

Ahora, cuando nuestro validador personalizado se active, la respuesta tendr√° un formato m√°s amigable que el que hemos definido.

---

#### **Cuestionario de repaso**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Si el cliente env√≠a datos de un tipo incorrecto (una cadena en lugar de un n√∫mero), FastAPI devolver√° autom√°ticamente el estado...</p>
      <label><input type="radio" name="q1" value="a"> a) 500 Internal Server Error</label>
      <label><input type="radio" name="q1" value="b"> b) 404 Not Found</label>
      <label><input type="radio" name="q1" value="c"> c) 422 Unprocessable Entity</label>
    </div>
    <div class="question">
      <p>2. `raise HTTPException(status_code=404)` se utiliza para...</p>
      <label><input type="radio" name="q2" value="a"> a) Terminar el funcionamiento de todo el servidor</label>
      <label><input type="radio" name="q2" value="b"> b) Interrumpir la ejecuci√≥n de la solicitud y devolver un error 404 al cliente</label>
      <label><input type="radio" name="q2" value="c"> c) Registrar el error, pero continuar la ejecuci√≥n</label>
    </div>
    <div class="question">
      <p>3. El decorador `@validator('field_name')` en Pydantic es necesario para:</p>
      <label><input type="radio" name="q3" value="a"> a) Crear l√≥gica de validaci√≥n personalizada para un campo espec√≠fico</label>
      <label><input type="radio" name="q3" value="b"> b) Indicar que un campo es obligatorio</label>
      <label><input type="radio" name="q3" value="c"> c) Cifrar el valor de un campo</label>
    </div>
    <div class="question">
      <p>4. ¬øQu√© debe hacer una funci√≥n validadora en Pydantic si los datos son correctos?</p>
      <label><input type="radio" name="q4" value="a"> a) No devolver nada (None)</label>
      <label><input type="radio" name="q4" value="b"> b) Devolver obligatoriamente un valor (posiblemente modificado)</label>
      <label><input type="radio" name="q4" value="c"> c) Devolver `True`</label>
    </div>
    <div class="question">
      <p>5. `@app.exception_handler()` permite...</p>
      <label><input type="radio" name="q5" value="a"> a) Crear nuevos tipos de excepciones</label>
      <label><input type="radio" name="q5" value="b"> b) Interceptar excepciones globalmente y definir una respuesta personalizada para ellas</label>
      <label><input type="radio" name="q5" value="c"> c) Ignorar todos los errores y siempre devolver un estado 200</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'a', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Su resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumen del cap√≠tulo:**

Ha instalado en su nave API un potente sistema de seguridad y protocolos de emergencia. Ahora puede:

- üõ°Ô∏è Repeler autom√°ticamente los ataques de "datos incorrectos" utilizando Pydantic.
- üö® Informar correctamente sobre la ausencia de recursos (`404 Not Found`) a trav√©s de `HTTPException`.
- ‚öôÔ∏è Realizar "validaciones especiales" utilizando validadores personalizados.
- üßØ Interceptar globalmente fallos inesperados y proporcionar respuestas estandarizadas.

**¬°Su "hiperimpulsor" no solo es r√°pido, sino tambi√©n incre√≠blemente fiable!**

> **üìå Verificaci√≥n:**

> - Intente crear una nave con el nombre "Death Star" y aseg√∫rese de recibir un error `400` con su mensaje personalizado.
> - Intente solicitar `GET /spaceships/999` y aseg√∫rese de recibir un error `404`.
> - Intente enviar una solicitud `POST` con `launch_year` como una cadena de texto y aseg√∫rese de recibir un error `422`.

> **‚ö†Ô∏è Si hay errores:**

> - Aseg√∫rese de que todos los m√≥dulos necesarios (`HTTPException`, `validator`, `Request`, `JSONResponse`) est√©n importados.
> - Verifique que los decoradores `@validator` y `@app.exception_handler` est√©n escritos sin errores tipogr√°ficos.

**¬°Enhorabuena por completar el Cap√≠tulo 3!** Ha construido y lanzado desde cero una API potente, documentada y protegida con FastAPI. Est√° listo para emprender aut√©nticas misiones espaciales.
