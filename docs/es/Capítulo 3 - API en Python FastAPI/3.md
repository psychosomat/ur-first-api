# **Cap√≠tulo 3.3: Modelos de datos con Pydantic**
**Tiempo de estudio:** 50 minutos

---

#### **1. Pydantic: El "plano digital" de una nave espacial**
Imagina que est√°s construyendo una nave espacial. No puedes simplemente soldar piezas de metal al azar. Necesitas un **plano detallado** que defina:

- Nombre de la nave (tipo: `cadena`, longitud m√°x.: 50 caracteres)
- A√±o de lanzamiento (tipo: `entero`)
- Presencia de hiperpropulsor (tipo: `s√≠/no`)

**Pydantic** es una librer√≠a que permite crear estos "planos digitales" para tus datos en Python. En FastAPI, cumple tres funciones clave:

1.  **Declaraci√≥n de estructura:** Describe claramente de qu√© campos se componen tus datos.
2.  **Validaci√≥n de datos:** Verifica autom√°ticamente si los datos entrantes cumplen con el plano.
3.  **Documentaci√≥n:** FastAPI utiliza estos planos para generar una documentaci√≥n detallada e interactiva.

> üí° **Analog√≠a espacial:**
> Un modelo Pydantic es el **pasaporte t√©cnico** de un objeto. Cualquier "carga" (datos) que llegue a la estaci√≥n debe cumplir con las especificaciones del pasaporte. Si no, el ordenador de a bordo (Pydantic) la rechazar√°.

---

#### **2. Creaci√≥n del primer plano: Modelo `Spaceship`**
Vamos a crear un modelo que describa nuestra nave espacial.

**Paso 1: Importamos `BaseModel` de Pydantic**
Pydantic ya est√° instalado junto con `fastapi[all]`. Solo necesitamos importar la clase base para nuestros modelos.

**A√±ade esto a `main.py` en la parte superior, junto a otras importaciones:**
```python
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
```

**Paso 2: Describimos el modelo `Spaceship`**
Crea una clase que herede de `BaseModel`. Dentro de la clase, define los campos y sus tipos, usando las anotaciones de tipo est√°ndar de Python.

**A√±ade este c√≥digo a `main.py` (puedes hacerlo despu√©s de las importaciones):**
```python
class Spaceship(BaseModel):
    """
    Pasaporte t√©cnico (modelo) de una nave espacial.
    """
    name: str
    type: str
    launch_year: int
    status: str
```
¬°Eso es todo! Acabas de crear un "plano". Pydantic ahora sabe que cualquier objeto de tipo `Spaceship` debe tener cuatro campos con los tipos especificados.

---

#### **3. Aplicaci√≥n del modelo: Mejorando nuestros endpoints**
Ahora, usemos nuestro nuevo modelo para hacer que la API sea "m√°s inteligente".

**A. Modelo como respuesta (Response Model)**
Podemos indicar a FastAPI que nuestro endpoint debe devolver datos que se ajusten al modelo `Spaceship`. Esto garantiza que la respuesta siempre tendr√° la estructura correcta.

**Modifica el endpoint `/spaceships/{ship_id}` de la siguiente manera:**
```python
# main.py

# ... c√≥digo con db_spaceships y el modelo Spaceship ...

# Usamos `response_model` para especificar el "plano" de la respuesta
@app.get("/spaceships/{ship_id}", response_model=Spaceship)
def get_spaceship(ship_id: int):
    """
    Devuelve datos sobre una nave, correspondientes al modelo Spaceship.
    """
    ship = db_spaceships.get(ship_id)
    return ship
```
- `response_model=Spaceship`: Le decimos a FastAPI: "La respuesta de esta funci√≥n debe ajustarse a la estructura `Spaceship`. Filtra cualquier campo extra y aseg√∫rate de que los tipos sean correctos".

**¬øQu√© proporciona esto?**

- **Filtrado de datos:** Si en `db_spaceships` hubiera campos extra (por ejemplo, `"secret_code"`), no se incluir√≠an en el JSON final.
- **Garant√≠a de estructura:** El cliente de la API puede estar seguro de que siempre recibir√° la respuesta en el formato esperado.
- **Documentaci√≥n:** En `/docs` ahora se mostrar√° un ejemplo de respuesta preciso (Example Value).

**B. Modelos para colecciones**
¬øY qu√© pasa con el endpoint `/spaceships`, que devuelve una *lista* de naves? Para ello, necesitamos usar `list` del m√≥dulo `typing`.

**Modifica las importaciones y el endpoint `/spaceships`:**
```python
# main.py en la parte superior
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List  # <-- Importamos List

# ... c√≥digo ...

# Indicamos que la respuesta es una lista (List) de objetos de tipo Spaceship
@app.get("/spaceships", response_model=List[Spaceship])
def get_spaceships():
    """
    Devuelve una lista de naves. Cada elemento de la lista se valida
    seg√∫n el modelo Spaceship.
    """
    # Pydantic no puede trabajar con un diccionario cuyas claves son IDs.
    # Convertimos nuestro diccionario en una lista simple.
    return list(db_spaceships.values())
```

- `response_model=List[Spaceship]`: Indicamos que la respuesta ser√° una lista, donde cada elemento es un objeto que corresponde al modelo `Spaceship`.
- `return list(db_spaceships.values())`: ¬°Cambio importante! Pydantic espera un objeto iterable (una lista), no un diccionario donde las claves son IDs. Convertimos los valores de nuestro "simulador de BD" en una lista.

---

#### **4. Verificaci√≥n de la API mejorada**
Aseg√∫rate de que el servidor `uvicorn` est√© ejecut√°ndose con `--reload`.

1.  **Verifica `http://127.0.0.1:8000/spaceships`:** Ahora la respuesta es un **array** JSON, no un objeto. Esta es una estructura m√°s correcta y est√°ndar para colecciones.
    ```json
    [
      { "name": "Voyager-1", "type": "–ó–æ–Ω–¥", ... },
      { "name": "Hubble Space Telescope", ... }
    ]
    ```
2.  **Verifica `http://127.0.0.1:8000/spaceships/1`:** La respuesta no ha cambiado, pero ahora est√° garantizado que cumple con el modelo.
3.  **Echa un vistazo a `/docs`:** En la secci√≥n "Schemas" al final de la p√°gina, aparecer√° tu modelo `Spaceship`. Y en los ejemplos de respuesta para los endpoints, ahora se mostrar√° un esquema de datos hermoso y estructurado.

---

#### **5. Validaci√≥n avanzada: El "ordenador de a bordo" en acci√≥n**
Pydantic puede hacer mucho m√°s que simplemente verificar tipos.

**A√±adamos validaci√≥n a nuestro modelo `Spaceship`:**
```python
from pydantic import BaseModel, Field

class Spaceship(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, description="Nombre de la nave")
    type: str
    launch_year: int = Field(..., gt=1950, description="El a√±o de lanzamiento debe ser posterior a 1950")
    status: str
```

- `Field(...)`: Se utiliza para a√±adir reglas de validaci√≥n adicionales.
- `...` (Ellipsis): Significa que el campo es obligatorio.
- `min_length`, `max_length`: Restricciones para cadenas de texto.
- `gt`: "Greater Than" (mayor que).

Aunque a√∫n no estamos creando nuevas naves (esto ser√° en el pr√≥ximo cap√≠tulo), estas reglas ya se reflejar√°n en la documentaci√≥n y se activar√°n cuando implementemos las peticiones `POST`.

---

#### **Cuestionario de refuerzo**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Pydantic en FastAPI se utiliza para...</p>
      <label><input type="radio" name="q1" value="a"> a) Enviar mensajes de correo electr√≥nico</label>
      <label><input type="radio" name="q1" value="b"> b) Declaraci√≥n, validaci√≥n y documentaci√≥n de modelos de datos</label>
      <label><input type="radio" name="q1" value="c"> c) Conexi√≥n directa a bases de datos</label>
    </div>
    <div class="question">
      <p>2. Para crear un modelo de datos, es necesario heredar la clase de...</p>
      <label><input type="radio" name="q2" value="a"> a) `FastAPI`</label>
      <label><input type="radio" name="q2" value="b"> b) `pydantic.Field`</label>
      <label><input type="radio" name="q2" value="c"> c) `pydantic.BaseModel`</label>
    </div>
    <div class="question">
      <p>3. El par√°metro `response_model` en el decorador `@app.get` es necesario para...</p>
      <label><input type="radio" name="q3" value="a"> a) Establecer el modelo para la solicitud entrante</label>
      <label><input type="radio" name="q3" value="b"> b) Indicar a qu√© estructura debe corresponder la respuesta de la API</label>
      <label><input type="radio" name="q3" value="c"> c) Acelerar la respuesta del servidor</label>
    </div>
    <div class="question">
      <p>4. ¬øC√≥mo indicar que un endpoint devuelve una *lista* de objetos de tipo `Item`?</p>
      <label><input type="radio" name="q4" value="a"> a) `response_model=Item[]`</label>
      <label><input type="radio" name="q4" value="b"> b) `response_model=List[Item]` (importando `List` de `typing`)</label>
      <label><input type="radio" name="q4" value="c"> c) `response_model=(Item)`</label>
    </div>
    <div class="question">
      <p>5. `Field(..., gt=0)` en un modelo Pydantic significa que el campo...</p>
      <label><input type="radio" name="q5" value="a"> a) Es opcional y debe ser igual a 0</label>
      <label><input type="radio" name="q5" value="b"> b) Es obligatorio y debe ser mayor que 0</label>
      <label><input type="radio" name="q5" value="c"> c) Es opcional y tiene tipo `float`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¬°Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Tu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumen del cap√≠tulo:**

Has dise√±ado los "planos digitales" para los datos de tu API. Ahora no solo funciona, sino que funciona de manera **predecible y fiable**.

- üìù Modelo `Spaceship` creado usando Pydantic.
- üõ°Ô∏è La API ahora valida y filtra los datos salientes usando `response_model`.
- üìä La documentaci√≥n es mucho m√°s informativa, mostrando esquemas de datos precisos.

**¬°Los planos est√°n listos y aprobados!** En el siguiente cap√≠tulo pasaremos de leer datos a crearlos ‚Äî implementaremos operaciones CRUD completas para nuestra flota.

> **üìå Verificaci√≥n:**

> - Aseg√∫rate de que el esquema del modelo `Spaceship` haya aparecido en `/docs`.
> - Verifica que el endpoint `/spaceships` ahora devuelva un array JSON (`[...]`) y no un objeto (`{...}`).
> - Aseg√∫rate de que no haya errores de sintaxis en el c√≥digo despu√©s de a√±adir los modelos.

> **‚ö†Ô∏è Si hay errores:**

> - `NameError: name 'BaseModel' is not defined`: Aseg√∫rate de haber importado `BaseModel` de `pydantic`.
> - `NameError: name 'List' is not defined`: Aseg√∫rate de haber importado `List` de `typing`.
> - La respuesta a `/spaceships` est√° vac√≠a (`[]`): Aseg√∫rate de haber cambiado `return db_spaceships` a `return list(db_spaceships.values())`.
