# **Capítulo 1.5: Pruebas de API a través de Postman**
**Tiempo de estudio:** 50 minutos

---

#### **1. ¿Por qué probamos las API? Verificación previa al lanzamiento**
Imagine: antes del lanzamiento de un cohete, los ingenieros realizan **pruebas de encendido de sistemas**. Si se omite una verificación, ¡la misión podría fallar!

Las **pruebas de API** son sus pruebas de control:

- ✅ Verificar la operatividad de los "nodos de acoplamiento"

- 🛡️ Detectar vulnerabilidades antes de su uso en combate

- 📊 Asegurarse de que los datos se transmitan sin distorsiones

> 💡 **Analogía espacial:**
> Postman es como una consola de pruebas del Centro de Control de Misiones (CCM) para simular todos los escenarios: "¿Qué pasa si se solicitan datos de un planeta inexistente? ¿Soportará el servidor 1000 solicitudes/seg?"

---

#### **2. Postman: "Centro de Control de Vuelo" para API**
**Capacidades:**

- 📡 Envío de cualquier solicitud HTTP (GET, POST, PUT, DELETE)

- 🔍 Análisis de respuestas (códigos de estado, encabezados, cuerpo JSON)

- 🧪 Escritura de pruebas automatizadas (JavaScript)

- 🌐 Trabajo con variables de entorno (pruebas vs producción)

[👉 Descargar Postman](https://www.postman.com/downloads/)

---

#### **3. Primer lanzamiento: Probando la API de planetas**
**Paso 1: Crear una solicitud**

1. Abrir Postman → New → Request

2. Introducir URL: `https://api.spacexdata.com/v4/rockets`

3. Seleccionar método: **GET**

**Paso 2: Enviar la "señal"**
```bash
[CCM] -- GET /planets --> [Servidor SpaceX]
```

**Paso 3: Analizar la telemetría:**
- Estado: `200 OK`
- Cuerpo de la respuesta (JSON): lista de cohetes con parámetros
```json
[
  {
    "name": "Falcon 1",
    "type": "rocket",
    "active": false,
    "stages": 2,
    "id": "5e9d0d95eda69955f709d1eb"
  },
  {
    "name": "Falcon 9",
    "type": "rocket",
    "active": true,
    "id": "5e9d0d95eda69973a809d1ec"
  }
]
```

---

#### **4. Esquema: Componentes de Postman**
```
[Espacio de trabajo]
├── Pestaña "Params" (Parámetros de consulta)
├── Pestaña "Headers" (Encabezados)
├── Pestaña "Body" (Cuerpo de la solicitud para POST/PUT)
├── Pestaña "Tests" (Scripts para verificaciones)
└── Panel de respuesta (Estado, Tiempo, Tamaño, Cuerpo)
```

---

#### **5. Creando un escenario complejo: Lanzamiento de una misión**
**Prueba: Añadir un nuevo planeta al catálogo**

1. Método: **POST**

2. URL: `https://jsonplaceholder.typicode.com/posts` (ejemplo)

3. En Encabezados:
   ```json
	{ "Content-Type": "application/json" }
   ```
4. En Cuerpo (raw → JSON):
   ```json
   {
	"title": "New Exoplanet Found",
	"body": "Proxima Centauri b shows signs of a stable atmosphere.",
	"userId": 1
	}
   ```

**Verificación automática en Tests:**
```javascript
// Verificación de estado
pm.test("Post created successfully", () => {
    pm.response.to.have.status(201);
});

// Verificación de estructura y datos de la respuesta
pm.test("Response contains the new post data", () => {
    const response = pm.response.json();
    pm.expect(response).to.have.property("id"); // Verificamos que el servidor asignó un ID
    pm.expect(response.title).to.eql("New Exoplanet Found");
});
```

---

#### **6. Variables de entorno: Tierra vs Marte**

¿Cómo probar en diferentes servidores (de prueba/producción)?

1. Crear entornos:
   - `Local` → `http://localhost:3000`
   - `Production` → `https://api.nasa.gov`

2. En las solicitudes, usar variables:
   ```bash
   {{base_url}}/planets  # Sustituirá la URL actual
   ```

> ⚠️ **¡Importante!** ¡Nunca pruebe `DELETE` en un servidor de producción!

---

#### **7. Colecciones: Biblioteca de misiones espaciales**
Agrupar solicitudes:
```
	📂 Colección "NASA"
  	├── GET Planetas
  	├── POST Nuevo planeta
  	└── DELETE Planeta (modo de prueba)
```
**Ventajas:**

- 🚀 Ejecutar todas las pruebas con un solo botón
- 📤 Exportar/importar configuraciones
- 👨‍🚀 Trabajo colaborativo en equipo

---

#### **8. Automatización: Verificaciones regulares de satélites**

Configurar la **monitorización de API** a través de Postman:

1. Schedule → Cada 2 horas

2. Pruebas:
   ```javascript
   pm.test("Satélite en línea", () => {
     pm.response.to.have.status(200);
     pm.expect(pm.response.json().signal).above(50); // Señal >50%
   });
   ```

3. Notificaciones en Slack/email en caso de fallo

---

#### **Cuestionario para consolidar**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Postman se utiliza para:</p>
      <label><input type="radio" name="q1" value="a"> a) Enviar correo</label>
      <label><input type="radio" name="q1" value="b"> b) Probar API</label>
      <label><input type="radio" name="q1" value="c"> c) Crear bases de datos</label>
    </div>
    <div class="question">
      <p>2. ¿Qué estado esperar al crear un objeto con éxito?</p>
      <label><input type="radio" name="q2" value="a"> a) 200 OK</label>
      <label><input type="radio" name="q2" value="b"> b) 201 Created</label>
      <label><input type="radio" name="q2" value="c"> c) 404 Not Found</label>
    </div>
    <div class="question">
      <p>3. ¿Dónde escribir pruebas automatizadas en Postman?</p>
      <label><input type="radio" name="q3" value="a"> a) Pestaña "Body"</label>
      <label><input type="radio" name="q3" value="b"> b) Pestaña "Tests"</label>
      <label><input type="radio" name="q3" value="c"> c) Pestaña "Cookies"</label>
    </div>
    <div class="question">
      <p>4. Las variables de entorno son necesarias para:</p>
      <label><input type="radio" name="q4" value="a"> a) Alternar entre el servidor de prueba y el de producción</label>
      <label><input type="radio" name="q4" value="b"> b) Almacenar contraseñas en texto claro</label>
      <label><input type="radio" name="q4" value="c"> c) Generar datos aleatorios</label>
    </div>
    <div class="question">
      <p>5. ¿Qué verifican las monitorizaciones regulares?</p>
      <label><input type="radio" name="q5" value="a"> a) La estabilidad del funcionamiento de la API</label>
      <label><input type="radio" name="q5" value="b"> b) La velocidad de internet</label>
      <label><input type="radio" name="q5" value="c"> c) La actualidad de la documentación</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:green;">¡Correcto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:red;">Incorrecto.</span> Respuesta correcta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pregunta ${question.slice(1)}: <span style="color:orange;">Sin respuesta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Su resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**🚀 Resumen del capítulo:**
Postman es su "consola de control" universal para probar API. Con él, usted:
- Verificará el funcionamiento de los "sistemas a bordo" antes del lanzamiento
- Creará una biblioteca de escenarios de prueba
- Automatizará la monitorización de servicios espaciales

> **📌 Ejercicio práctico:**

> 1. Instale Postman
> 2. Cree una solicitud a la API de SpaceX: `GET https://api.spacexdata.com/v4/launches/latest`
> 3. Escriba una prueba que verifique que:
>    - El estado de la respuesta es `200`
>    - El campo `name` contiene la palabra "Falcon"
>    - El tiempo de respuesta es < 500 ms

**¡Felicidades por completar el Capítulo 1!**

Ha dominado los fundamentos del trabajo con API. ¡En los próximos capítulos construiremos nuestra propia "nave espacial" – una aplicación web que utiliza API espaciales!

> **🌌 Recursos adicionales:**

> - [SpaceX API Documentation](https://docs.spacexdata.com/)