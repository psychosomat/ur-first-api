# **Chapter 1.5: Testing an API with Postman**
**Study time:** 50 minutes

---

#### **1. Why Test an API? Pre-launch Check**
Imagine: before launching a rocket, engineers conduct **test system activations**. Skip the check, and the mission could fail!

**API testing** is your control test:

- âœ… Check the functionality of the "docking ports"

- ðŸ›¡ï¸ Detect vulnerabilities before live use

- ðŸ“Š Ensure that data is transmitted without distortion

> ðŸ’¡ **Space analogy:**
> Postman is like a test console at the MCC for simulating all scenarios: "What if we request data about a non-existent planet? Can the server handle 1000 requests/sec?"

---

#### **2. Postman: The "Mission Control Center" for APIs**
**Features:**

- ðŸ“¡ Sending any HTTP requests (GET, POST, PUT, DELETE)

- ðŸ” Analyzing responses (status codes, headers, JSON body)

- ðŸ§ª Writing automated tests (JavaScript)

- ðŸŒ Working with environment variables (test vs. production)

[ðŸ‘‰ Download Postman](https://www.postman.com/downloads/)

---

#### **3. First Launch: Testing the Planets API**
**Step 1: Create a request**

1. Open Postman â†’ New â†’ Request

2. Enter the URL: `https://api.spacexdata.com/v4/rockets`

3. Select the method: **GET**

**Step 2: Send the "signal"**
```bash
[MCC] -- GET /planets --> [SpaceX Server]
```

**Step 3: Analyze the telemetry:**
- Status: `200 OK`
- Response body (JSON): a list of rockets with parameters
```json
[
  {
    "name": "Falcon 1",
    "type": "rocket",
    "active": false,
    "stages": 2,
    "id": "5e9d0d95eda69955f709d1eb"
  },
  {
    "name": "Falcon 9",
    "type": "rocket",
    "active": true,
    "id": "5e9d0d95eda69973a809d1ec"
  }
]
```

---

#### **4. Diagram: Postman Components**
```
[Workspace]
â”œâ”€â”€ "Params" tab (Query parameters)
â”œâ”€â”€ "Headers" tab (Headers)
â”œâ”€â”€ "Body" tab (Request body for POST/PUT)
â”œâ”€â”€ "Tests" tab (Scripts for checks)
â””â”€â”€ Response panel (Status, Time, Size, Body)
```

---

#### **5. Creating a Complex Scenario: Mission Launch**
**Test: Adding a new planet to the catalog**

1. Method: **POST**

2. URL: `https://jsonplaceholder.typicode.com/posts` (example)

3. In Headers:
   ```json
	{ "Content-Type": "application/json" }
   ```
4. In Body (raw â†’ JSON):
   ```json
   {
	"title": "New Exoplanet Found",
	"body": "Proxima Centauri b shows signs of a stable atmosphere.",
	"userId": 1
	}
   ```

**Automated check in Tests:**
```javascript
// Status check
pm.test("Post created successfully", () => {
    pm.response.to.have.status(201);
});

// Checking the structure and data of the response
pm.test("Response contains the new post data", () => {
    const response = pm.response.json();
    pm.expect(response).to.have.property("id"); // Check that the server has assigned an ID
    pm.expect(response.title).to.eql("New Exoplanet Found");
});
```

---

#### **6. Environment Variables: Earth vs. Mars**

How to test on different servers (test/production)?

1. Create environments:
   - `Local` â†’ `http://localhost:3000`
   - `Production` â†’ `https://api.nasa.gov`

2. Use variables in requests:
   ```bash
   {{base_url}}/planets  # Will substitute the current URL
   ```

> âš ï¸ **Important!** Never test `DELETE` on a production server!

---

#### **7. Collections: A Library of Space Missions**
Group requests:
```
	ðŸ“‚ "NASA" Collection
  	â”œâ”€â”€ GET Planets
  	â”œâ”€â”€ POST New Planet
  	â””â”€â”€ DELETE Planet (test mode)
```
**Advantages:**

- ðŸš€ Run all tests with one button
- ðŸ“¤ Export/import configurations
- ðŸ‘¨â€ðŸš€ Team collaboration

---

#### **8. Automation: Regular Satellite Checks**

Set up **API monitoring** via Postman:

1. Schedule â†’ Every 2 hours

2. Tests:
   ```javascript
   pm.test("Satellite online", () => {
     pm.response.to.have.status(200);
     pm.expect(pm.response.json().signal).above(50); // Signal >50%
   });
   ```

3. Notifications to Slack/email on failure

---

#### **Quiz for reinforcement**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Postman is used for:</p>
      <label><input type="radio" name="q1" value="a"> a) Sending mail</label>
      <label><input type="radio" name="q1" value="b"> b) API testing</label>
      <label><input type="radio" name="q1" value="c"> c) Creating databases</label>
    </div>
    <div class="question">
      <p>2. What status to expect when an object is created successfully?</p>
      <label><input type="radio" name="q2" value="a"> a) 200 OK</label>
      <label><input type="radio" name="q2" value="b"> b) 201 Created</label>
      <label><input type="radio" name="q2" value="c"> c) 404 Not Found</label>
    </div>
    <div class="question">
      <p>3. Where to write automated tests in Postman?</p>
      <label><input type="radio" name="q3" value="a"> a) "Body" tab</label>
      <label><input type="radio" name="q3" value="b"> b) "Tests" tab</label>
      <label><input type="radio" name="q3" value="c"> c) "Cookies" tab</label>
    </div>
    <div class="question">
      <p>4. Environment variables are needed for:</p>
      <label><input type="radio" name="q4" value="a"> a) Switching between test and production servers</label>
      <label><input type="radio" name="q4" value="b"> b) Storing passwords in plain text</label>
      <label><input type="radio" name="q4" value="c"> c) Generating random data</label>
    </div>
    <div class="question">
      <p>5. What do regular monitoring checks verify?</p>
      <label><input type="radio" name="q5" value="a"> a) API stability</label>
      <label><input type="radio" name="q5" value="b"> b) Internet speed</label>
      <label><input type="radio" name="q5" value="c"> c) Documentation relevance</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> The correct answer is: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**ðŸš€ Chapter summary:**
Postman is your universal "control panel" for API testing. With it you will:
- Check the operation of "onboard systems" before launch
- Create a library of test scenarios
- Automate the monitoring of space services

> **ðŸ“Œ Practical task:**
>
> 1. Install Postman
> 2. Create a request to the SpaceX API: `GET https://api.spacexdata.com/v4/launches/latest`
> 3. Write a test that checks that:
>    - The response status is `200`
>    - The `name` field contains the word "Falcon"
>    - The response time is < 500 ms

**Congratulations on completing Chapter 1!**

You have mastered the basics of working with APIs. In the following chapters, we will build our own "spaceship" - a web application that uses space APIs!

> **ðŸŒŒ Additional resources:**
>
> - [SpaceX API Documentation](https://docs.spacexdata.com/)