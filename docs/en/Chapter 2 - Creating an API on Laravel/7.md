# **Chapter 2.7: Error Handling**
**Time to learn:** 40 minutes

---

#### **1. Why Are Default Errors Bad?**

If an error occurs in your Laravel application (for example, a record is not found in the database) and you haven't handled it, the user will see a huge HTML page with debug information or an uninformative "Server Error" message.

For an API, this is a disaster. Your frontend application expects to receive JSON, not HTML. Our task is to catch any error and turn it into a structured JSON response.

---

#### **2. The Central Error Dispatcher: `bootstrap/app.php`**

In older versions of Laravel, there was a cumbersome `App\Exceptions\Handler.php` file. In Laravel 11/12, everything has become much simpler and more elegant. The error handling control center is now located directly in your application's configuration file â€” `bootstrap/app.php`.

Open `bootstrap/app.php`. At the very bottom, you will see the `.withExceptions(...)` block. This is our "central dispatcher."

```php
<?php
// bootstrap/app.php

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        api: __DIR__.'/../routes/api.php',
        commands: __DIR__.'/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        // ...
    })
    ->withExceptions(function (Exceptions $exceptions) {
        // <-- THIS IS WHERE WE WILL WORK
    })->create();
```

---

#### **3. Handling the Most Common Error: "Not Found" (404)**

The most common error in an API is when a user requests a resource that does not exist (e.g., `GET /api/planets/999`). In this case, Laravel generates a `ModelNotFoundException` or `NotFoundHttpException`. Let's catch them.

Add the following code inside `.withExceptions(...)`:

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // Catch the exception when a model is not found in the database
    $exceptions->render(function (ModelNotFoundException $e, Request $request) {
        // Check that the request is for our API
        if ($request->is('api/*')) {
            return response()->json([
                'message' => 'The requested resource was not found in our galaxy.'
            ], 404);
        }
    });

    // Catch the exception when the route itself is not found
    $exceptions->render(function (NotFoundHttpException $e, Request $request) {
        if ($request->is('api/*')) {
            return response()->json([
                'message' => 'This cosmic route does not exist.'
            ], 404);
        }
    });

})->create();
```
**What did we do?**

1.  `$exceptions->render(...)` â€” We register a "handler." It says: "If an exception of type `ModelNotFoundException` occurs, execute this code."
2.  `if ($request->is('api/*'))` â€” This is an important check. It ensures that our nice JSON response is only sent for API requests, without affecting regular web pages.
3.  `return response()->json(...)` â€” We create and return a standardized JSON response with a 404 code.

Now, if you request a non-existent planet, you will get a neat JSON response instead of an ugly HTML page.

---

#### **4. Custom Exceptions: Creating Your Own "Alarm Signals"**

Sometimes, standard exceptions are not enough. Imagine we have a business rule: "you cannot delete the planet 'Earth'". If someone tries to do this, we must return a meaningful error.

**Step 1: Create our own exception class**
Run in the terminal:
```bash
php artisan make:exception CannotDeleteEarthException
```

**Step 2: Use it in the controller**
Open `PlanetController.php` and modify the `destroy` method:

```php
<?php
// app/Http/Controllers/PlanetController.php
use App\Exceptions\CannotDeleteEarthException; // <-- Import our exception
use App\Models\Planet;

public function destroy(Planet $planet)
{
    // Our new business rule
    if (strtolower($planet->name) === 'earth') {
        throw new CannotDeleteEarthException('Deleting planet Earth is forbidden by the Galactic Code.');
    }

    $planet->delete();
    return response()->json(null, 204);
}
```
Now, if someone tries to execute `DELETE /api/planets/1` (where 1 is the ID of Earth), our code will throw a `CannotDeleteEarthException`.

**Step 3: Teach Laravel to handle our "alarm" gracefully**
Let's go back to `bootstrap/app.php` and add a new handler for our exception.

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // Our new handler
    $exceptions->render(function (CannotDeleteEarthException $e, Request $request) {
        return response()->json([
            'message' => 'Operation forbidden.',
            'details' => $e->getMessage() // Get the message we passed in the throw
        ], 403); // 403 Forbidden
    });

    // ... (other handlers for 404)

})->create();
```
Done! We have created our own named exception, which makes the controller code cleaner, and taught Laravel to turn it into a beautiful, meaningful JSON response with the correct HTTP status.

---

#### **5. Handling All Other Failures (500 Internal Server Error)**

What about all other, unforeseen errors? For example, if the database connection is lost or there is a syntax error in the code. For this, we can register a "universal" handler for the most general type of error â€” `Throwable`.

**Important:** This handler must be the **last one** so that it does not catch the more specific exceptions we defined above.

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // ... (handlers for CannotDeleteEarthException and 404)

    // UNIVERSAL HANDLER (at the very end)
    $exceptions->render(function (Throwable $e, Request $request) {
        if ($request->is('api/*')) {
            // In debug mode, you can show the real error message
            $message = config('app.debug')
                ? 'An error occurred: ' . $e->getMessage()
                : 'An unexpected error occurred on board. Engineers have been dispatched.';

            return response()->json(['message' => $message], 500);
        }
    });

})->create();
```

Now any "unknown" exception will be neatly caught and turned into a JSON response with a 500 code, without breaking your API or showing the user unnecessary information.

---

#### **6. Error Logging: The Spaceship's Black Box**
Logging settings in `config/logging.php`:
```php
<?php
'channels' => [
    'space_api' => [
        'driver' => 'daily',
        'path' => storage_path('logs/space_api.log'),
        'level' => 'error',
        'days' => 14,
    ],
],
```

**Adding a log entry:**
```php
<?php
try {
    // Code with risk of error
} catch (Exception $e) {
    Log::channel('space_api')->error('Error accessing planets', [
        'exception' => $e,
        'request' => request()->all(),
        'user_id' => auth()->id()
    ]);
    throw $e;
}
```

---

#### **Review Quiz**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. The HTTP status for "Planet not found" is:</p>
      <label><input type="radio" name="q1" value="a"> a) 400</label>
      <label><input type="radio" name="q1" value="b"> b) 404</label>
      <label><input type="radio" name="q1" value="c"> c) 500</label>
    </div>
    <div class="question">
      <p>2. In modern Laravel, where is global error handling configured?</p>
      <label><input type="radio" name="q2" value="a"> a) bootstrap/app.php</label>
      <label><input type="radio" name="q2" value="b"> b) App/Exceptions/Handler.php</label>
      <label><input type="radio" name="q2" value="c"> c) App/Http/Controllers/ErrorController.php</label>
    </div>
    <div class="question">
      <p>3. The command to create a custom exception is:</p>
      <label><input type="radio" name="q3" value="a"> a) php artisan make:exception</label>
      <label><input type="radio" name="q3" value="b"> b) php artisan exception:create</label>
      <label><input type="radio" name="q3" value="c"> c) php artisan generate:exception</label>
    </div>
    <div class="question">
      <p>4. To create a separate log channel for API errors, you should:</p>
      <label><input type="radio" name="q4" value="a"> a) Configure it in config/logging.php</label>
      <label><input type="radio" name="q4" value="b"> b) Set a parameter in .env</label>
      <label><input type="radio" name="q4" value="c"> c) Specify it in the controller</label>
    </div>
    <div class="question">
      <p>5. The main advantage of creating custom exceptions is:</p>
      <label><input type="radio" name="q5" value="a"> a) Improved performance</label>
      <label><input type="radio" name="q5" value="b"> b) Creating semantically clear errors for specific business scenarios</label>
      <label><input type="radio" name="q5" value="c"> c) Automatic addition to .env</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'a', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> The correct answer is: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**ðŸš€ Chapter Summary:**

You have equipped your API with a reliable rescue system:

- ðŸ›Ÿ Global interception of standard errors
- ðŸª Custom exceptions with clear codes
- ðŸ“ A unified JSON format for all errors
- ðŸ” Logging with incident details

**The spaceship is ready for emergencies!** In the final chapter of this section, we will test all the systems.

> **ðŸ“Œ Checkpoint:**

> 1. Create a custom exception like `PlanetNotFoundException`
> 2. Add handling for 404 errors in the `.withExceptions` closure
> 3. Test a request to a non-existent planet

> **âš ï¸ If errors are not being caught:**

> - Make sure `is('api/*')` matches your routes
> - Check the order of your handlers within `withExceptions`
> - For custom exceptions, make sure you are using `throw new`