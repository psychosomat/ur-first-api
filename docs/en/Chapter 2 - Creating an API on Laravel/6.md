# **Chapter 2.6: Data Validation**
**Time to learn:** 50 minutes

---

#### **1. Validation: A Cosmic-Scale Shield**
**Validation** is the process of checking incoming data against a set of rules. Without it:

- ðŸš€ Incorrect data could "destroy" your database
- ðŸŒŒ Attackers could inject malicious code
- ðŸª Users would receive confusing errors

> ðŸ’¡ **Space Analogy:**
> Validation = The space station's defense system:

> - It checks the "cargo" (data) before docking
> - It rejects dangerous objects
> - It filters out space debris

---

#### **2. Where to Validate in a Laravel API**
The main approaches are:

1. **In the Controller** (quick, but clutters the code)
2. **Form Request** (recommended, clean architecture)

---

#### **3. Validation in the Controller**
We use the `validate()` method of the Request object:
```php
<?php
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ]);

    // ... create the planet
}
```

**Popular Validation Rules:**

| Rule              | Description                          | Example                     |
|----------------------|-----------------------------------|----------------------------|
| `required`           | The field is mandatory                 | `'name' => 'required'`     |
| `string`             | Must be a string value                | `'description' => 'string'`|
| `integer`            | Must be an integer                       | `'size_km' => 'integer'`   |
| `min:value`          | Minimum value/length        | `'size_km' => 'min:100'`   |
| `max:value`          | Maximum value/length       | `'name' => 'max:255'`      |
| `unique:table,column`| Must be unique in the table            | `'name' => 'unique:planets'` |
| `url`                | Must be a valid URL                    | `'image_url' => 'url'`     |
| `boolean`            | true/false/1/0                    | `'is_habitable' => 'boolean'` |

---

#### **4. Custom Error Messages**
Change the default error messages:
```php
<?php
$validated = $request->validate(
    [
        'name' => 'required|unique:planets',
        'size_km' => 'min:1000'
    ],
    [
        'name.required' => 'The planet name is required!',
        'name.unique' => 'A planet with this name already exists in the catalog',
        'size_km.min' => 'The planet diameter cannot be less than 1000 km'
    ]
);
```

**Example response on error (automatically 422 Unprocessable Entity):**
```json
{
    "message": "The given data was invalid.",
    "errors": {
        "name": ["A planet with this name already exists in the catalog"],
        "size_km": ["The planet diameter cannot be less than 1000 km"]
    }
}
```

---

#### **5. Creating a Form Request**
For complex validation, we create a dedicated class:

**Step 1: Generation**
```bash
php artisan make:request StorePlanetRequest
```

**Step 2: Edit `app/Http/Requests/StorePlanetRequest.php`**
```php
<?php
public function authorize()
{
    return true; // Usually true for APIs
}

public function rules()
{
    return [
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ];
}

public function messages()
{
    return [
        'name.unique' => 'A planet with this name already exists!',
        'size_km.min' => 'The diameter cannot be less than 100 km'
    ];
}
```

**Step 3: Use it in the controller**
```php
<?php
use App\Http\Requests\StorePlanetRequest;

public function store(StorePlanetRequest $request)
{
    // The data is already validated!
    $validated = $request->validated();
    $planet = Planet::create($validated);
    return response()->json($planet, 201);
}
```

---

#### **6. Custom Validation Rules**
Let's create a rule to check for the "reasonableness" of a planet's name. Standard Laravel rules can't check if a name is "forbidden," so we'll write our own logic.

**Step 1: Generate the Rule**

Laravel provides an Artisan command to create a rule class boilerplate. Let's run it in the terminal:

```bash
php artisan make:rule ValidPlanetName
```

**Step 2: Edit `app/Rules/ValidPlanetName.php`**

Open the created file. Its structure is simple and clear. Our task is to implement the logic inside the `validate` method.

```php
<?php

namespace App\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;

class ValidPlanetName implements ValidationRule
{
    /**
     * Run the validation rule.
     *
     * @param  \Closure(string): \Illuminate\Translation\PotentiallyTranslatedString  $fail
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        // Our "blacklist" of names
        $forbidden = ['Earth 2.0', 'Nibiru', 'Planet X'];

        // Check if the input value is in our list,
        // ignoring case.
        if (in_array(strtolower($value), array_map('strtolower', $forbidden))) {
            // If the check fails, call the $fail function
            // with the error message the user will see.
            $fail('This planet name is forbidden!');
        }
    }
}
```

**Step 3: Use it in the Form Request**

Now our custom rule is ready to use. We can include it in any Form Request by simply creating a new instance of our class.

Let's open `app/Http/Requests/StorePlanetRequest.php` and add `new ValidPlanetName` to the rules array for the `name` field.

```php
<?php
// app/Http/Requests/StorePlanetRequest.php

namespace App\Http\Requests;

use App\Rules\ValidPlanetName; // <-- Don't forget to import the class
use Illuminate\Foundation\Http\FormRequest;

class StorePlanetRequest extends FormRequest
{
    // ... (authorize method)

    public function rules(): array
    {
        return [
            'name' => [
                'required',
                'string',
                'max:255',
                'unique:planets',
                new ValidPlanetName, // <-- Here is our custom rule
            ],
            'description' => 'required|string',
            'size_km' => 'required|integer|min:100|max:500000',
            'solar_system' => 'required|string|max:100',
            'image_url' => 'nullable|url|max:2048',
            'is_habitable' => 'required|boolean'
        ];
    }

    // ... (messages method)
}
```
Done. Now when creating a planet, Laravel will sequentially apply all rules to the `name` field and, upon reaching `new ValidPlanetName`, will execute our custom logic.

---

#### **7. Validation for Updates**
Specifics for updating data:

> When updating a record, validation rules often differ. The main feature is the uniqueness check, which must ignore the current record being updated.

**Step 1: Create a separate Form Request for updates**
 ```bash
 php artisan make:request UpdatePlanetRequest
 ```
**Step 2: Edit `app/Http/Requests/UpdatePlanetRequest.php`**
```php
<?php
use Illuminate\Validation\Rule;

public function authorize(): bool
{
    return true;
}
public function rules(): array
{
	$planet = $this->route('planet'); // Get the model from the route

     return [
         'name' => [
             'sometimes', // Validate only if the field is present in the request
             'required',
             'string',
             'max:255',
             Rule::unique('planets')->ignore($planet->id),
         ],
         'description'  => 'sometimes|required|string',
         'size_km'      => 'sometimes|required|integer|min:100|max:500000',
         // ... other fields with 'sometimes'
     ];
 }
```
**Step 3: Use it in the controller**
```php
<?php
 use App\Http\Requests\UpdatePlanetRequest;

 public function update(UpdatePlanetRequest $request, Planet $planet)
 {
     $validated = $request->validated();
     $planet->update($validated);
     return response()->json($planet);
 }
```

---

#### **8. Testing Validation in Postman**
**Scenario 1: Name Uniqueness Error**
```json
POST /api/planets
{
    "name": "Mars",
    "description": "The red planet, a target for future colonization",
    "size_km": 6779,
    "solar_system": "Solar System",
    "is_habitable": false
}
```
**Expected Response:**
```json
{
    "message": "The given data was invalid.",
    "errors": {
        "name": ["A planet with this name already exists!"]
    }
}
```

**Scenario 2: Incorrect Diameter**
```json
{
    "name": "Pea Planet",
    "size_km": 50 // < min:100
}
```
**Expected Response:**
```json
"errors": {
    "size_km": ["The diameter cannot be less than 100 km"]
}
```

---

#### **Review Quiz**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. The HTTP status for validation errors is:</p>
      <label><input type="radio" name="q1" value="a"> a) 400 Bad Request</label>
      <label><input type="radio" name="q1" value="b"> b) 422 Unprocessable Entity</label>
      <label><input type="radio" name="q1" value="c"> c) 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. The rule for checking uniqueness is:</p>
      <label><input type="radio" name="q2" value="a"> a) unique:table</label>
      <label><input type="radio" name="q2" value="b"> b) distinct</label>
      <label><input type="radio" name="q2" value="c"> c) only:table</label>
    </div>
    <div class="question">
      <p>3. Where is the best place to put complex validation rules?</p>
      <label><input type="radio" name="q3" value="a"> a) In the controller</label>
      <label><input type="radio" name="q3" value="b"> b) In the model</label>
      <label><input type="radio" name="q3" value="c"> c) In a Form Request</label>
    </div>
    <div class="question">
      <p>4. The `authorize()` method in a Form Request should return:</p>
      <label><input type="radio" name="q4" value="a"> a) false</label>
      <label><input type="radio" name="q4" value="b"> b) true</label>
      <label><input type="radio" name="q4" value="c"> c) null</label>
    </div>
    <div class="question">
      <p>5. The `sometimes` rule means:</p>
      <label><input type="radio" name="q5" value="a"> a) The field is required</label>
      <label><input type="radio" name="q5" value="b"> b) The field is validated only if present</label>
      <label><input type="radio" name="q5" value="c"> c) The field is ignored</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'c', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> The correct answer is: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**ðŸš€ Chapter Summary:**

You have installed a powerful defense system for your cosmic API:

- ðŸ›¡ï¸ Basic and custom validation rules
- ðŸ“ Readable error messages
- ðŸ§© Form Requests for complex scenarios
- âš™ï¸ Unique rules for updating data

**Your universe is now protected!** Next, we will learn how to handle "cosmic accidents" - server errors.

> **ðŸ“Œ Checkpoint:**

> 1. Create a Form Request for updating planets
> 2. Add a custom rule to validate the name
> 3. Test the errors using Postman

> **âš ï¸ If validation doesn't work:**

> - Check the Form Request injection in the controller method
> - Make sure `authorize()` returns true
> - For uniqueness on update, use `Rule::unique`