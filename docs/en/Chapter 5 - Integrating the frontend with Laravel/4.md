# **Chapter 5.4: Working with CSRF Tokens**
**Study time:** 30 minutes

---

### **1. What is a CSRF Attack? "Hijacking" Your Ship**

Imagine you are logged into the control panel of your space fleet (`space-api.test`). In the next tab, you open a harmless website with cats (`evil-cats.com`). This site has a hidden form that automatically sends a request to your site at `POST /api/planets/1/delete`.

Since you are already authenticated on `space-api.test`, your browser will kindly attach all your cookies to this request. The Laravel server will see a valid session and think that you yourself decided to decommission the planet. **The planet will be deleted without your knowledge.**

This is **CSRF (Cross-Site Request Forgery)** â€” an attack in which an attacker forces the browser of an authenticated user to perform an unwanted action on a trusted site.

> ðŸ’¡ **Space Analogy:**
>
> You are the captain of a ship, and you have a key card (session/cookie). An attacker cannot steal your card. But he can trick you into applying it to a resource decommissioning terminal while you are distracted. A CSRF token is like a PIN code that you need to enter along with the card. The attacker does not know the PIN code, and his attack fails.

---

### **2. How Laravel Protects Against CSRF?**

By default, Laravel protects all "unsafe" web requests (POST, PUT, PATCH, DELETE) with a **CSRF token**.

1.  When generating a page, Laravel creates a unique, random token for the user's session.
2.  This token is embedded in HTML forms.
3.  When the form is submitted, the token is sent along with the request.
4.  On the server, the `VerifyCsrfToken` middleware compares the token from the request with the token stored in the session.
5.  **If the tokens do not match, Laravel aborts the request with a 419 error (Session Expired/Page Expired).**

**Important:** API routes in `routes/api.php` are **not** protected by CSRF, as they assume a different authentication mechanism (e.g., Sanctum tokens), rather than cookie-based sessions. Our current problem concerns the web routes and pages that we create in `routes/web.php`.

---

### **3. Using a CSRF Token in HTML Forms**
This is the simplest scenario. Laravel provides a special Blade directive for this.

**Example: Form for creating a planet**
Let's create a simple form in the file `resources/views/planets/create.blade.php`:

```html
<h2>Form for launching a new planet</h2>
<form action="/planets" method="POST">
    @csrf {{-- Here it is, the magic! --}}

    <label for="name">Name:</label>
    <input type="text" id="name" name="name" required>

    <label for="solar_system">Solar System:</label>
    <input type="text" id="solar_system" name="solar_system" required>

    {{-- ... other fields ... --}}

    <button type="submit">Launch</button>
</form>
```

The `@csrf` directive will automatically generate a hidden field in the form:
```html
<input type="hidden" name="_token" value="j2aK3dLf4gH5...unique_token...">
```

This is enough to protect standard HTML forms.

---

### **4. Using a CSRF Token in AJAX/Fetch Requests**

In the previous chapter, we sent a `DELETE` request using JavaScript. Now Laravel will block it with a 419 error. We need to add a CSRF token to the headers of our Fetch request.

**Step 1: Make the token available to JavaScript**

Add a meta tag with the token to the `<head>` of your master layout `resources/views/app.blade.php`. This is standard practice in Laravel.

```blade
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    {{-- Add the CSRF token to a meta tag --}}
    <meta name="csrf-token" content="{{ csrf_token() }}">

    {{-- ... --}}
</head>
```

The `csrf_token()` function returns the current token.

**Step 2: Modify the JavaScript to send the token**

Now in our `public/js/planets.js`, we can read this token and add it to the headers of all "unsafe" requests.

```javascript
// ... in the file public/js/planets.js ...

document.addEventListener('DOMContentLoaded', () => {
    // Get the token from the meta tag
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const deleteButtons = document.querySelectorAll('.delete-btn');

    deleteButtons.forEach(button => {
        button.addEventListener('click', async (event) => {
            // ... confirmation logic ...

            try {
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-TOKEN': csrfToken // <-- Add the token to the headers!
                    }
                });

                // ... rest of the response handling logic ...
            } catch (error) {
                // ...
            }
        });
    });
});
```

-   The header name `X-CSRF-TOKEN` is the standard that Laravel checks by default.

Now our AJAX requests are also protected. Try deleting a planet again â€” this time the request will be successful.

---

### **Quiz to Reinforce**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. What attack does a CSRF token prevent?</p>
      <label><input type="radio" name="q1" value="a"> a) SQL Injection</label>
      <label><input type="radio" name="q1" value="b"> b) Cross-Site Scripting (XSS)</label>
      <label><input type="radio" name="q1" value="c"> c) Cross-Site Request Forgery (CSRF)</label>
    </div>
    <div class="question">
      <p>2. Which Blade directive adds a hidden field with a CSRF token to a form?</p>
      <label><input type="radio" name="q2" value="a"> a) @token</label>
      <label><input type="radio" name="q2" value="b"> b) @csrf</label>
      <label><input type="radio" name="q2" value="c"> c) @form_token</label>
    </div>
    <div class="question">
      <p>3. What happens if you send a POST request without a CSRF token to a web route?</p>
      <label><input type="radio" name="q3" value="a"> a) 500 (Internal Server Error)</label>
      <label><input type="radio" name="q3" value="b"> b) 403 (Forbidden)</label>
      <label><input type="radio" name="q3" value="c"> c) 419 (Page Expired / Session Expired)</label>
    </div>
    <div class="question">
      <p>4. What is the standard HTTP header used to send a CSRF token in AJAX requests?</p>
      <label><input type="radio" name="q4" value="a"> a) Authorization</label>
      <label><input type="radio" name="q4" value="b"> b) X-CSRF-TOKEN</label>
      <label><input type="radio" name="q4" value="c"> c) Content-Type</label>
    </div>
    <div class="question">
      <p>5. Why don't API routes (`routes/api.php`) use CSRF protection by default?</p>
      <label><input type="radio" name="q5" value="a"> a) Because they are intended for stateless authentication</label>
      <label><input type="radio" name="q5" value="b"> b) It's a bug in Laravel, they need to be enabled manually</label>
      <label><input type="radio" name="q5" value="c"> c) Because API requests cannot be forged</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'c', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> Correct answer: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**ðŸš€ Chapter Summary:**

You have installed an "identification friend or foe" system on your spaceship, protecting it from CSRF attacks. You have learned to:

-   Understand the nature and danger of CSRF attacks.
-   Protect standard HTML forms with the `@csrf` directive.
-   Pass the CSRF token to JavaScript via a meta tag.
-   Include the token in the headers of AJAX/Fetch requests for their successful execution.

**Your web interfaces are now not only interactive, but also secure.** In the next chapter, we will finish creating our web interface by looking at how to properly organize routing for web pages.