# **Chapter 6.5: API Security Basics**
**Study Time:** 45 minutes

---

#### **1. API Security: Multi-Level Station Defense**

Imagine your space station (API) is in a hostile sector of space. A single force field (authentication) is not enough. You need a comprehensive defense system:

- **Shields (HTTPS):** Encryption of all traffic.
- **Anomaly Sensors (Rate Limiting):** Protection against too frequent requests.
- **Internal Bulkheads (Authorization):** Separation of access rights.
- **Cargo Inspection (Validation):** Do not trust any incoming data.
- **Secret Safe (Environment Variables):** Secure storage of keys.

Let's configure each of these levels.

---

#### **2. Shields: Always Use HTTPS**

**What is it?** HTTPS (HyperText Transfer Protocol Secure) is a version of the HTTP protocol that encrypts all data between the client and the server. Without it, anyone who "listens" to the network (for example, on public Wi-Fi) can intercept logins, passwords, and tokens.

**How to implement it?**

- **On production â€” mandatory.** When deploying your API to a real server (Heroku, DigitalOcean, etc.), configure the web server (Nginx, Apache) to work with an SSL certificate. Services like **Let's Encrypt** provide free certificates.
- **In local development,** this is less critical, but tools like **Laravel Herd** or **mkcert** make it easy to set up local HTTPS.

> ðŸ’¡ **Rule #1 in API security:** **No HTTPS â€” no security.**

---

#### **3. Anomaly Sensors: Rate Limiting**

**What is it?** Protection against **Brute-force attacks** (when an attacker tries to guess a password by sending thousands of requests per second) and against **DoS attacks** (when the server is "flooded" with requests to make it stop responding). Rate Limiting limits the number of requests that a single user (or IP address) can make in a certain period of time.

**How to implement it?**

- **In Laravel:** The middleware for limiting is already built in!
  Open `app/Http/Kernel.php` and look at the `middlewareGroups['api']` key. It already has `'throttle:api'`. The settings for this limitation are in `app/Providers/RouteServiceProvider.php` in the `configureRateLimiting()` method.
  ```php
  // app/Providers/RouteServiceProvider.php
  protected function configureRateLimiting()
  {
      RateLimiter::for('api', function (Request $request) {
          return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
      });
  }
  ```
  This means: 60 requests per minute per user (if authorized) or per IP address.

- **In FastAPI:** A third-party package is used, for example, **`slowapi`**.

  1.  Installation: `pip install slowapi`
  2.  Integration into `main.py`:
      ```python
      # main.py
      from slowapi import Limiter, _rate_limit_exceeded_handler
      from slowapi.util import get_remote_address
      from slowapi.errors import RateLimitExceeded

      limiter = Limiter(key_func=get_remote_address)
      app = FastAPI(...)

      # Connect the error handler and the limiter itself
      app.state.limiter = limiter
      app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

      # Apply to a specific endpoint
      @router.get("/planets")
      @limiter.limit("5/minute") # 5 requests per minute
      def get_planets(request: Request):
          # ...
      ```

---

#### **4. Internal Bulkheads: Authorization (not to be confused with authentication!)**

**What is it?**

- **Authentication** answers the question "Who are you?".
- **Authorization** answers the question "What are you allowed to do?".

For example, a regular user can view planets, but only a user with the "administrator" role can delete them.

**How to implement it?**

- **In Laravel:** **Policies** or **Gates** are used.

  1.  Create a policy: `php artisan make:policy PlanetPolicy --model=Planet`
  2.  Describe the rules in `app/Policies/PlanetPolicy.php`:
      ```php
      class PlanetPolicy
      {
          // Allow deletion only for users with the 'admin' role
          public function delete(User $user, Planet $planet): bool
          {
              return $user->role === 'admin';
          }
      }
      ```
  3.  Apply the policy in the `PlanetController.php` controller:
      ```php
      public function destroy(Planet $planet)
      {
          // Check if the current user has the right to delete
          $this->authorize('delete', $planet);

          $planet->delete();
          return response()->json(null, 204);
      }
      ```

- **In FastAPI:** Authorization logic is usually written manually inside the endpoints, using user information obtained from the token.

  ```python
  # (assuming the token has a 'roles' field)
  def get_current_active_user(token: str = Depends(oauth2_scheme)):
      # ... decode the token and get the user with roles from the DB
      # user = get_user_from_db(username)
      return user # return the user object

  @router.delete("/planets/{planet_id}")
  def delete_planet(
      planet_id: int,
      current_user: User = Depends(get_current_active_user)
  ):
      if "admin" not in current_user.roles:
          raise HTTPException(
              status_code=status.HTTP_403_FORBIDDEN,
              detail="Insufficient permissions to perform this operation",
          )
      # ... deletion logic ...
  ```

---

#### **5. Cargo Inspection and the Secret Safe: Validation and Environment Variables**

We have already implemented these two points, but it is important to emphasize their role in security.

- **Never trust incoming data (Validation):**

  - We used `$request->validate()` in Laravel and Pydantic models in FastAPI. This protects us from **SQL injections** (when using Eloquent/SQLAlchemy) and incorrect data that can break the application. **Always validate everything that comes from the outside!**

- **Store secrets in `.env` (Environment Variables):**

  - Database keys, secret keys for JWT (`SECRET_KEY`), third-party service keys â€” all of this should **never** get into the version control system (Git). This is what `.env` files, which are added to `.gitignore`, are for.

---

#### **Reinforcement Quiz**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. To protect against data interception on public networks, you should use:</p>
      <label><input type="radio" name="q1" value="a"> a) Rate Limiting</label>
      <label><input type="radio" name="q1" value="b"> b) HTTPS</label>
      <label><input type="radio" name="q1" value="c"> c) CORS</label>
    </div>
    <div class="question">
      <p>2. Rate Limiting primarily protects against:</p>
      <label><input type="radio" name="q2" value="a"> a) SQL injections</label>
      <label><input type="radio" name="q2" value="b"> b) Brute-force and DoS attacks</label>
      <label><input type="radio" name="q2" value="c"> c) Cross-site scripting (XSS)</label>
    </div>
    <div class="question">
      <p>3. The question "What is this user allowed to do?" is solved by:</p>
      <label><input type="radio" name="q3" value="a"> a) Authentication</label>
      <label><input type="radio" name="q3" value="b"> b) Authorization</label>
      <label><input type="radio" name="q3" value="c"> c) Validation</label>
    </div>
    <div class="question">
      <p>4. Secret API keys and database passwords should be stored:</p>
      <label><input type="radio" name="q4" value="a"> a) Directly in the code for convenience</label>
      <label><input type="radio" name="q4" value="b"> b) In a public repository on GitHub</label>
      <label><input type="radio" name="q4" value="c"> c) In a `.env` file that is excluded from Git</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'b', q4: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> Correct answer: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**ðŸš€ Course Completion**
**Congratulations, Commander! You have successfully completed all missions.**

You have gone from a beginner who had only heard about APIs to an engineer capable of independently designing, developing, documenting, securing, and testing a full-fledged web service on two of the most popular technologies in their ecosystems.

You have mastered the universal language of REST, learned Laravel and FastAPI, and built a "Mission Control Center" for them in pure JavaScript.

**This is a huge achievement.** The world of API development is now open to you. Continue to explore, learn, and build amazing things.

**End of communication.** ðŸš€
---
<h2>â˜„ Support the Mission</h2>
<p>Creating this tutorial is a long and complex flight that requires a lot of time and energy. If the material was useful to you, you can help refuel our expedition's fuel tanks.
Each support is another orbit towards new useful materials.</p>
<a href='https://ko-fi.com/K3K41JFJ32' target='blank'><img height='36' style='border:0px;height:36px;' src='https://storage.ko-fi.com/cdn/kofi4.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>