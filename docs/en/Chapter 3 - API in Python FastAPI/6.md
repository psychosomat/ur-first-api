# **Chapter 3.6: Error Handling and Validation**
**Time to learn:** 50 minutes

---

#### **1. Error Handling: The Spaceship's "Emergency Shields"**
Even on the most advanced ship, unforeseen situations can occur:

- **Incorrect command from Mission Control:** The client sent invalid data.
- **Loss of communication with a module:** The resource was not found in the database.
- **Reactor failure:** An internal server error.

**Proper error handling** is a system of "emergency shields." It prevents the ship from falling apart and instead sends a clear signal to Mission Control about what went wrong.

> 💡 **Space Analogy:**

> Instead of just sending a "FAILURE!" signal to Mission Control, a good onboard computer would send a structured report:
> ```json
> {
>   "error_code": "ENGINE_OVERHEAT",
>   "message": "Engine #2 temperature has exceeded normal levels",
>   "suggested_action": "Activate cooling system"
> }
> ```
> This allows engineers on Earth to quickly understand the problem and take action.

---

#### **2. Pydantic Validation: The Built-in "Onboard Computer"**
We have already encountered the magic of Pydantic. If you try to create a ship with an incorrect data type (e.g., `launch_year` as a string), FastAPI will automatically return a `422 Unprocessable Entity` error with a detailed description of which field failed validation and why.

**Example request to `POST /spaceships`:**
```json
{
  "name": "X-Wing",
  "type": "Fighter",
  "launch_year": "a long time ago",  // <-- Invalid type!
  "status": "In service"
}
```

**Automatic response from FastAPI:**
```json
{
  "detail": [
    {
      "loc": [
        "body",
        "launch_year"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ]
}
```
This is incredibly powerful! You don't need to write code to check types—FastAPI and Pydantic do it for you.

---

#### **3. Handling "Resource Not Found": The `HTTPException`**
We have already used this in our CRUD operations. `HTTPException` is the standard FastAPI way to interrupt the execution of a request and immediately return an error response to the client.

**Let's recall the code from `GET /spaceships/{ship_id}`:**
```python
# main.py
from fastapi import FastAPI, HTTPException # Make sure HTTPException is imported

# ...

@app.get("/spaceships/{ship_id}", response_model=Spaceship, tags=["Spacecraft"])
def get_spaceship(ship_id: int):
    ship = db_spaceships.get(ship_id)
    if not ship:
        # If the ship is not found, "raise" a 404 exception
        raise HTTPException(status_code=404, detail=f"Spacecraft with ID {ship_id} not found")
    return ship
```

- `raise HTTPException(...)`: This call stops the function's execution.
- `status_code=404`: Sets the HTTP status of the response.
- `detail`: The message that will be sent to the client in the JSON response body.

---

#### **4. Custom Validators: "Special Checks" Before Launch**
What if we want to add our own, more complex business logic? For example, to prohibit launching ships named "Death Star."

For this, Pydantic has a powerful tool: **validators**.

**Step 1: Add a validator to the `SpaceshipCreate` model**
```python
# main.py
from pydantic import BaseModel, Field, validator

class SpaceshipCreate(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)
    type: str
    launch_year: int = Field(..., gt=1950)
    status: str

    @validator('name')
    def name_must_not_be_forbidden(cls, v):
        """Checks that the ship's name is not on the forbidden list."""
        if 'Death Star' in v:
            raise ValueError('Names like "Death Star" are forbidden by Imperial decree!')
        return v.title() # Also, capitalize the name
```

- `@validator('name')`: A decorator that "binds" this function to the `name` field.
- `cls, v`: The method receives the class itself (`cls`) and the field's value (`v`).
- `raise ValueError(...)`: If the check fails, we raise a standard Python exception. FastAPI will catch it and turn it into a nice `422` error.
- `return v.title()`: If everything is fine, we **must return the value**. We can even modify it on the fly (for example, standardize its format).

**Step 2: Test it**
Restart `uvicorn` and try to create a ship with the forbidden name via `/docs`. You will get a `422` error with your custom message!

---

#### **5. Global Error Handling: The Station's "Emergency Protocol"**
Sometimes you need to catch unexpected errors (like a connection failure to a real database) and return a single, standardized response format.

For this, the `@app.exception_handler` decorator is used.

**Example: Catching all `ValueError` exceptions**
```python
# main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# ...

@app.exception_handler(ValueError)
async def value_error_exception_handler(request: Request, exc: ValueError):
    """
    A global handler for all ValueError exceptions
    to return a standardized JSON.
    """
    return JSONResponse(
        status_code=400,
        content={"message": f"Invalid data provided: {str(exc)}"},
    )
```

- `@app.exception_handler(ValueError)`: Tells FastAPI that this function should handle all `ValueError` exceptions that were not caught earlier.
- `async def ...`: Exception handlers should be asynchronous (`async`).
- `JSONResponse`: Allows you to fully control the response body and status.

Now, when our custom validator is triggered, the response will have the more user-friendly format that we defined.

---

#### **Review Quiz**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. If a client sends data of the wrong type (a string instead of a number), FastAPI will automatically return the status...</p>
      <label><input type="radio" name="q1" value="a"> a) 500 Internal Server Error</label>
      <label><input type="radio" name="q1" value="b"> b) 404 Not Found</label>
      <label><input type="radio" name="q1" value="c"> c) 422 Unprocessable Entity</label>
    </div>
    <div class="question">
      <p>2. `raise HTTPException(status_code=404)` is used to...</p>
      <label><input type="radio" name="q2" value="a"> a) Shut down the entire server</label>
      <label><input type="radio" name="q2" value="b"> b) Interrupt the request and return a 404 error to the client</label>
      <label><input type="radio" name="q2" value="c"> c) Log the error but continue execution</label>
    </div>
    <div class="question">
      <p>3. The `@validator('field_name')` decorator in Pydantic is for:</p>
      <label><input type="radio" name="q3" value="a"> a) Creating custom validation logic for a specific field</label>
      <label><input type="radio" name="q3" value="b"> b) Specifying that a field is required</label>
      <label><input type="radio" name="q3" value="c"> c) Encrypting the field's value</label>
    </div>
    <div class="question">
      <p>4. What must a Pydantic validator function do if the data is valid?</p>
      <label><input type="radio" name="q4" value="a"> a) Return nothing (None)</label>
      <label><input type="radio" name="q4" value="b"> b) It must return the value (possibly modified)</label>
      <label><input type="radio" name="q4" value="c"> c) Return `True`</label>
    </div>
    <div class="question">
      <p>5. `@app.exception_handler()` allows you to...</p>
      <label><input type="radio" name="q5" value="a"> a) Create new types of exceptions</label>
      <label><input type="radio" name="q5" value="b"> b) Catch exceptions globally and define a custom response for them</label>
      <label><input type="radio" name="q5" value="c"> c) Ignore all errors and always return a 200 status</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'a', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> The correct answer is: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**🚀 Chapter Summary:**

You have installed a powerful defense system and emergency protocols on your API ship. It can now:

- 🛡️ Automatically repel "invalid data" attacks using Pydantic.
- 🚨 Properly report missing resources (`404 Not Found`) via `HTTPException`.
- ⚙️ Perform "special checks" with custom validators.
- 🧯 Globally catch unexpected failures and provide standardized responses.

**Your "hyperdrive" is not only fast, but also incredibly reliable!**

> **📌 Checkpoint:**

> - Try to create a ship named "Death Star" and ensure you get a `400` error with your custom message (from the global handler).
> - Try to request `GET /spaceships/999` and ensure you get a `404` error.
> - Try to send a `POST` request with `launch_year` as a string and ensure you get a `422` error.

> **⚠️ If you have errors:**

> - Make sure all necessary modules (`HTTPException`, `validator`, `Request`, `JSONResponse`) are imported.
> - Check that the `@validator` and `@app.exception_handler` decorators are written without typos.

**Congratulations on completing Chapter 3!** You have built, launched, and secured a powerful, well-documented API from scratch using FastAPI. You are ready to take on real space missions
