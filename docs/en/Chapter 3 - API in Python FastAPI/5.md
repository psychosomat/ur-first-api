# **Chapter 3.5: Automatic Swagger Documentation**
**Time to learn:** 30 minutes

---

#### **1. API Documentation: The Space Station's Operating Manual**
Imagine you are a new astronaut arriving at the ISS. How do you know which switch does what and how to operate the robotic arm? You need a **detailed and up-to-date manual**.

**API documentation** is the same kind of manual for developers. It explains:

- Which "docking ports" (endpoints) are available.
- Which "commands" (HTTP methods) can be sent.
- What "cargo" (data) needs to be transmitted.
- What "telemetry" (responses) to expect.

The problem is that writing documentation manually is long, boring, and it almost always becomes outdated.

> ðŸ’¡ **Space Analogy:**

> Manual documentation is like paper blueprints that sit in an archive and are not updated after the station is upgraded.
> **FastAPI's automatic documentation** is an **interactive display in Mission Control** that updates in real-time after every change on the station.

---

#### **2. The Magic of FastAPI: How Does It Work?**
FastAPI does all the "dirty work" for you, based on your own code. It scans:

1.  **Routes:** All decorators like `@app.get`, `@app.post`, etc.
2.  **Parameters:** Path parameters (`ship_id: int`) and query parameters.
3.  **Pydantic Models:** Your "blueprints" (`Spaceship`, `SpaceshipCreate`).
4.  **Docstrings:** The descriptions you write in triple quotes.

Based on this data, FastAPI generates a schema according to the **OpenAPI** standard (formerly known as Swagger) and then displays it through two beautiful interfaces.

---

#### **3. Exploring the "Mission Control Display": Swagger UI**
**Swagger UI** is an interactive interface that allows you not only to read the documentation but also to **test the API directly from the browser**.

**Open `http://127.0.0.1:8000/docs`**

You will see:

- **List of Endpoints:** Grouped by tags (by default, by the resource name) and colored according to the HTTP methods.
- **Descriptions:** The text from your docstrings (`"""..."""`) is displayed as endpoint descriptions.
- **Parameters:** Shows which parameters (like `ship_id`) the endpoint expects, their type, and whether they are required.
- **Request Body:** For `POST` and `PUT`, it shows a JSON schema generated from your Pydantic model (`SpaceshipCreate`).
- **Responses:** Shows possible status codes and response schemas based on the `response_model`.
- **"Try it out" Button:** Allows you to fill in the parameters and send a real request to your server.


---

#### **4. Improving the Documentation: Tags and Descriptions**
Let's make our documentation even more professional.

**Step 1: Add metadata to the `FastAPI` instance**
You can pass general information about your API when creating the `app`.

**Modify the `app = FastAPI()` line in `main.py`:**
```python
# main.py

app = FastAPI(
    title="Fleet Management API",
    description="API for managing a fleet of spacecraft.",
    version="1.0.0",
)
```
Now, a title and description will appear at the top of your documentation.

**Step 2: Group endpoints using tags**
You can add tags to each endpoint to group them logically.

**Add the `tags` parameter to the decorators:**
```python
# GET /spaceships
@app.get("/spaceships", response_model=List[Spaceship], tags=["Spacecraft"])
# ...

# GET /spaceships/{ship_id}
@app.get("/spaceships/{ship_id}", response_model=Spaceship, tags=["Spacecraft"])
# ...

# POST /spaceships
@app.post("/spaceships", response_model=Spaceship, status_code=201, tags=["Spacecraft"])
# ...

# and so on for PUT and DELETE
```
Now all your CRUD operations will be neatly grouped under the "Spacecraft" heading.

---

#### **5. The Alternative View: ReDoc**
FastAPI provides another documentation interface out of the box â€” **ReDoc**. It is less interactive, but often considered more readable and is excellent for static documentation.

**Open `http://127.0.0.1:8000/redoc`**

You will see a three-column layout with navigation, endpoint descriptions, and data schemas. This is a great way to provide documentation to your "clients" (for example, the frontend team).



---

#### **Review Quiz**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>


<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. FastAPI generates documentation based on...</p>
      <label><input type="radio" name="q1" value="a"> a) Separate `.html` files that you have to create manually</label>
      <label><input type="radio" name="q1" value="b"> b) Your Python code: routes, Pydantic models, and docstrings</label>
      <label><input type="radio" name="q1" value="c"> c) Comments that start with `#`</label>
    </div>
    <div class="question">
      <p>2. What standard is the basis for FastAPI's auto-documentation?</p>
      <label><input type="radio" name="q2" value="a"> a) GraphQL</label>
      <label><input type="radio" name="q2" value="b"> b) XML-RPC</label>
      <label><input type="radio" name="q2" value="c"> c) OpenAPI (Swagger)</label>
    </div>
    <div class="question">
      <p>3. At what URL is the interactive Swagger UI documentation available by default?</p>
      <label><input type="radio" name="q3" value="a"> a) `/admin`</label>
      <label><input type="radio" name="q3" value="b"> b) `/docs`</label>
      <label><input type="radio" name="q3" value="c"> c) `/api/help`</label>
    </div>
    <div class="question">
      <p>4. The `tags` parameter in the `@app.get` decorator is used for:</p>
      <label><input type="radio" name="q4" value="a"> a) Adding meta tags to HTML</label>
      <label><input type="radio" name="q4" value="b"> b) Grouping endpoints in the documentation</label>
      <label><input type="radio" name="q4" value="c"> c) Marking an endpoint as deprecated</label>
    </div>
    <div class="question">
      <p>5. ReDoc is...</p>
      <label><input type="radio" name="q5" value="a"> a) A tool for editing code in the browser</label>
      <label><input type="radio" name="q5" value="b"> b) An alternative, more static interface for API documentation</label>
      <label><input type="radio" name="q5" value="c"> c) A system for detecting "red" (non-working) code</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Check</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Results:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> The correct answer is: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">No answer.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Your score: ${score} out of ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**ðŸš€ Chapter Summary:**

You have seen one of FastAPI's most powerful "superpowers"â€”creating documentation without any effort.

- ðŸ“– Your API now has two types of up-to-date documentation: **Swagger UI** and **ReDoc**.
- ðŸ”¬ The documentation is interactive and allows you to test the API on the fly.
- ðŸ·ï¸ You have learned to improve it with metadata and tags.

**The operating manual is ready and always up-to-date!** In the final chapter of this section, we will learn how to handle "cosmic anomalies"â€”errors and invalid data.

> **ðŸ“Œ Checkpoint:**

> - Make sure that the title, description, and tagged endpoints are displayed at `http://127.0.0.1:8000/docs`.
> - Check that your `Spaceship` model is visible in the "Schemas" section.
> - Open `http://127.0.0.1:8000/redoc` and appreciate the alternative view.

> **âš ï¸ If changes are not displayed:**

> - Make sure you have saved the `main.py` file.
> - Check that the `uvicorn` server is running with the `--reload` flag and has restarted successfully.