# **Cap√≠tulo 3.6: Tratamento de Erros e Valida√ß√£o**
**Tempo de estudo:** 50 minutos

---

#### **1. Tratamento de Erros: "Escudos de Emerg√™ncia" da Nave Espacial**
Mesmo na nave mais perfeita, situa√ß√µes imprevistas podem ocorrer:

- **Comando incorreto do Centro de Controle da Miss√£o (CCM):** O cliente enviou dados incorretos.
- **Perda de comunica√ß√£o com o m√≥dulo:** Recurso n√£o encontrado no banco de dados.
- **Falha no reator:** Erro interno do servidor.

**O tratamento adequado de erros** √© um sistema de "escudos de emerg√™ncia". Ele impede que a nave se desintegre e, em vez disso, envia um sinal claro ao CCM sobre o que deu errado.

> üí° **Analogia espacial:**

> Em vez de simplesmente transmitir um sinal de "AVARIA!" ao CCM, um bom computador de bordo enviar√° um relat√≥rio estruturado:
> ```json
> {
>   "error_code": "ENGINE_OVERHEAT",
>   "message": "A temperatura do motor N¬∫2 excedeu o normal",
>   "suggested_action": "Ligar o sistema de refrigera√ß√£o"
> }
> ```
> Isso permite que os engenheiros na Terra entendam rapidamente o problema e tomem medidas.

---

#### **2. Valida√ß√£o Pydantic: O "Computador de Bordo" Integrado**
J√° encontramos a magia do Pydantic. Se voc√™ tentar criar uma nave com um tipo de dado inv√°lido (por exemplo, `launch_year` como uma string), o FastAPI retornar√° automaticamente um erro `422 Unprocessable Entity` com uma descri√ß√£o detalhada de qual campo e por que a valida√ß√£o falhou.

**Exemplo de requisi√ß√£o para `POST /spaceships`:**
```json
{
  "name": "X-Wing",
  "type": "Ca√ßa",
  "launch_year": "h√° muito tempo",  // <-- Tipo inv√°lido!
  "status": "Em opera√ß√£o"
}
```

**Resposta autom√°tica do FastAPI:**
```json
{
  "detail": [
    {
      "loc": [
        "body",
        "launch_year"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ]
}
```
Isso √© incrivelmente poderoso! Voc√™ n√£o precisa escrever c√≥digo para verificar tipos ‚Äî FastAPI e Pydantic fazem isso por voc√™.

---

#### **3. Tratamento de "Recurso n√£o Encontrado": Exce√ß√£o `HTTPException`**
J√° usamos isso em opera√ß√µes CRUD. `HTTPException` √© a maneira padr√£o do FastAPI de interromper a execu√ß√£o de uma requisi√ß√£o e retornar imediatamente uma resposta de erro ao cliente.

**Vamos relembrar o c√≥digo de `GET /spaceships/{ship_id}`:**
```python
# main.py
from fastapi import FastAPI, HTTPException # Certifique-se de que HTTPException esteja importado

# ...

@app.get("/spaceships/{ship_id}", response_model=Spaceship, tags=["Naves Espaciais"])
def get_spaceship(ship_id: int):
    ship = db_spaceships.get(ship_id)
    if not ship:
        # Se a nave n√£o for encontrada, "lan√ßamos" a exce√ß√£o 404
        raise HTTPException(status_code=404, detail=f"Nave espacial com ID {ship_id} n√£o encontrada")
    return ship
```

- `raise HTTPException(...)`: Esta chamada interrompe a execu√ß√£o da fun√ß√£o.
- `status_code=404`: Define o status HTTP da resposta.
- `detail`: Mensagem que ser√° enviada ao cliente no corpo da resposta JSON.

---

#### **4. Validadores Personalizados: "Verifica√ß√µes Especiais" antes do Lan√ßamento**
E se quisermos adicionar nossa pr√≥pria l√≥gica de neg√≥cio, mais complexa? Por exemplo, proibir o lan√ßamento de naves com o nome "Estrela da Morte".

Para isso, o Pydantic oferece uma ferramenta poderosa ‚Äî **validadores**.

**Passo 1: Adicionar o validador ao modelo `SpaceshipCreate`**
```python
# main.py
from pydantic import BaseModel, Field, validator

class SpaceshipCreate(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)
    type: str
    launch_year: int = Field(..., gt=1950)
    status: str

    @validator('name')
    def name_must_not_be_forbidden(cls, v):
        """Verifica se o nome da nave n√£o est√° na lista de proibidos."""
        if 'Death Star' in v:
            raise ValueError('Nomes como "Estrela da Morte" s√£o proibidos por decreto Imperial!')
        return v.title() # De quebra, convertemos o nome para mai√∫sculas
```

- `@validator('name')`: Decorador que "vincula" esta fun√ß√£o ao campo `name`.
- `cls, v`: O m√©todo recebe a pr√≥pria classe (`cls`) e o valor do campo (`v`).
- `raise ValueError(...)`: Se a verifica√ß√£o falhar, levantamos uma exce√ß√£o Python padr√£o. O FastAPI a interceptar√° e a transformar√° em um belo erro `422`.
- `return v.title()`: Se tudo estiver bem, **devemos obrigatoriamente retornar o valor**. Podemos at√© modific√°-lo em tempo real (por exemplo, padroniz√°-lo).

**Passo 2: Testar**
Reinicie o `uvicorn` e tente criar uma nave com um nome proibido via `/docs`. Voc√™ receber√° um erro `422` com sua mensagem personalizada!

---

#### **5. Tratamento Global de Erros: "Protocolo de Emerg√™ncia" da Esta√ß√£o**
√Äs vezes, √© necess√°rio interceptar erros inesperados (por exemplo, falha na conex√£o com um banco de dados real) e retornar um formato de resposta unificado e padronizado.

Para isso, o decorador `@app.exception_handler` √© utilizado.

**Exemplo: Intercepta√ß√£o de todos os erros `ValueError`**
```python
# main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# ...

@app.exception_handler(ValueError)
async def value_error_exception_handler(request: Request, exc: ValueError):
    """
    Manipulador global para todos os erros ValueError,
    para retornar JSON padronizado.
    """
    return JSONResponse(
        status_code=400,
        content={"message": f"Erro nos dados: {str(exc)}"},
    )
```

- `@app.exception_handler(ValueError)`: Informa ao FastAPI que esta fun√ß√£o deve lidar com todos os `ValueError` que n√£o foram interceptados anteriormente.
- `async def ...`: Manipuladores de exce√ß√£o devem ser ass√≠ncronos (`async`).
- `JSONResponse`: Permite controle total sobre o corpo e o status da resposta.

Agora, quando nosso validador personalizado for acionado, a resposta ter√° um formato mais amig√°vel que definimos.

---

#### **Quiz para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Se o cliente enviar dados de tipo incorreto (string em vez de n√∫mero), o FastAPI retornar√° automaticamente o status...</p>
      <label><input type="radio" name="q1" value="a"> a) 500 Internal Server Error</label>
      <label><input type="radio" name="q1" value="b"> b) 404 Not Found</label>
      <label><input type="radio" name="q1" value="c"> c) 422 Unprocessable Entity</label>
    </div>
    <div class="question">
      <p>2. `raise HTTPException(status_code=404)` √© usado para...</p>
      <label><input type="radio" name="q2" value="a"> a) Encerrar o servidor inteiro</label>
      <label><input type="radio" name="q2" value="b"> b) Interromper a execu√ß√£o da requisi√ß√£o e retornar um erro 404 ao cliente</label>
      <label><input type="radio" name="q2" value="c"> c) Registrar o erro, mas continuar a execu√ß√£o</label>
    </div>
    <div class="question">
      <p>3. O decorador `@validator('field_name')` no Pydantic √© necess√°rio para:</p>
      <label><input type="radio" name="q3" value="a"> a) Criar l√≥gica de valida√ß√£o personalizada para um campo espec√≠fico</label>
      <label><input type="radio" name="q3" value="b"> b) Indicar que o campo √© obrigat√≥rio</label>
      <label><input type="radio" name="q3" value="c"> c) Criptografar o valor do campo</label>
    </div>
    <div class="question">
      <p>4. O que a fun√ß√£o validadora no Pydantic deve fazer se os dados estiverem corretos?</p>
      <label><input type="radio" name="q4" value="a"> a) N√£o retornar nada (None)</label>
      <label><input type="radio" name="q4" value="b"> b) Obrigatoriamente retornar o valor (possivelmente modificado)</label>
      <label><input type="radio" name="q4" value="c"> c) Retornar `True`</label>
    </div>
    <div class="question">
      <p>5. `@app.exception_handler()` permite...</p>
      <label><input type="radio" name="q5" value="a"> a) Criar novos tipos de exce√ß√µes</label>
      <label><input type="radio" name="q5" value="b"> b) Interceptar exce√ß√µes globalmente e definir uma resposta personalizada para elas</label>
      <label><input type="radio" name="q5" value="c"> c) Ignorar todos os erros e sempre retornar o status 200</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'a', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ instalou em sua nave API um poderoso sistema de prote√ß√£o e protocolos de emerg√™ncia. Agora ela √© capaz de:

- üõ°Ô∏è Rejeitar automaticamente ataques de "dados inv√°lidos" usando Pydantic.
- üö® Notificar corretamente a aus√™ncia de recursos (`404 Not Found`) atrav√©s de `HTTPException`.
- ‚öôÔ∏è Realizar "verifica√ß√µes especiais" com validadores personalizados.
- üßØ Interceptar globalmente falhas inesperadas e fornecer respostas padronizadas.

**Seu "hipermotor" n√£o √© apenas r√°pido, mas tamb√©m incrivelmente confi√°vel!**

> **üìå Verifica√ß√£o:**

> - Tente criar uma nave com o nome "Death Star" e verifique se voc√™ recebe um erro `400` com sua mensagem personalizada.
> - Tente solicitar `GET /spaceships/999` e verifique se voc√™ recebe um erro `404`.
> - Tente enviar uma solicita√ß√£o `POST` com `launch_year` como uma string e verifique se voc√™ recebe um erro `422`.

> **‚ö†Ô∏è Se houver erros:**

> - Certifique-se de que todos os m√≥dulos necess√°rios (`HTTPException`, `validator`, `Request`, `JSONResponse`) foram importados.
> - Verifique se os decoradores `@validator` e `@app.exception_handler` foram escritos sem erros de digita√ß√£o.

**Parab√©ns por completar o Cap√≠tulo 3!** Voc√™ construiu e lan√ßou do zero uma API poderosa, documentada e segura com FastAPI. Voc√™ est√° pronto para realizar miss√µes espaciais reais
