# **Cap√≠tulo 3.3: Modelos de Dados com Pydantic**
**Tempo de estudo:** 50 minutos

---

#### **1. Pydantic: A "Planta Digital" da nave espacial**
Imagine que voc√™ est√° construindo uma nave espacial. Voc√™ n√£o pode simplesmente soldar peda√ßos de metal aleatoriamente. Voc√™ precisa de uma **planta detalhada** que defina:

- Nome da nave (tipo: `string`, comprimento m√°x.: 50 caracteres)
- Ano de lan√ßamento (tipo: `n√∫mero inteiro`)
- Presen√ßa de hipermotor (tipo: `sim/n√£o`)

**Pydantic** √© uma biblioteca que permite criar essas "plantas digitais" para seus dados em Python. No FastAPI, ela desempenha tr√™s fun√ß√µes chave:

1.  **Declara√ß√£o da estrutura:** Descreve claramente quais campos seus dados cont√™m.
2.  **Valida√ß√£o de dados:** Verifica automaticamente se os dados de entrada correspondem √† planta.
3.  **Documenta√ß√£o:** O FastAPI usa essas plantas para gerar documenta√ß√£o detalhada e interativa.

> üí° **Analogia espacial:**
> Um modelo Pydantic √© a **ficha t√©cnica** de um objeto. Qualquer "carga" (dados) que chega √† esta√ß√£o deve corresponder √† especifica√ß√£o na ficha t√©cnica. Caso contr√°rio, o computador de bordo (Pydantic) a rejeitar√°.

---

#### **2. Criando a primeira planta: Modelo `Spaceship`**
Vamos criar um modelo que descrever√° nossa nave espacial.

**Passo 1: Importamos `BaseModel` do Pydantic**
Pydantic j√° est√° instalado junto com `fastapi[all]`. Precisamos apenas importar a classe base para nossos modelos.

**Adicione no `main.py` no topo, ao lado de outras importa√ß√µes:**
```python
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
```

**Passo 2: Descrevemos o modelo `Spaceship`**
Crie uma classe que herda de `BaseModel`. Dentro da classe, defina os campos e seus tipos, usando as anota√ß√µes de tipo padr√£o do Python.

**Adicione este c√≥digo em `main.py` (pode ser depois das importa√ß√µes):**
```python
class Spaceship(BaseModel):
    """
    Ficha t√©cnica (modelo) da nave espacial.
    """
    name: str
    type: str
    launch_year: int
    status: str
```
√â isso! Voc√™ acabou de criar a "planta". Pydantic agora sabe que qualquer objeto do tipo `Spaceship` deve ter quatro campos com os tipos especificados.

---

#### **3. Aplicando o modelo: Melhoramos nossos endpoints**
Agora, vamos usar nosso novo modelo para tornar a API "mais inteligente".

**A. Modelo como resposta (Response Model)**
Podemos informar ao FastAPI que nosso endpoint deve retornar dados que correspondam ao modelo `Spaceship`. Isso garante que a resposta sempre ter√° a estrutura correta.

**Modifique o endpoint `/spaceships/{ship_id}` da seguinte forma:**
```python
# main.py

# ... c√≥digo com db_spaceships e o modelo Spaceship ...

# Usamos `response_model` para especificar a "planta" da resposta
@app.get("/spaceships/{ship_id}", response_model=Spaceship)
def get_spaceship(ship_id: int):
    """
    Retorna os dados da nave, correspondentes ao modelo Spaceship.
    """
    ship = db_spaceships.get(ship_id)
    return ship
```
- `response_model=Spaceship`: Dizemos ao FastAPI: "A resposta desta fun√ß√£o deve corresponder √† estrutura `Spaceship`. Filtre todos os campos extras e certifique-se de que os tipos est√£o corretos".

**O que isso oferece?**

- **Filtragem de dados:** Se `db_spaceships` tivesse campos extras (por exemplo, `"secret_code"`), eles n√£o seriam inclu√≠dos no JSON final.
- **Garantia de estrutura:** O cliente da API pode ter certeza de que sempre receber√° uma resposta no formato esperado.
- **Documenta√ß√£o:** Em `/docs` agora ser√° exibido um exemplo exato da resposta (Example Value).

**B. Modelos para cole√ß√µes**
E quanto ao endpoint `/spaceships`, que retorna uma *lista* de naves? Para isso, precisamos usar `list` do m√≥dulo `typing`.

**Modifique as importa√ß√µes e o endpoint `/spaceships`:**
```python
# main.py no topo
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List  # <-- Importamos List

# ... c√≥digo ...

# Indicamos que a resposta √© uma lista (List) de objetos do tipo Spaceship
@app.get("/spaceships", response_model=List[Spaceship])
def get_spaceships():
    """
    Retorna uma lista de naves. Cada item da lista
    √© verificado de acordo com o modelo Spaceship.
    """
    # Pydantic n√£o pode trabalhar com um dicion√°rio cujas chaves s√£o IDs.
    # Convertemos nosso dicion√°rio em uma lista simples.
    return list(db_spaceships.values())
```

- `response_model=List[Spaceship]`: Indicamos que a resposta ser√° uma lista, onde cada elemento √© um objeto que corresponde ao modelo `Spaceship`.
- `return list(db_spaceships.values())`: Uma mudan√ßa importante! Pydantic espera um objeto iter√°vel (uma lista), e n√£o um dicion√°rio onde as chaves s√£o IDs. Convertemos os valores do nosso "simulador de BD" em uma lista.

---

#### **4. Verificando a API aprimorada**
Certifique-se de que o servidor `uvicorn` esteja em execu√ß√£o com `--reload`.

1.  **Verifique `http://127.0.0.1:8000/spaceships`:** Agora a resposta √© um **array** JSON, e n√£o um objeto. Esta √© uma estrutura mais correta e padr√£o para cole√ß√µes.
    ```json
    [
      { "name": "Voyager-1", "type": "Sonda", ... },
      { "name": "Hubble Space Telescope", ... }
    ]
    ```
2.  **Verifique `http://127.0.0.1:8000/spaceships/1`:** A resposta n√£o mudou, mas agora est√° garantida para corresponder ao modelo.
3.  **D√™ uma olhada em `/docs`:** Na se√ß√£o "Schemas" na parte inferior da p√°gina, seu modelo `Spaceship` apareceu. E nos exemplos de resposta para os endpoints, agora √© exibido um esquema de dados bonito e estruturado.

---

#### **5. Valida√ß√£o avan√ßada: O "computador de bordo" em a√ß√£o**
Pydantic pode fazer muito mais do que apenas verificar tipos.

**Vamos adicionar valida√ß√£o ao nosso modelo `Spaceship`:**
```python
from pydantic import BaseModel, Field

class Spaceship(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, description="Nome da nave")
    type: str
    launch_year: int = Field(..., gt=1950, description="O ano de lan√ßamento deve ser depois de 1950")
    status: str
```

- `Field(...)`: Usado para adicionar regras de valida√ß√£o adicionais.
- `...` (Ellipsis): Significa que o campo √© obrigat√≥rio.
- `min_length`, `max_length`: Restri√ß√µes para strings.
- `gt`: "Greater Than" (maior que).

Embora ainda n√£o estejamos criando novas naves (isso ser√° na pr√≥xima se√ß√£o), essas regras j√° ser√£o refletidas na documenta√ß√£o e entrar√£o em vigor quando implementarmos as solicita√ß√µes `POST`.

---

#### **Quiz para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Pydantic no FastAPI √© usado para...</p>
      <label><input type="radio" name="q1" value="a"> a) Enviar mensagens de e-mail</label>
      <label><input type="radio" name="q1" value="b"> b) Declara√ß√£o, valida√ß√£o e documenta√ß√£o de modelos de dados</label>
      <label><input type="radio" name="q1" value="c"> c) Conex√£o direta com bancos de dados</label>
    </div>
    <div class="question">
      <p>2. Para criar um modelo de dados, voc√™ precisa herdar a classe de...</p>
      <label><input type="radio" name="q2" value="a"> a) `FastAPI`</label>
      <label><input type="radio" name="q2" value="b"> b) `pydantic.Field`</label>
      <label><input type="radio" name="q2" value="c"> c) `pydantic.BaseModel`</label>
    </div>
    <div class="question">
      <p>3. O par√¢metro `response_model` no decorador `@app.get` √© necess√°rio para...</p>
      <label><input type="radio" name="q3" value="a"> a) Definir o modelo para a requisi√ß√£o de entrada</label>
      <label><input type="radio" name="q3" value="b"> b) Indicar a qual estrutura a resposta da API deve corresponder</label>
      <label><input type="radio" name="q3" value="c"> c) Acelerar a resposta do servidor</label>
    </div>
    <div class="question">
      <p>4. Como indicar que um endpoint retorna uma *lista* de objetos do tipo `Item`?</p>
      <label><input type="radio" name="q4" value="a"> a) `response_model=Item[]`</label>
      <label><input type="radio" name="q4" value="b"> b) `response_model=List[Item]` (importando `List` de `typing`)</label>
      <label><input type="radio" name="q4" value="c"> c) `response_model=(Item)`</label>
    </div>
    <div class="question">
      <p>5. `Field(..., gt=0)` em um modelo Pydantic significa que o campo...</p>
      <label><input type="radio" name="q5" value="a"> a) √â opcional e deve ser igual a 0</label>
      <label><input type="radio" name="q5" value="b"> b) √â obrigat√≥rio e deve ser maior que 0</label>
      <label><input type="radio" name="q5" value="c"> c) √â opcional e tem o tipo `float`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ projetou os "projetos digitais" para os dados da sua API. Agora ela n√£o apenas funciona, mas funciona de forma **previs√≠vel e confi√°vel**.

- üìù Modelo `Spaceship` criado usando Pydantic.
- üõ°Ô∏è A API agora valida e filtra os dados de sa√≠da usando `response_model`.
- üìä A documenta√ß√£o tornou-se muito mais informativa, mostrando esquemas de dados precisos.

**Os projetos est√£o prontos e aprovados!** No pr√≥ximo cap√≠tulo, passaremos da leitura de dados para a cria√ß√£o ‚Äî implementaremos opera√ß√µes CRUD completas para a nossa frota.

> **üìå Verifica√ß√£o:**

> - Certifique-se de que o esquema do modelo `Spaceship` apareceu em `/docs`.
> - Verifique se o endpoint `/spaceships` agora retorna um array JSON (`[...]`), e n√£o um objeto (`{...}`).
> - Certifique-se de que n√£o h√° erros de sintaxe no c√≥digo ap√≥s adicionar os modelos.

> **‚ö†Ô∏è Se houver erros:**

> - `NameError: name 'BaseModel' is not defined`: Verifique se voc√™ importou `BaseModel` de `pydantic`.
> - `NameError: name 'List' is not defined`: Verifique se voc√™ importou `List` de `typing`.
> - A resposta para `/spaceships` est√° vazia (`[]`): Certifique-se de que voc√™ alterou `return db_spaceships` para `return list(db_spaceships.values())`.
