# **Cap√≠tulo 4.5: Async/await vs Promise**
**Tempo de estudo:** 30 minutos

---

#### **1. Assincronicidade: Duas maneiras de gerenciar a "comunica√ß√£o espacial"**
Imagine que o Centro de Controle da Miss√£o (CCM) envie um comando para Marte. A resposta s√≥ chegar√° em alguns minutos. Como organizar o trabalho durante esse tempo?

**Maneira 1: "Protocolo de Retorno de Chamada" (Promise com `.then()`)**
Voc√™ envia um comando e d√° uma instru√ß√£o: "**QUANDO** a resposta chegar, **ENT√ÉO** execute esta fun√ß√£o". Isso √© parecido com uma cadeia de eventos.

**Maneira 2: "Modo de Espera" (Async/await)**
Voc√™ diz: "Eu **VOU ESPERAR** a resposta para este comando, mas n√£o vou bloquear outros consoles de controle". √â como se voc√™ pausasse a execu√ß√£o *desta tarefa espec√≠fica*, permitindo que o resto do CCM continue trabalhando.

Ambas as maneiras resolvem a mesma tarefa ‚Äî gerenciar opera√ß√µes ass√≠ncronas. `async/await` √© simplesmente uma sintaxe mais moderna e leg√≠vel que funciona "em cima" das promises.

> üí° **Analogia espacial:**

> - **Promise com `.then()`**: √â como escrever num post-it: "Quando o rover de Marte enviar a foto, encaminh√°-la para o departamento de an√°lise".
> - **Async/await**: √â como dizer ao assistente: "Espere pela foto do rover de Marte, enquanto isso vou fazer os c√°lculos para o lan√ßamento de um novo foguete".

---

#### **2. Promise com `.then()`: Cadeia de comandos cl√°ssica**
Esta √© a maneira fundamental de trabalhar com assincronicidade em JavaScript, que usamos no Cap√≠tulo 4.1.

**Vamos relembrar nosso primeiro c√≥digo:**
```javascript
function getIssPositionWithPromises() {
    console.log('Enviando solicita√ß√£o via protocolo "Promise"...');

    fetch('http://api.open-notify.org/iss-now.json')
        .then(response => {
            // Etapa 1: Resposta recebida
            if (!response.ok) {
                throw new Error(`Erro HTTP: ${response.status}`);
            }
            return response.json(); // Retornamos uma nova promise
        })
        .then(data => {
            // Etapa 2: Dados analisados
            console.log('Dados via protocolo "Promise" recebidos:', data.iss_position);
        })
        .catch(error => {
            // Etapa 3 (Erro): Algo deu errado em qualquer uma das etapas
            console.error('Falha de comunica√ß√£o via protocolo "Promise":', error);
        });

    console.log('...comando enviado, CCM continua trabalhando...');
}
```

**Vantagens:**

- Cadeia expl√≠cita de a√ß√µes.
- Adequado para opera√ß√µes sequenciais simples.

**Desvantagens:**

- **"Inferno de Callbacks" (Callback Hell):** Com um grande n√∫mero de opera√ß√µes ass√≠ncronas aninhadas, o c√≥digo pode se transformar numa "escadaria" de `.then()`, o que dificulta a leitura.
- O tratamento de erros pode ser menos intuitivo.

---

#### **3. Async/await: Estilo s√≠ncrono moderno**
`async/await` √© "a√ß√∫car sint√°tico" sobre promises, que permite escrever c√≥digo ass√≠ncrono como se fosse s√≠ncrono.

**Regras de uso:**

1.  A palavra-chave `await` pode ser usada **apenas dentro de uma fun√ß√£o** marcada como `async`.
2.  `await` √© colocado antes de uma chamada que retorna uma promise (por exemplo, `fetch()` ou `response.json()`).
3.  `await` "pausa" a execu√ß√£o da fun√ß√£o `async` at√© que a promise seja resolvida, e retorna o seu resultado.

**O mesmo c√≥digo, reescrito com `async/await`:**
```javascript
async function getIssPositionWithAsyncAwait() {
    console.log('Enviando solicita√ß√£o via protocolo "Async/await"...');

    try {
        // Etapa 1: Esperando resposta do servidor
        const response = await fetch('http://api.open-notify.org/iss-now.json');

        if (!response.ok) {
            throw new Error(`Erro HTTP: ${response.status}`);
        }

        // Etapa 2: Esperando que o corpo da resposta seja convertido para JSON
        const data = await response.json();

        console.log('Dados via protocolo "Async/await" recebidos:', data.iss_position);
    } catch (error) {
        // Etapa 3 (Erro): Capturamos qualquer erro do bloco try
        console.error('Falha de comunica√ß√£o via protocolo "Async/await":', error);
    }

    console.log('...comando enviado, CCM continua trabalhando...');
}
```

**Vantagens:**

- **Legibilidade:** O c√≥digo parece quase um c√≥digo s√≠ncrono comum, √© f√°cil de ler de cima para baixo.
- **Tratamento de erros:** Usa o bloco `try...catch` padr√£o e familiar.
- **Depura√ß√£o:** Muito mais f√°cil de depurar, pois voc√™ pode colocar pontos de interrup√ß√£o (breakpoints) em cada linha com `await`.

**Desvantagens:**

- F√°cil esquecer `await` ou `async`, o que levar√° a erros.

---

#### **4. Quando usar qual protocolo?**

| Situa√ß√£o | Abordagem recomendada | Porqu√™? |
|---|---|---|
| **Maioria dos casos** | **`async/await`** | O c√≥digo √© mais limpo, mais f√°cil de ler e depurar. Este √© o padr√£o moderno. |
| **Cadeia simples de 1-2 a√ß√µes** | Promise com `.then()` | Totalmente adequado, o c√≥digo permanece compacto. |
| **Execu√ß√£o paralela de v√°rias requisi√ß√µes** | `Promise.all()` | Este m√©todo permite executar v√°rias promises simultaneamente e esperar que todas sejam conclu√≠das. `async/await` combina perfeitamente com ele. |

**Exemplo com `Promise.all()`:**
```javascript
async function getParallelData() {
    try {
        // Executamos ambas as requisi√ß√µes simultaneamente
        const [shipsResponse, launchesResponse] = await Promise.all([
            fetch('https://api.spacexdata.com/v4/rockets'),
            fetch('https://api.spacexdata.com/v4/launches/latest')
        ]);

        if (!shipsResponse.ok || !launchesResponse.ok) {
            throw new Error('Uma das requisi√ß√µes falhou!');
        }

        const rockets = await shipsResponse.json();
        const latestLaunch = await launchesResponse.json();

        console.log(`Total de foguetes na frota: ${rockets.length}`);
        console.log(`√öltimo lan√ßamento: ${latestLaunch.name}`);
    } catch (error) {
        console.error('Erro ao obter dados paralelos:', error);
    }
}
```

---

#### **Quiz para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. `async/await` √©...</p>
      <label><input type="radio" name="q1" value="a"> a) Uma substitui√ß√£o para promises que funciona de forma diferente</label>
      <label><input type="radio" name="q1" value="b"> b) Uma sintaxe mais conveniente para trabalhar com promises</label>
      <label><input type="radio" name="q1" value="c"> c) Uma maneira de tornar o JavaScript s√≠ncrono</label>
    </div>
    <div class="question">
      <p>2. Qual palavra-chave √© obrigat√≥ria para uma fun√ß√£o dentro da qual `await` √© usado?</p>
      <label><input type="radio" name="q2" value="a"> a) `promise`</label>
      <label><input type="radio" name="q2" value="b"> b) `function`</label>
      <label><input type="radio" name="q2" value="c"> c) `async`</label>
    </div>
    <div class="question">
      <p>3. A principal vantagem de `async/await` sobre `.then()`:</p>
      <label><input type="radio" name="q3" value="a"> a) Maior velocidade de execu√ß√£o</label>
      <label><input type="radio" name="q3" value="b"> b) Melhor legibilidade do c√≥digo e tratamento de erros conveniente via `try...catch`</label>
      <label><input type="radio" name="q3" value="c"> c) Funciona em navegadores antigos sem polyfills</label>
    </div>
    <div class="question">
      <p>4. O que acontece se voc√™ esquecer `await` antes de `fetch()` dentro de uma fun√ß√£o `async`?</p>
      <label><input type="radio" name="q4" value="a"> a) O c√≥digo ser√° executado sem erros, mas a vari√°vel conter√° uma promise, n√£o o resultado</label>
      <label><input type="radio" name="q4" value="b"> b) JavaScript ir√° emitir um erro de sintaxe</label>
      <label><input type="radio" name="q4" value="c"> c) A p√°gina "travar√°" esperando a resposta</label>
    </div>
    <div class="question">
      <p>5. `Promise.all()` √© usado para:</p>
      <label><input type="radio" name="q5" value="a"> a) Executar promises estritamente em ordem</label>
      <label><input type="radio" name="q5" value="b"> b) Iniciar v√°rias promises em paralelo e esperar por todas elas</label>
      <label><input type="radio" name="q5" value="c"> c) Escolher a promise mais r√°pida entre v√°rias</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ aprendeu duas sintaxes para gerenciar opera√ß√µes ass√≠ncronas e entendeu por que `async/await` √© prefer√≠vel na maioria dos projetos modernos.

- üîó Voc√™ revisou seus conhecimentos sobre **Promise com `.then()`**.
- üõ†Ô∏è Voc√™ compreendeu profundamente como funciona **`async/await`** e suas vantagens.
- ‚ö° Voc√™ aprendeu sobre `Promise.all` para executar requisi√ß√µes paralelas.

**Protocolos de comunica√ß√£o aprendidos!** No cap√≠tulo final desta se√ß√£o, reuniremos todo o nosso conhecimento e construiremos nosso "Centro de Controle de Voo", criando uma interface completa para todas as opera√ß√µes CRUD.

> **üìå Pr√°tica:**

> - Reescreva todas as fun√ß√µes em seu `app.js` que ainda usam `.then()`, para a sintaxe `async/await`.
> - Tente adicionar mais uma requisi√ß√£o a `Promise.all()` (por exemplo, para `https://api.spacexdata.com/v4/starlink`) e exiba os dados.

> **‚ö†Ô∏è Se houver erros:**

> - `await is only valid in async functions`: Certifique-se de que a fun√ß√£o onde voc√™ usa `await` esteja marcada como `async`.
> - `A vari√°vel cont√©m [object Promise]`: Voc√™ esqueceu de colocar `await` antes da fun√ß√£o que retorna uma promise.
