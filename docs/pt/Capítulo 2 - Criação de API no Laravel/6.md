# **Cap√≠tulo 2.6: Valida√ß√£o de Dados**
**Tempo de estudo:** 50 minutos

---

#### **1. Valida√ß√£o: Um escudo de escala c√≥smica**
**Valida√ß√£o** - √© a verifica√ß√£o de dados de entrada quanto √† conformidade com as regras. Sem ela:

- üöÄ Dados incorretos podem "destruir" sua base
- üåå Atacantes podem injetar c√≥digo malicioso
- ü™ê Usu√°rios receber√£o erros incompreens√≠veis

> üí° **Analogia c√≥smica:**
> Valida√ß√£o = Sistema de prote√ß√£o de uma esta√ß√£o espacial:

> - Verifica a "carga" (dados) antes da acoplagem
> - Rejeita objetos perigosos
> - Filtra o lixo espacial

---

#### **2. Onde validar em uma API Laravel**
Abordagens principais:

1. **No controlador** (r√°pido, mas polui o c√≥digo)
2. **Form Request** (recomendado, arquitetura limpa)

---

#### **3. Valida√ß√£o no controlador**
Usamos o m√©todo `validate()` do objeto Request:
```php
<?php
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ]);

    // ... cria√ß√£o do planeta
}
```

**Regras de valida√ß√£o populares:**

| Regra              | Descri√ß√£o                         | Exemplo                    |
|--------------------|-----------------------------------|----------------------------|
| `required`         | Campo obrigat√≥rio                 | `'name' => 'required'`     |
| `string`           | Valor de string                   | `'description' => 'string'`|
| `integer`          | N√∫mero inteiro                    | `'size_km' => 'integer'`   |
| `min:value`        | Valor/comprimento m√≠nimo          | `'size_km' => 'min:100'`   |
| `max:value`        | Valor/comprimento m√°ximo          | `'name' => 'max:255'`      |
| `unique:table,column`| Unicidade na tabela             | `'name' => 'unique:planets'` |
| `url`              | URL correto                       | `'image_url' => 'url'`     |
| `boolean`          | true/false/1/0                    | `'is_habitable' => 'boolean'` |

---

#### **4. Mensagens de erro personalizadas**
Mudamos os textos de erro padr√£o:
```php
<?php
$validated = $request->validate(
    [
        'name' => 'required|unique:planets',
        'size_km' => 'min:1000'
    ],
    [
        'name.required' => 'O nome do planeta √© obrigat√≥rio!',
        'name.unique' => 'Um planeta com esse nome j√° existe no cat√°logo',
        'size_km.min' => 'O di√¢metro do planeta n√£o pode ser menor que 1000 km'
    ]
);
```

**Exemplo de resposta em caso de erro (automaticamente 422 Unprocessable Entity):**
```json
{
    "message": "The given data was invalid.",
    "errors": {
        "name": ["Um planeta com esse nome j√° existe no cat√°logo"],
        "size_km": ["O di√¢metro do planeta n√£o pode ser menor que 1000 km"]
    }
}
```

---

#### **5. Cria√ß√£o de um Form Request**
Para valida√ß√£o complexa, criamos uma classe separada:

**Passo 1: Gera√ß√£o**
```bash
php artisan make:request StorePlanetRequest
```

**Passo 2: Editamos `app/Http/Requests/StorePlanetRequest.php`**
```php
<?php
public function authorize()
{
    return true; // Para API, geralmente true
}

public function rules()
{
    return [
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ];
}

public function messages()
{
    return [
        'name.unique' => 'Um planeta com esse nome j√° existe!',
        'size_km.min' => 'O di√¢metro n√£o pode ser menor que 100 km'
    ];
}
```

**Passo 3: Usamos no controlador**
```php
<?php
use App\Http\Requests\StorePlanetRequest;

public function store(StorePlanetRequest $request)
{
    // Os dados j√° foram validados!
    $validated = $request->validated();
    $planet = Planet::create($validated);
    return response()->json($planet, 201);
}
```

---

Entendido. A tarefa √© alinhar o cap√≠tulo com o Laravel 10/11/12, removendo todas as men√ß√µes a conceitos e flags obsoletos, em particular `--invokable`, e mantendo apenas o c√≥digo atualizado. Sem tocar em nada desnecess√°rio.

Aceito. Aqui est√° a vers√£o corrigida da Se√ß√£o 6, que reflete com precis√£o a realidade das vers√µes modernas do framework.

---

#### **6. Regras de valida√ß√£o personalizadas**
Vamos criar uma regra para verificar a "sensatez" do nome do planeta. As regras padr√£o do Laravel n√£o podem verificar se um nome √© "proibido", ent√£o vamos escrever nossa pr√≥pria l√≥gica.

**Passo 1: Gera√ß√£o da regra**

O Laravel fornece um comando Artisan para criar um "esqueleto" de classe de regra. Vamos execut√°-lo no terminal:

```bash
php artisan make:rule ValidPlanetName
```

**Passo 2: Editamos `app/Rules/ValidPlanetName.php`**

Abra o arquivo criado. Sua estrutura √© simples e clara. Nossa tarefa √© implementar a l√≥gica dentro do m√©todo `validate`.

```php
<?php

namespace App\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;

class ValidPlanetName implements ValidationRule
{
    /**
     * Executa a regra de valida√ß√£o.
     *
     * @param  \Closure(string): \Illuminate\Translation\PotentiallyTranslatedString  $fail
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        // Nossa "lista negra" de nomes
        $forbidden = ['–ó–µ–º–ª—è 2.0', '–ù–∏–±–∏—Ä—É', '–ü–ª–∞–Ω–µ—Ç–∞ X'];

        // Verificamos se o valor inserido est√° em nossa lista,
        // ignorando o caso das letras.
        if (in_array(strtolower($value), array_map('strtolower', $forbidden))) {
            // Se a valida√ß√£o falhar, chamamos a fun√ß√£o $fail
            // com o texto do erro que o usu√°rio ver√°.
            $fail('Este nome de planeta √© proibido de usar!');
        }
    }
}
```

**Passo 3: Usamos no Form Request**

Agora nossa regra personalizada est√° pronta para uso. Podemos inclu√≠-la em qualquer Form Request, simplesmente criando uma nova inst√¢ncia de nossa classe.

Vamos abrir `app/Http/Requests/StorePlanetRequest.php` e adicionar `new ValidPlanetName` ao array de regras para o campo `name`.

```php
<?php
// app/Http/Requests/StorePlanetRequest.php

namespace App\Http\Requests;

use App\Rules\ValidPlanetName; // <-- N√£o se esque√ßa de importar a classe
use Illuminate\Foundation\Http\FormRequest;

class StorePlanetRequest extends FormRequest
{
    // ... (m√©todo authorize)

    public function rules(): array
    {
        return [
            'name' => [
                'sometimes',
                'string',
                'max:255',
                'unique:planets',
                new ValidPlanetName, // <-- Aqui est√° nossa regra personalizada
            ],
            'description' => 'sometimes|string',
            'size_km' => 'sometimes|integer|min:100|max:500000',
            'solar_system' => 'sometimes|string|max:100',
            'image_url' => 'nullable|url|max:2048',
            'is_habitable' => 'sometimes|boolean'
        ];
    }

    // ... (m√©todo messages)
}
```
Pronto. Agora, ao criar um planeta, o Laravel aplicar√° sequencialmente todas as regras ao campo `name` e, ao chegar a `new ValidPlanetName`, executar√° nossa l√≥gica personalizada.

---

#### **7. Valida√ß√£o para atualiza√ß√£o (Update)**
Particularidades ao atualizar dados:

> Ao atualizar um registro, as regras de valida√ß√£o frequentemente diferem. A principal caracter√≠stica √© a verifica√ß√£o de unicidade, que deve ignorar o registro atualmente sendo atualizado.

**Passo 1: Criamos um Form Request separado para atualiza√ß√£o**
 ```bash
 php artisan make:request UpdatePlanetRequest
 ```
**Passo 2: Editamos `app/Http/Requests/UpdatePlanetRequest.php`**
```php
<?php
use Illuminate\Validation\Rule;

public function authorize(): bool
{
    return true;
}
public function rules(): array
{
	$planet = $this->route('planet'); // Obtemos o modelo da rota

     return [
         'name' => [
             'sometimes', // Verifica, somente se o campo veio na requisi√ß√£o
             'required',
             'string',
             'max:255',
             Rule::unique('planets')->ignore($planetId),
         ],
         'description'  => 'sometimes|required|string',
         'size_km'      => 'sometimes|required|integer|min:100|max:500000',
         // ... outros campos com 'sometimes'
     ];
 }
```
**Passo 3: Usamos no controlador**
```php
<?php
 use App\Http\Requests\UpdatePlanetRequest;

 public function update(UpdatePlanetRequest $request, Planet $planet)
 {
     $validated = $request->validated();
     $planet->update($validated);
     return response()->json($planet);
 }
```

---

#### **8. Testando a valida√ß√£o no Postman**
**Cen√°rio 1: Erro de unicidade do nome**
```json
POST /api/planets
{
    "name": "–ú–∞—Ä—Å",
    "description": "Planeta vermelho, alvo de futuras coloniza√ß√µes",
    "size_km": 6779,
    "solar_system": "Solar System",
    "is_habitable": false
}
```
**Resposta esperada:**
```json
{
    "message": "The given data was invalid.",
    "errors": {
        "name": ["Um planeta com esse nome j√° existe!"]
    }
}
```

**Cen√°rio 2: Di√¢metro incorreto**
```json
{
    "name": "Planeta-Ervilha",
    "size_km": 50 // < min:100
}
```
**Resposta esperada:**
```json
"errors": {
    "size_km": ["O di√¢metro n√£o pode ser menor que 100 km"]
}
```

---

#### **Question√°rio para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {

    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Status HTTP em caso de erros de valida√ß√£o:</p>
      <label><input type="radio" name="q1" value="a"> a) 400 Bad Request</label>
      <label><input type="radio" name="q1" value="b"> b) 422 Unprocessable Entity</label>
      <label><input type="radio" name="q1" value="c"> c) 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. Regra para verifica√ß√£o de unicidade:</p>
      <label><input type="radio" name="q2" value="a"> a) unique:table</label>
      <label><input type="radio" name="q2" value="b"> b) distinct</label>
      <label><input type="radio" name="q2" value="c"> c) only:table</label>
    </div>
    <div class="question">
      <p>3. Onde √© melhor colocar regras de valida√ß√£o complexas?</p>
      <label><input type="radio" name="q3" value="a"> a) No controlador</label>
      <label><input type="radio" name="q3" value="b"> b) No modelo</label>
      <label><input type="radio" name="q3" value="c"> c) No Form Request</label>
    </div>
    <div class="question">
      <p>4. O m√©todo `authorize()` no Form Request deve retornar:</p>
      <label><input type="radio" name="q4" value="a"> a) false</label>
      <label><input type="radio" name="q4" value="b"> b) true</label>
      <label><input type="radio" name="q4" value="c"> c) null</label>
    </div>
    <div class="question">
      <p>5. A regra sometimes significa:</p>
      <label><input type="radio" name="q5" value="a"> a) Campo obrigat√≥rio</label>
      <label><input type="radio" name="q5" value="b"> b) O campo √© verificado apenas se estiver presente</label>
      <label><input type="radio" name="q5" value="c"> c) O campo √© ignorado</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'c', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ estabeleceu um poderoso sistema de defesa para sua API espacial:

- üõ°Ô∏è Regras de valida√ß√£o b√°sicas e customizadas
- üìù Mensagens de erro leg√≠veis
- üß© Form Request para cen√°rios complexos
- ‚öôÔ∏è Regras exclusivas para atualiza√ß√£o de dados

**Seu universo est√° agora sob prote√ß√£o!** Em seguida, aprenderemos a lidar com "acidentes espaciais" - erros de servidor.

> **üìå Verifica√ß√£o:**

> 1. Crie um Form Request para atualizar planetas
> 2. Adicione uma regra de valida√ß√£o customizada para o nome
> 3. Teste os erros via Postman

> **‚ö†Ô∏è Se a valida√ß√£o n√£o funcionar:**

> - Verifique a conex√£o do Form Request no controlador
> - Certifique-se de que `authorize()` retorne true
> - Para unicidade na atualiza√ß√£o, use `Rule::unique`
