# **Capítulo 5.5: Roteamento para Páginas Web**
**Tempo de estudo:** 40 minutos

---

### **1. `routes/web.php` vs `routes/api.php`: Dois Painéis de Controle Diferentes**

É importante reforçar novamente a diferença fundamental:

| Característica          | `routes/web.php` (Painel Web)                               | `routes/api.php` (Painel API)                                 |
| ----------------------- | ----------------------------------------------------------- | ------------------------------------------------------------- |
| **Tarefa Principal**    | Exibição de páginas HTML, processamento de formulários      | Fornecimento de dados em formato JSON para outras aplicações  |
| **Estado (State)**      | **Stateful** (com estado) — usa sessões e cookies           | **Stateless** (sem estado) — cada requisição é independente   |
| **Middleware padrão**   | `web` (inclui sessões, proteção CSRF, criptografia de cookies) | `api` (inclui "throttling" — limitação de frequência de requisições) |
| **Prefixo da URL**      | Nenhum (raiz do seu site)                                   | `/api/` (configurável em `RouteServiceProvider`)              |
| **Autenticação**        | Geralmente via sessões (Login/Senha)                        | Geralmente via tokens (Sanctum, Passport)                     |

Trabalhamos com `routes/web.php` para construir a interface para um ser humano.

---

### **2. Rotas de Recurso para a Web**

Similar a `Route::apiResource`, para a web existe `Route::resource`. Ele cria rotas para o ciclo CRUD completo, incluindo páginas para exibir formulários de criação e edição.

Vamos criar um conjunto completo de rotas para gerenciar nossos planetas através da interface web.

**Passo 1: Criamos a rota em `routes/web.php`**

Comente ou exclua as rotas antigas para `/planets` e substitua-as por uma única linha:

```php
use App\Http\Controllers\Web\PlanetPageController;

// Route::get('/planets', [PlanetPageController::class, 'index']);
// Route::get('/planets/{planet}', [PlanetPageController::class, 'show']);

Route::resource('planets', PlanetPageController::class);
```

**Passo 2: Verificamos o que foi criado**
Execute no terminal o comando `php artisan route:list --except-vendor`:

```
+--------+-----------+------------------------+------------------+-------------------------------------------------+------------+
| Method | URI       | Name                   | Action           | Middleware                                      |
+--------+-----------+------------------------+------------------+-------------------------------------------------+------------+
| GET|HEAD | planets                | planets.index          | ...\PlanetPageController@index                    | web        |
| POST   | planets                | planets.store          | ...\PlanetPageController@store                    | web        |
| GET|HEAD | planets/create         | planets.create         | ...\PlanetPageController@create                   | web        |
| GET|HEAD | planets/{planet}       | planets.show           | ...\PlanetPageController@show                     | web        |
| PUT|PATCH | planets/{planet}       | planets.update         | ...\PlanetPageController@update                   | web        |
| DELETE | planets/{planet}       | planets.destroy        | ...\PlanetPageController@destroy                  | web        |
| GET|HEAD | planets/{planet}/edit  | planets.edit           | ...\PlanetPageController@edit                     | web        |
+--------+-----------+------------------------+------------------+-------------------------------------------------+------------+
```

`Route::resource` criou 7 rotas para nós, incluindo:

-   `planets.create` (GET `/planets/create`): página com formulário de criação.
-   `planets.store` (POST `/planets`): processamento deste formulário.
-   `planets.edit` (GET `/planets/{planet}/edit`): página com formulário de edição.
-   `planets.update` (PUT/PATCH `/planets/{planet}`): processamento do formulário de edição.
-   `planets.destroy` (DELETE `/planets/{planet}`): exclusão do recurso.

---

### **3. Rotas Nomeadas: Convenientes "Coordenadas Cósmicas"**
Observe a coluna `Name`. O Laravel atribuiu automaticamente a cada rota um nome único (por exemplo, `planets.index`). Usar nomes em vez de URLs hardcoded é a **melhor prática**.

**Por quê?** Se você decidir alterar a URL de `/planets` para `/worlds`, não precisará procurar e alterar todos os links em seus templates. Você simplesmente o altera em um único lugar — no arquivo de rotas, e os nomes permanecem os mesmos.

**Exemplo de uso no Blade:**

Antes escrevíamos assim:

```blade
<a href="/planets/{{ $planet->id }}">Узнать больше &rarr;</a>
```

Agora escreveremos assim, usando o helper `route()`:
```blade
<a href="{{ route('planets.show', ['planet' => $planet->id]) }}">Узнать больше &rarr;</a>
```

-   `route('planets.show', ...)` — gera a URL para a rota com o nome `planets.show`.
-   `['planet' => $planet->id]` — passa os parâmetros necessários para a URL. O Laravel irá preencher o ID em `{planet}`. Você pode até passar o modelo completo: `['planet' => $planet]`.

---

### **4. Implementação dos Métodos Faltantes no Controller**
`Route::resource` criou as rotas, mas precisamos criar os métodos correspondentes em `PlanetPageController` nós mesmos.

Abra `app/Http/Controllers/Web/PlanetPageController.php` e os adicionaremos.

```php
<?php
use Illuminate\Http\Request; // <-- Adicionar

class PlanetPageController extends Controller
{
    // index() e show() nós já temos

    /**
     * Mostra o formulário para criar um novo planeta.
     */
    public function create()
    {
        return view('planets.create'); // Apenas retornamos a view com o formulário
    }

    /**
     * Salva um novo planeta no banco de dados.
     */
    public function store(Request $request)
    {
        // Validação dos dados do formulário
        $validated = $request->validate([
            'name' => 'required|string|max:255|unique:planets',
            'solar_system' => 'required|string|max:100',
            // ... outras regras
        ]);

        Planet::create($validated);

        // Redirecionamos o usuário para a página da lista com uma mensagem de sucesso
        return redirect()->route('planets.index')->with('success', 'Planeta criado com sucesso!');
    }

    /**
     * Mostra o formulário para editar um planeta.
     */
    public function edit(Planet $planet)
    {
        return view('planets.edit', ['planet' => $planet]);
    }

    /**
     * Atualiza os dados do planeta no banco de dados.
     */
    public function update(Request $request, Planet $planet)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255|unique:planets,name,' . $planet->id,
            'solar_system' => 'required|string|max:100',
        ]);

        $planet->update($validated);

        return redirect()->route('planets.show', $planet)->with('success', 'Dados do planeta atualizados!');
    }

    /**
     * Exclui um planeta.
     */
    public function destroy(Planet $planet)
    {
        $planet->delete();

        return redirect()->route('planets.index')->with('success', 'Planeta removido.');
    }
}
```

-   `redirect()->route(...)` — redireciona o usuário para outra rota nomeada.
-   `->with('success', '...')` — adiciona uma "mensagem flash" à sessão, que estará disponível na próxima página exatamente uma vez. Podemos exibi-la em nosso template Blade.

---

### **5. Agrupamento de Rotas**
Se você tiver muitas rotas com características comuns (por exemplo, todas elas são para o painel de administração e devem ter o prefixo `/admin` e um middleware especial), elas podem ser agrupadas.

```php
<?php
Route::middleware(['auth', 'admin'])->prefix('admin')->name('admin.')->group(function () {
    // Todas as rotas dentro deste grupo terão:
    // 1. Middleware 'auth' e 'admin'
    // 2. Prefixo da URL '/admin' (por exemplo, /admin/planets)
    // 3. Prefixo do nome 'admin.' (por exemplo, admin.planets.index)

    Route::resource('planets', PlanetPageController::class);
    // Route::get('/dashboard', ...)->name('dashboard'); // -> admin.dashboard
});
```

---

### **Quiz para Fixação**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Qual comando em `routes/web.php` criará um conjunto completo de rotas CRUD para a interface web?</p>
      <label><input type="radio" name="q1" value="a"> a) Route::crud('planets', Controller::class)</label>
      <label><input type="radio" name="q1" value="b"> b) Route::apiResource('planets', Controller::class)</label>
      <label><input type="radio" name="q1" value="c"> c) Route::resource('planets', Controller::class)</label>
    </div>
    <div class="question">
      <p>2. Qual é a principal vantagem de usar rotas nomeadas?</p>
      <label><input type="radio" name="q2" value="a"> a) Elas funcionam mais rápido do que URLs diretas</label>
      <label><input type="radio" name="q2" value="b"> b) Permitem mudar facilmente a URL no arquivo de rotas, sem quebrar os links nos templates</label>
      <label><input type="radio" name="q2" value="c"> c) Elas são automaticamente protegidas por CSRF</label>
    </div>
    <div class="question">
      <p>3. Qual rota será gerada para o método `create()` em `Route::resource('articles', ...)`?</p>
      <label><input type="radio" name="q3" value="a"> a) GET `/articles/new`</label>
      <label><input type="radio" name="q3" value="b"> b) GET `/articles/create`</label>
      <label><input type="radio" name="q3" value="c"> c) POST `/articles/create`</label>
    </div>
    <div class="question">
      <p>4. O que o código `redirect()->route('home')->with('status', 'OK')` faz?</p>
      <label><input type="radio" name="q4" value="a"> a) Retorna JSON com 'status' => 'OK' para a URL `/home`</label>
      <label><input type="radio" name="q4" value="b"> b) Redireciona para a rota nomeada `home` e adiciona uma mensagem 'status' flash à sessão</label>
      <label><input type="radio" name="q4" value="c"> c) Exibe a view `home.blade.php` com a variável `$status`</label>
    </div>
    <div class="question">
      <p>5. Para que `Route::prefix('dashboard')` é usado?</p>
      <label><input type="radio" name="q5" value="a"> a) Para adicionar um prefixo a todas as URLs dentro do grupo</label>
      <label><input type="radio" name="q5" value="b"> b) Para adicionar um prefixo a todos os nomes de rotas dentro do grupo</label>
      <label><input type="radio" name="q5" value="c"> c) Para aplicar o middleware `dashboard`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

**🚀 Resumo do Capítulo:**

Você dominou uma abordagem estruturada e profissional para a organização de rotas web no Laravel. Agora você é capaz de:

-   Distinguir as rotas `web` e `api` e seus propósitos.
-   Usar `Route::resource` para gerar rapidamente rotas CRUD padrão.
-   Aplicar rotas nomeadas para criar um código flexível e de fácil manutenção.
-   Criar operações CRUD completas no controlador com validação e redirecionamentos.
-   Agrupar rotas para aplicar regras comuns.

**O sistema de navegação da sua "nave" agora é tolerante a falhas e está pronto para expansão.** No capítulo final desta seção, combinaremos todo o conhecimento adquirido e exibiremos os dados dos planetas, obtidos via Fetch, em nossa página Blade.