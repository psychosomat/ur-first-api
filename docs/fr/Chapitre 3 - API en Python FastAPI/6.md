# **Chapitre 3.6 : Gestion des erreurs et validation**
**Temps d'√©tude :** 50 minutes

---

#### **1. Gestion des erreurs : les "boucliers d'urgence" du vaisseau spatial**
M√™me sur le vaisseau le plus sophistiqu√©, des situations impr√©vues peuvent survenir :

- **Commande incorrecte du Centre de contr√¥le de mission :** Le client a envoy√© des donn√©es incorrectes.
- **Perte de connexion avec le module :** La ressource n'a pas √©t√© trouv√©e dans la base de donn√©es.
- **D√©faillance du r√©acteur :** Erreur interne du serveur.

**Une bonne gestion des erreurs** est un syst√®me de "boucliers d'urgence". Elle emp√™che le vaisseau de se d√©sint√©grer et envoie plut√¥t un signal clair au Centre de contr√¥le de mission indiquant ce qui n'a pas fonctionn√©.

> üí° **Analogie spatiale :**

> Au lieu de simplement transmettre le signal "URGENCE !" au Centre de contr√¥le de mission, un bon ordinateur de bord enverra un rapport structur√© :
> ```json
> {
>   "error_code": "ENGINE_OVERHEAT",
>   "message": "La temp√©rature du moteur n¬∞2 a d√©pass√© la norme",
>   "suggested_action": "D√©marrer le syst√®me de refroidissement"
> }
> ```
> Cela permet aux ing√©nieurs sur Terre de comprendre rapidement le probl√®me et de prendre des mesures.

---

#### **2. Validation Pydantic : l'"ordinateur de bord" int√©gr√©**
Nous avons d√©j√† rencontr√© la magie de Pydantic. Si vous tentez de cr√©er un vaisseau avec un type de donn√©es incorrect (par exemple, `launch_year` sous forme de cha√Æne de caract√®res), FastAPI retournera automatiquement une erreur `422 Unprocessable Entity` avec une description d√©taill√©e du champ et de la raison pour laquelle la validation a √©chou√©.

**Exemple de requ√™te vers `POST /spaceships` :**
```json
{
  "name": "X-Wing",
  "type": "Chasseur",
  "launch_year": "il y a longtemps",  // <-- Type incorrect !
  "status": "En service"
}
```

**R√©ponse automatique de FastAPI :**
```json
{
  "detail": [
    {
      "loc": [
        "body",
        "launch_year"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ]
}
```
C'est incroyablement puissant ! Vous n'avez pas besoin d'√©crire de code pour la v√©rification des types ‚Äî FastAPI et Pydantic le font pour vous.

---

#### **3. Gestion "Ressource non trouv√©e" : l'exception `HTTPException`**
Nous l'avons d√©j√† utilis√© dans les op√©rations CRUD. `HTTPException` est le moyen standard pour FastAPI d'interrompre l'ex√©cution de la requ√™te et de renvoyer imm√©diatement une r√©ponse d'erreur au client.

**Rappelons le code de `GET /spaceships/{ship_id}` :**
```python
# main.py
from fastapi import FastAPI, HTTPException # Assurez-vous que HTTPException est import√©

# ...

@app.get("/spaceships/{ship_id}", response_model=Spaceship, tags=["Vaisseaux spatiaux"])
def get_spaceship(ship_id: int):
    ship = db_spaceships.get(ship_id)
    if not ship:
        # Si le vaisseau n'est pas trouv√©, nous "levons" une exception 404
        raise HTTPException(status_code=404, detail=f"Vaisseau spatial avec l'ID {ship_id} non trouv√©")
    return ship
```

- `raise HTTPException(...)` : Cet appel arr√™te l'ex√©cution de la fonction.
- `status_code=404` : D√©finit le statut HTTP de la r√©ponse.
- `detail` : Le message qui sera envoy√© au client dans le corps de la r√©ponse JSON.

---

#### **4. Validateurs personnalis√©s : "V√©rifications sp√©ciales" avant le lancement**
Et si nous voulions ajouter notre propre logique m√©tier, plus complexe ? Par exemple, interdire de lancer des vaisseaux nomm√©s "√âtoile de la Mort".

Pour cela, Pydantic dispose d'un outil puissant : les **validateurs**.

**√âtape 1 : Ajout d'un validateur au mod√®le `SpaceshipCreate`**
```python
# main.py
from pydantic import BaseModel, Field, validator

class SpaceshipCreate(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)
    type: str
    launch_year: int = Field(..., gt=1950)
    status: str

    @validator('name')
    def name_must_not_be_forbidden(cls, v):
        """V√©rifie que le nom du vaisseau n'est pas dans la liste des noms interdits."""
        if 'Death Star' in v:
            raise ValueError('Les noms comme "√âtoile de la Mort" sont interdits par d√©cret Imp√©rial !')
        return v.title() # Met le nom en majuscule par la m√™me occasion
```

- `@validator('name')` : Un d√©corateur qui "lie" cette fonction au champ `name`.
- `cls, v` : La m√©thode re√ßoit la classe elle-m√™me (`cls`) et la valeur du champ (`v`).
- `raise ValueError(...)` : Si la validation √©choue, nous levons une exception Python standard. FastAPI l'interceptera et la transformera en une belle erreur `422`.
- `return v.title()` : Si tout est bon, nous **devons imp√©rativement retourner la valeur**. Nous pouvons m√™me la modifier √† la vol√©e (par exemple, la mettre sous une forme standardis√©e).

**√âtape 2 : Test**
Red√©marrez `uvicorn` et essayez de cr√©er un vaisseau avec un nom interdit via `/docs`. Vous obtiendrez une erreur `422` avec votre message personnalis√© !

---

#### **5. Gestion globale des erreurs : le "protocole d'urgence" de la station**
Parfois, il est n√©cessaire d'intercepter des erreurs inattendues (par exemple, une panne de connexion √† une base de donn√©es r√©elle) et de renvoyer un format de r√©ponse unique et standardis√©.

Pour cela, le d√©corateur `@app.exception_handler` est utilis√©.

**Exemple : Interception de toutes les erreurs `ValueError`**
```python
# main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# ...

@app.exception_handler(ValueError)
async def value_error_exception_handler(request: Request, exc: ValueError):
    """
    Gestionnaire global pour toutes les erreurs ValueError,
    afin de renvoyer un JSON standardis√©.
    """
    return JSONResponse(
        status_code=400,
        content={"message": f"Erreur dans les donn√©es : {str(exc)}"},
    )
```

- `@app.exception_handler(ValueError)` : Indique √† FastAPI que cette fonction doit g√©rer toutes les `ValueError` qui n'ont pas √©t√© intercept√©es pr√©c√©demment.
- `async def ...` : Les gestionnaires d'exceptions doivent √™tre asynchrones (`async`).
- `JSONResponse` : Permet de contr√¥ler enti√®rement le corps et le statut de la r√©ponse.

Maintenant, lorsque notre validateur personnalis√© se d√©clenchera, la r√©ponse aura le format plus convivial que nous avons d√©fini.

---

#### **Quiz pour consolider les connaissances**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Si le client envoie des donn√©es d'un type incorrect (une cha√Æne de caract√®res au lieu d'un nombre), FastAPI retournera automatiquement le statut...</p>
      <label><input type="radio" name="q1" value="a"> a) 500 Internal Server Error</label>
      <label><input type="radio" name="q1" value="b"> b) 404 Not Found</label>
      <label><input type="radio" name="q1" value="c"> c) 422 Unprocessable Entity</label>
    </div>
    <div class="question">
      <p>2. `raise HTTPException(status_code=404)` est utilis√© pour...</p>
      <label><input type="radio" name="q2" value="a"> a) Arr√™ter l'ensemble du serveur</label>
      <label><input type="radio" name="q2" value="b"> b) Interrompre l'ex√©cution de la requ√™te et renvoyer une erreur 404 au client</label>
      <label><input type="radio" name="q2" value="c"> c) Enregistrer l'erreur dans le journal, mais poursuivre l'ex√©cution</label>
    </div>
    <div class="question">
      <p>3. Le d√©corateur `@validator('field_name')` dans Pydantic est n√©cessaire pour :</p>
      <label><input type="radio" name="q3" value="a"> a) Cr√©er une logique de validation personnalis√©e pour un champ sp√©cifique</label>
      <label><input type="radio" name="q3" value="b"> b) Indiquer qu'un champ est obligatoire</label>
      <label><input type="radio" name="q3" value="c"> c) Chiffrer la valeur d'un champ</label>
    </div>
    <div class="question">
      <p>4. Que doit faire une fonction de validation dans Pydantic si les donn√©es sont correctes ?</p>
      <label><input type="radio" name="q4" value="a"> a) Ne rien retourner (None)</label>
      <label><input type="radio" name="q4" value="b"> b) Retourner imp√©rativement la valeur (√©ventuellement modifi√©e)</label>
      <label><input type="radio" name="q4" value="c"> c) Retourner `True`</label>
    </div>
    <div class="question">
      <p>5. `@app.exception_handler()` permet de...</p>
      <label><input type="radio" name="q5" value="a"> a) Cr√©er de nouveaux types d'exceptions</label>
      <label><input type="radio" name="q5" value="b"> b) Intercepter les exceptions globalement et d√©finir une r√©ponse personnalis√©e pour celles-ci</label>
      <label><input type="radio" name="q5" value="c"> c) Ignorer toutes les erreurs et toujours retourner le statut 200</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'a', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> R√©ponse correcte : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ R√©sum√© du chapitre :**

Vous avez install√© sur votre vaisseau API un puissant syst√®me de d√©fense et des protocoles d'urgence. Il est d√©sormais capable de :

- üõ°Ô∏è Repousser automatiquement les attaques de "donn√©es incorrectes" √† l'aide de Pydantic.
- üö® Signaler intelligemment l'absence de ressources (`404 Not Found`) via `HTTPException`.
- ‚öôÔ∏è Effectuer des "v√©rifications sp√©ciales" √† l'aide de validateurs personnalis√©s.
- üßØ Intercepter globalement les pannes impr√©vues et fournir des r√©ponses standardis√©es.

**Votre "hyperpropulsion" est non seulement rapide, mais aussi incroyablement fiable !**

> **üìå V√©rification :**

> - Essayez de cr√©er un vaisseau nomm√© "√âtoile de la Mort" et assurez-vous de recevoir une erreur `400` avec votre message personnalis√©.
> - Essayez de requ√™ter `GET /spaceships/999` et assurez-vous de recevoir une erreur `404`.
> - Essayez d'envoyer une requ√™te `POST` avec `launch_year` sous forme de cha√Æne de caract√®res et assurez-vous de recevoir une erreur `422`.

> **‚ö†Ô∏è En cas d'erreurs :**

> - Assurez-vous que tous les modules n√©cessaires (`HTTPException`, `validator`, `Request`, `JSONResponse`) sont import√©s.
> - V√©rifiez que les d√©corateurs `@validator` et `@app.exception_handler` sont √©crits sans fautes de frappe.

**F√©licitations pour la fin du Chapitre 3 !** Vous avez construit et lanc√© un API puissant, document√© et s√©curis√© avec FastAPI, √† partir de z√©ro. Vous √™tes pr√™t pour de v√©ritables missions spatiales.