# **Chapitre 3.3 : Mod√®les de donn√©es avec Pydantic**
**Temps d'√©tude :** 50 minutes

---

#### **1. Pydantic : Le "plan num√©rique" d'un vaisseau spatial**
Imaginez que vous construisez un vaisseau spatial. Vous ne pouvez pas simplement souder des morceaux de m√©tal au hasard. Vous avez besoin d'un **plan d√©taill√©** qui d√©finit :

- Nom du vaisseau (type : `cha√Æne`, longueur max : 50 caract√®res)
- Ann√©e de lancement (type : `entier`)
- Pr√©sence d'un hyperpropulseur (type : `oui/non`)

**Pydantic** est une biblioth√®que qui permet de cr√©er de tels "plans num√©riques" pour vos donn√©es en Python. Dans FastAPI, elle remplit trois fonctions cl√©s :

1.  **D√©claration de structure :** D√©crit clairement de quels champs vos donn√©es sont compos√©es.
2.  **Validation des donn√©es :** V√©rifie automatiquement si les donn√©es entrantes correspondent au plan.
3.  **Documentation :** FastAPI utilise ces plans pour g√©n√©rer une documentation d√©taill√©e et interactive.

> üí° **Analogie spatiale :**
> Un mod√®le Pydantic est le **passeport technique** d'un objet. Toute "cargaison" (donn√©es) arrivant √† la station doit correspondre aux sp√©cifications du passeport. Sinon, l'ordinateur de bord (Pydantic) la rejettera.

---

#### **2. Cr√©ation du premier plan : Le mod√®le `Spaceship`**
Cr√©ons un mod√®le qui d√©crira notre engin spatial.

**√âtape 1 : Importation de `BaseModel` depuis Pydantic**
Pydantic est d√©j√† install√© avec `fastapi[all]`. Nous avons seulement besoin d'importer la classe de base pour nos mod√®les.

**Ajoutez ceci en haut de `main.py`, √† c√¥t√© des autres importations :**
```python
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
```

**√âtape 2 : Description du mod√®le `Spaceship`**
Cr√©ez une classe qui h√©rite de `BaseModel`. √Ä l'int√©rieur de la classe, d√©finissez les champs et leurs types en utilisant les annotations de type Python standard.

**Ajoutez ce code dans `main.py` (peut √™tre apr√®s les importations) :**
```python
class Spaceship(BaseModel):
    """
    Passeport technique (mod√®le) d'un vaisseau spatial.
    """
    name: str
    type: str
    launch_year: int
    status: str
```
Et voil√† ! Vous venez de cr√©er un "plan". Pydantic sait maintenant que tout objet de type `Spaceship` doit avoir quatre champs avec les types sp√©cifi√©s.

---

#### **3. Application du mod√®le : Am√©lioration de nos points d'API**
Utilisons maintenant notre nouveau mod√®le pour rendre l'API "plus intelligente".

**A. Mod√®le en tant que r√©ponse (Response Model)**
Nous pouvons indiquer √† FastAPI que notre point d'API doit retourner des donn√©es correspondant au mod√®le `Spaceship`. Cela garantit que la r√©ponse aura toujours la bonne structure.

**Modifiez le point d'API `/spaceships/{ship_id}` comme suit :**
```python
# main.py

# ... code avec db_spaceships et le mod√®le Spaceship ...

# Utilisation de `response_model` pour sp√©cifier le "plan" de la r√©ponse
@app.get("/spaceships/{ship_id}", response_model=Spaceship)
def get_spaceship(ship_id: int):
    """
    Retourne les donn√©es du vaisseau, correspondant au mod√®le Spaceship.
    """
    ship = db_spaceships.get(ship_id)
    return ship
```
- `response_model=Spaceship` : Nous disons √† FastAPI : "La r√©ponse de cette fonction doit correspondre √† la structure `Spaceship`. Filtre tous les champs superflus et assure-toi que les types sont corrects."

**Qu'est-ce que cela apporte ?**

-   **Filtrage des donn√©es :** Si `db_spaceships` contenait des champs superflus (par exemple, `"secret_code"`), ils ne seraient pas inclus dans le JSON final.
-   **Garantie de structure :** Le client de l'API peut √™tre s√ªr de toujours recevoir une r√©ponse dans le format attendu.
-   **Documentation :** Dans `/docs`, un exemple pr√©cis de r√©ponse (Example Value) sera d√©sormais affich√©.

**B. Mod√®les pour les collections**
Et qu'en est-il du point d'API `/spaceships` qui retourne une *liste* de vaisseaux ? Pour cela, il faut utiliser `list` du module `typing`.

**Modifiez les importations et le point d'API `/spaceships` :**
```python
# main.py en haut
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List  # <-- Importation de List

# ... code ...

# Indique que la r√©ponse est une liste (List) d'objets de type Spaceship
@app.get("/spaceships", response_model=List[Spaceship])
def get_spaceships():
    """
    Retourne une liste de vaisseaux. Chaque √©l√©ment de la liste
    est valid√© selon le mod√®le Spaceship.
    """
    # Pydantic ne peut pas fonctionner avec un dictionnaire dont les cl√©s sont des ID.
    # Convertissons notre dictionnaire en une simple liste.
    return list(db_spaceships.values())
```

-   `response_model=List[Spaceship]` : Nous indiquons que la r√©ponse sera une liste, o√π chaque √©l√©ment est un objet correspondant au mod√®le `Spaceship`.
-   `return list(db_spaceships.values())` : Changement important ! Pydantic s'attend √† un objet it√©rable (une liste), et non √† un dictionnaire o√π les cl√©s sont des ID. Nous convertissons les valeurs de notre "simulateur de base de donn√©es" en une liste.

---

#### **4. V√©rification de l'API am√©lior√©e**
Assurez-vous que le serveur `uvicorn` est lanc√© avec `--reload`.

1.  **V√©rifiez `http://127.0.0.1:8000/spaceships` :** La r√©ponse est maintenant un **tableau** JSON, et non un objet. C'est une structure plus correcte et standard pour les collections.
    ```json
    [
      { "name": "Voyager-1", "type": "Sonde", ... },
      { "name": "Hubble Space Telescope", ... }
    ]
    ```
2.  **V√©rifiez `http://127.0.0.1:8000/spaceships/1` :** La r√©ponse n'a pas chang√©, mais elle est maintenant garantie de correspondre au mod√®le.
3.  **Consultez `/docs` :** Dans la section "Schemas" en bas de page, votre mod√®le `Spaceship` est apparu. Et dans les exemples de r√©ponses pour les points d'API, un beau sch√©ma de donn√©es structur√© est maintenant affich√©.

---

#### **5. Validation avanc√©e : L'"ordinateur de bord" en action**
Pydantic peut faire bien plus que simplement v√©rifier les types.

**Ajoutons la validation √† notre mod√®le `Spaceship` :**
```python
from pydantic import BaseModel, Field

class Spaceship(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, description="Nom du vaisseau")
    type: str
    launch_year: int = Field(..., gt=1950, description="L'ann√©e de lancement doit √™tre apr√®s 1950")
    status: str
```

-   `Field(...)` : Utilis√© pour ajouter des r√®gles de validation suppl√©mentaires.
-   `...` (Ellipsis) : Indique que le champ est obligatoire.
-   `min_length`, `max_length` : Contraintes pour la cha√Æne de caract√®res.
-   `gt` : "Greater Than" (plus grand que).

Bien que nous ne cr√©ions pas encore de nouveaux vaisseaux (ce sera dans le prochain chapitre), ces r√®gles seront d√©j√† refl√©t√©es dans la documentation et s'appliqueront lorsque nous impl√©menterons les requ√™tes `POST`.

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Pydantic dans FastAPI est utilis√© pour...</p>
      <label><input type="radio" name="q1" value="a"> a) L'envoi de messages √©lectroniques</label>
      <label><input type="radio" name="q1" value="b"> b) La d√©claration, la validation et la documentation des mod√®les de donn√©es</label>
      <label><input type="radio" name="q1" value="c"> c) La connexion directe aux bases de donn√©es</label>
    </div>
    <div class="question">
      <p>2. Pour cr√©er un mod√®le de donn√©es, il faut h√©riter d'une classe de...</p>
      <label><input type="radio" name="q2" value="a"> a) `FastAPI`</label>
      <label><input type="radio" name="q2" value="b"> b) `pydantic.Field`</label>
      <label><input type="radio" name="q2" value="c"> c) `pydantic.BaseModel`</label>
    </div>
    <div class="question">
      <p>3. Le param√®tre `response_model` dans le d√©corateur `@app.get` est n√©cessaire pour...</p>
      <label><input type="radio" name="q3" value="a"> a) D√©finir le mod√®le pour la requ√™te entrante</label>
      <label><input type="radio" name="q3" value="b"> b) Indiquer √† quelle structure la r√©ponse de l'API doit correspondre</label>
      <label><input type="radio" name="q3" value="c"> c) Acc√©l√©rer la r√©ponse du serveur</label>
    </div>
    <div class="question">
      <p>4. Comment indiquer qu'un point d'API retourne une *liste* d'objets de type `Item` ?</p>
      <label><input type="radio" name="q4" value="a"> a) `response_model=Item[]`</label>
      <label><input type="radio" name="q4" value="b"> b) `response_model=List[Item]` (en important `List` de `typing`)</label>
      <label><input type="radio" name="q4" value="c"> c) `response_model=(Item)`</label>
    </div>
    <div class="question">
      <p>5. `Field(..., gt=0)` dans un mod√®le Pydantic signifie que le champ...</p>
      <label><input type="radio" name="q5" value="a"> a) Est facultatif et doit √™tre √©gal √† 0</label>
      <label><input type="radio" name="q5" value="b"> b) Est obligatoire et doit √™tre sup√©rieur √† 0</label>
      <label><input type="radio" name="q5" value="c"> c) Est optionnel et a le type `float`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ R√©sum√© du chapitre :**

Vous avez con√ßu des "plans num√©riques" pour les donn√©es de votre API. Maintenant, elle ne fonctionne pas seulement, elle fonctionne de mani√®re **pr√©visible et fiable**.

-   üìù Le mod√®le `Spaceship` a √©t√© cr√©√© √† l'aide de Pydantic.
-   üõ°Ô∏è L'API valide et filtre d√©sormais les donn√©es sortantes √† l'aide de `response_model`.
-   üìä La documentation est devenue beaucoup plus informative, affichant des sch√©mas de donn√©es pr√©cis.

**Les plans sont pr√™ts et approuv√©s !** Dans le prochain chapitre, nous passerons de la lecture des donn√©es √† leur cr√©ation ‚Äî nous impl√©menterons des op√©rations CRUD compl√®tes pour notre flotte.

> **üìå V√©rification :**

> -   Assurez-vous que le sch√©ma du mod√®le `Spaceship` est apparu dans `/docs`.
> -   V√©rifiez que le point d'API `/spaceships` retourne d√©sormais un tableau JSON (`[...]`), et non un objet (`{...}`).
> -   Assurez-vous qu'il n'y a pas d'erreurs de syntaxe dans le code apr√®s l'ajout des mod√®les.

> **‚ö†Ô∏è En cas d'erreurs :**
> - `NameError: name 'BaseModel' is not defined`: V√©rifiez que vous avez import√© `BaseModel` depuis `pydantic`.
> - `NameError: name 'List' is not defined`: V√©rifiez que vous avez import√© `List` depuis `typing`.
> - La r√©ponse √† `/spaceships` est vide (`[]`) : Assurez-vous d'avoir chang√© `return db_spaceships` en `return list(db_spaceships.values())`.