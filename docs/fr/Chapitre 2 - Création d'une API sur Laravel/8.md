# **Chapitre 2.8 : Test d'API**
**Temps d'√©tude :** 1 heure

---

#### **1. Pourquoi les tests sont-ils n√©cessaires ?**

Imaginez que vous ayez construit un vaisseau spatial. Avant de l'envoyer sur Mars, vous effectuez des milliers de v√©rifications sur Terre. Les tests en programmation, c'est la m√™me chose. Ils :

-   **Donnent confiance :** Vous pouvez modifier le code, et si les tests passent, cela signifie que vous n'avez rien cass√©.
-   **√âconomisent du temps :** Au lieu de "cliquer" manuellement sur tout dans Postman apr√®s chaque modification, vous ex√©cutez une seule commande qui v√©rifie tout pour vous en quelques secondes.
-   **Servent de documentation :** De bons tests montrent comment votre API est cens√©e fonctionner.

---

#### **2. Configuration du "Laboratoire" de test**

Laravel rend la configuration des tests incroyablement simple. Par d√©faut, il utilise une configuration distincte afin de ne pas affecter votre base de donn√©es principale.

**Base de donn√©es pour les tests :**
Par d√©faut, Laravel utilise une base de donn√©es **en m√©moire** (`:memory:`). C'est la m√©thode la plus rapide car il n'est pas n√©cessaire d'√©crire quoi que ce soit sur le disque. La base de donn√©es est cr√©√©e avant les tests et d√©truite apr√®s. Nous n'avons m√™me rien √† configurer pour cela !

**Cr√©ation du fichier de test :**
Cr√©ons un fichier sp√©cial pour les tests li√©s aux plan√®tes.

```bash
php artisan make:test PlanetApiTest
```

Cette commande cr√©era le fichier `tests/Feature/PlanetApiTest.php`. Le mot `Feature` signifie que nous allons tester la fonctionnalit√© dans son ensemble (par exemple, "l'utilisateur peut-il cr√©er une plan√®te ?"), et non une petite classe individuelle.

---

#### **3. Anatomie d'un test : Pr√©paration, Action, V√©rification**

Ouvrez `tests/Feature/PlanetApiTest.php`. Nous y √©crirons notre premier test. Un bon test se compose toujours de trois parties (Arrange, Act, Assert).

```php
<?php

namespace Tests\Feature;

use App\Models\Planet; // N'oubliez pas d'importer le mod√®le
use Illuminate\Foundation\Testing\RefreshDatabase; // L'outil le plus important !
use Tests\TestCase;

class PlanetApiTest extends TestCase
{
    // Ce trait "nettoie" et recr√©e "magiquement"
    // notre base de donn√©es de test avant chaque test.
    // Cela garantit que les tests ne s'affectent pas mutuellement.
    use RefreshDatabase;

    /**
     * Test : le point de terminaison pour obtenir la liste des plan√®tes fonctionne correctement.
     * Les noms des tests doivent √™tre significatifs !
     */
    public function test_can_get_all_planets(): void
    {
        // 1. PR√âPARATION (Arrange)
        // Nous cr√©ons 3 plan√®tes factices dans notre base de donn√©es de test
        // √† l'aide de la fabrique que nous avons cr√©√©e pr√©c√©demment.
        Planet::factory()->count(3)->create();

        // 2. ACTION (Act)
        // Nous simulons une v√©ritable requ√™te GET vers notre API.
        $response = $this->getJson('/api/planets');

        // 3. V√âRIFICATION (Assert)
        // Nous v√©rifions que tout s'est pass√© comme pr√©vu.
        $response->assertStatus(200); // Nous nous attendons √† ce que le serveur r√©ponde "200 OK"
        $response->assertJsonCount(3); // Nous nous attendons √† exactement 3 plan√®tes dans la r√©ponse
    }
}
```
**Points cl√©s :**

-   `use RefreshDatabase` : Ce trait est votre meilleur ami. Il garantit que chaque test commence avec une "table rase", avec une base de donn√©es vide.
-   `Planet::factory()` : Les fabriques sont id√©ales pour cr√©er des donn√©es de test.
-   `$this->getJson()` : C'est une m√©thode Laravel sp√©ciale pour envoyer des requ√™tes API √† l'int√©rieur des tests.
-   `assert...()` : Ce sont des "assertions" ou des "v√©rifications". Si au moins l'une d'entre elles √©choue, le test √©chouera.

---

#### **4. Test des op√©rations principales (CRUD)**

√âcrivons des tests pour la cr√©ation, la mise √† jour et la suppression de plan√®tes.

**A. Test de cr√©ation de plan√®te (POST)**

```php
<?php
public function test_can_create_a_planet(): void
{
    // 1. Pr√©paration : pr√©paration des donn√©es pour une nouvelle plan√®te
    $planetData = [
        'name' => 'Kepler-186f',
        'description' => 'La premi√®re exoplan√®te de la taille de la Terre dans la zone habitable.',
        'size_km' => 14000,
        'solar_system' => 'Kepler-186'
    ];

    // 2. Action : envoi d'une requ√™te POST avec les donn√©es
    $response = $this->postJson('/api/planets', $planetData);

    // 3. V√©rification
    $response->assertStatus(201); // Nous nous attendons au statut "201 Created"
    $response->assertJsonFragment(['name' => 'Kepler-186f']); // Nous v√©rifions que le nom cr√©√© est pr√©sent dans la r√©ponse

    // La v√©rification la plus importante : les donn√©es ont-elles vraiment √©t√© ajout√©es √† la base de donn√©es ?
    $this->assertDatabaseHas('planets', [
        'name' => 'Kepler-186f'
    ]);
}
```

**B. Test de suppression de plan√®te (DELETE)**
```php
<?php
public function test_can_delete_a_planet(): void
{
    // 1. Pr√©paration : cr√©ation de la plan√®te √† supprimer
    $planet = Planet::factory()->create();

    // 2. Action : envoi d'une requ√™te DELETE
    $response = $this->deleteJson("/api/planets/{$planet->id}");

    // 3. V√©rification
    $response->assertStatus(204); // Nous nous attendons √† "204 No Content" - suppression r√©ussie

    // Nous v√©rifions que l'enregistrement a bien disparu de la base de donn√©es
    $this->assertDatabaseMissing('planets', [
        'id' => $planet->id
    ]);
}
```

---

#### **5. Test des "mauvais" sc√©narios**

Tester les cas r√©ussis est une bonne chose. Mais il est encore plus important de tester les erreurs !

**A. Test d'erreur de validation**
```php
<?php
public function test_creation_fails_with_invalid_data(): void
{
    // 2. Action : envoi de donn√©es sciemment incorrectes
    $response = $this->postJson('/api/planets', ['name' => '']); // Nom vide

    // 3. V√©rification
    $response->assertStatus(422); // Nous nous attendons √† "422 Unprocessable Entity"
    $response->assertJsonValidationErrors('name'); // Nous nous attendons √† ce que l'erreur se trouve sp√©cifiquement dans le champ 'name'
}
```

**B. Test de "non trouv√©" (404)**
```php
<?php
public function test_returns_404_for_non_existent_planet(): void
{
    // 2. Action : demande d'une plan√®te avec un ID inexistant
    $response = $this->getJson('/api/planets/99999');

    // 3. V√©rification
    $response->assertStatus(404); // Nous nous attendons √† "404 Not Found"
}
```

---

#### **6. Ex√©cution des tests**

Maintenant que les tests sont √©crits, les ex√©cuter est tr√®s simple. Ex√©cutez dans le terminal :

```bash
php artisan test
```

Laravel trouvera tous vos tests et les ex√©cutera un par un. Si tout se passe bien, vous verrez une sortie verte. Si un test √©choue, vous verrez une sortie rouge avec une description d√©taill√©e de l'erreur, ce qui vous permettra de la corriger rapidement.

**Pour ex√©cuter un seul fichier sp√©cifique :**
```bash
php artisan test tests/Feature/PlanetApiTest.php
```

---

#### **8. Couverture de code (Code Coverage)**
**√âtape 1 : Installation de Xdebug**

Pour collecter les informations de couverture de code, l'extension PHP [Xdebug](https://xdebug.org/wizard) est requise.
>Envoyez votre `php -i` au wizard et suivez les instructions.

**√âtape 2 : Configuration de `phpunit.xml`**
```xml
<phpunit ... >
    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">./app</directory>
        </include>
    </coverage>
</phpunit>
```

**√âtape 3 : Ex√©cution avec rapport**
```bash
php artisan test --coverage-html=coverage
```
Rapport : Ouvrez `coverage/index.html` dans le navigateur

---

#### **9. Int√©gration avec Postman**
**Automatisation via Newman :**

1. Exportez la collection Postman vers `tests/Postman/SpaceApi.postman_collection.json`
2. Installez Newman :
```bash
npm install -g newman
```
3. Ajoutez le script dans `composer.json` :
```json
"scripts": {
    "test:postman": "newman run tests/Postman/SpaceApi.postman_collection.json"
}
```
4. Ex√©cution :
```bash
composer test:postman
```

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Commande pour cr√©er une classe de test :</p>
      <label><input type="radio" name="q1" value="a"> a) php artisan make:test</label>
      <label><input type="radio" name="q1" value="b"> b) php artisan generate:test</label>
      <label><input type="radio" name="q1" value="c"> c) php artisan test:create</label>
    </div>
    <div class="question">
      <p>2. Le trait RefreshDatabase est utilis√© pour :</p>
      <label><input type="radio" name="q2" value="a"> a) Nettoyer la BD apr√®s les tests</label>
      <label><input type="radio" name="q2" value="b"> b) Remplir la BD avec des donn√©es de test</label>
      <label><input type="radio" name="q2" value="c"> c) Cr√©er la structure de la BD</label>
    </div>
    <div class="question">
      <p>3. M√©thode pour v√©rifier la structure JSON :</p>
      <label><input type="radio" name="q3" value="a"> a) assertJsonFormat()</label>
      <label><input type="radio" name="q3" value="b"> b) assertJsonStructure()</label>
      <label><input type="radio" name="q3" value="c"> c) assertJsonSchema()</label>
    </div>
    <div class="question">
      <p>4. Les fabriques dans Laravel sont n√©cessaires pour :</p>
      <label><input type="radio" name="q4" value="a"> a) G√©n√©rer des donn√©es de test</label>
      <label><input type="radio" name="q4" value="b"> b) Cr√©er des migrations</label>
      <label><input type="radio" name="q4" value="c"> c) G√©rer les erreurs</label>
    </div>
    <div class="question">
      <p>5. Outil pour ex√©cuter des collections Postman depuis la CLI :</p>
      <label><input type="radio" name="q5" value="a"> a) Newman</label>
      <label><input type="radio" name="q5" value="b"> b) Postman CLI</label>
      <label><input type="radio" name="q5" value="c"> c) Artisan</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'a', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**
Vous avez effectu√© un cycle complet de tests de pr√©-lancement ! Votre API peut d√©sormais :

- ‚úÖ Configurer l'environnement de test sans effort suppl√©mentaire
- üõ°Ô∏è √âcrire des tests bas√©s sur le principe "Pr√©paration-Action-V√©rification".
- üìä Tester les sc√©narios r√©ussis (CRUD) ainsi que les erreurs (validation, 404).
- üîÅ Ex√©cuter les tests avec une seule commande et √™tre confiant dans votre code.

**Le vaisseau spatial est pr√™t pour le lancement !** Vous avez termin√© la section sur la cr√©ation d'une API avec Laravel.

> **üìå V√©rification finale :**

> 1. Ex√©cutez `php artisan test`
> 2. Assurez-vous que tous les tests passent (lumi√®re verte !)
> 3. V√©rifiez le rapport de couverture

> **‚ö†Ô∏è Si les tests √©chouent :**

> - V√©rifiez le fonctionnement de l'API via Postman
> - Assurez-vous que la base de donn√©es de test est configur√©e
> - Utilisez `dd($response->content())` pour le d√©bogage

**F√©licitations pour l'ach√®vement du Chapitre 2 !** Vous n'avez pas seulement cr√©√© une API, vous avez construit un "vaisseau spatial" fiable et test√©, pr√™t pour de futures missions.

> **üåå Prochaines √©tapes :**

> 1. Configuration de l'authentification (Sanctum)
> 2. Documentation de l'API avec Swagger
> 3. D√©ploiement sur un serveur (Forge, VPS)
> 4. D√©veloppement du frontend avec Vue/React

**Bon lancement pour votre mission spatiale ! Dans le prochain chapitre, nous aborderons la cr√©ation d'une API √† partir de z√©ro** üöÄ