# **Chapitre 2.6 : Validation des donn√©es**
**Temps d'√©tude :** 50 minutes

---

#### **1. Validation : Un bouclier √† l'√©chelle cosmique**
La **validation** est la v√©rification des donn√©es entrantes par rapport aux r√®gles. Sans elle :

- üöÄ Des donn√©es incorrectes peuvent "d√©truire" votre base de donn√©es
- üåå Des acteurs malveillants peuvent injecter du code nuisible
- ü™ê Les utilisateurs recevront des erreurs incompr√©hensibles

> üí° **Analogie spatiale :**
> Validation = Syst√®me de d√©fense d'une station spatiale :

> - V√©rifie la "cargaison" (donn√©es) avant l'amarrage
> - Rejette les objets dangereux
> - Filtre les d√©bris spatiaux

---

#### **2. O√π valider dans l'API Laravel**
Principales approches :

1. **Dans le contr√¥leur** (rapide, mais alourdit le code)
2. **Form Request** (recommand√©, architecture propre)

---

#### **3. Validation dans le contr√¥leur**
Nous utilisons la m√©thode `validate()` de l'objet Request :
```php
<?php
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ]);

    // ... cr√©ation de la plan√®te
}
```

**R√®gles de validation populaires :**

| R√®gle              | Description                           | Exemple                     |
|----------------------|---------------------------------------|----------------------------|
| `required`           | Champ obligatoire                     | `'name' => 'required'`     |
| `string`             | Valeur de cha√Æne de caract√®res        | `'description' => 'string'`|
| `integer`            | Nombre entier                         | `'size_km' => 'integer'`   |
| `min:value`          | Valeur/longueur minimale              | `'size_km' => 'min:100'`   |
| `max:value`          | Valeur/longueur maximale              | `'name' => 'max:255'`      |
| `unique:table,column`| Unicit√© dans la table                 | `'name' => 'unique:planets'` |
| `url`                | URL valide                            | `'image_url' => 'url'`     |
| `boolean`            | true/false/1/0                        | `'is_habitable' => 'boolean'` |

---

#### **4. Messages d'erreur personnalis√©s**
Nous modifions les textes d'erreur standard :
```php
<?php
$validated = $request->validate(
    [
        'name' => 'required|unique:planets',
        'size_km' => 'min:1000'
    ],
    [
        'name.required' => 'Le nom de la plan√®te est obligatoire !',
        'name.unique' => 'Cette plan√®te existe d√©j√† dans le catalogue',
        'size_km.min' => 'Le diam√®tre de la plan√®te ne peut √™tre inf√©rieur √† 1000 km'
    ]
);
```

**Exemple de r√©ponse en cas d'erreur (automatiquement 422 Unprocessable Entity) :**
```json
{
    "message": "Les donn√©es fournies sont invalides.",
    "errors": {
        "name": ["Cette plan√®te existe d√©j√† dans le catalogue"],
        "size_km": ["Le diam√®tre de la plan√®te ne peut √™tre inf√©rieur √† 1000 km"]
    }
}
```

---

#### **5. Cr√©ation d'un Form Request**
Pour une validation complexe, nous cr√©ons une classe s√©par√©e :

**√âtape 1 : G√©n√©ration**
```bash
php artisan make:request StorePlanetRequest
```

**√âtape 2 : Modification de `app/Http/Requests/StorePlanetRequest.php`**
```php
<?php
public function authorize()
{
    return true; // G√©n√©ralement true pour une API
}

public function rules()
{
    return [
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100|max:500000',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url|max:2048',
        'is_habitable' => 'boolean'
    ];
}

public function messages()
{
    return [
        'name.unique' => 'Une plan√®te avec ce nom existe d√©j√† !',
        'size_km.min' => 'Le diam√®tre ne peut √™tre inf√©rieur √† 100 km'
    ];
}
```

**√âtape 3 : Utilisation dans le contr√¥leur**
```php
<?php
use App\Http\Requests\StorePlanetRequest;

public function store(StorePlanetRequest $request)
{
    // Les donn√©es sont d√©j√† valid√©es !
    $validated = $request->validated();
    $planet = Planet::create($validated);
    return response()->json($planet, 201);
}
```

---

Compris. La t√¢che consiste √† rendre le chapitre enti√®rement conforme √† Laravel 10/11/12, en supprimant toute mention de concepts et de drapeaux obsol√®tes, en particulier `--invokable`, et en ne laissant que le code actuel. Sans toucher √† quoi que ce soit d'inutile.

Accept√©. Voici la version corrig√©e de la section 6, qui refl√®te fid√®lement la r√©alit√© des versions modernes du framework.

---

#### **6. R√®gles de validation personnalis√©es**
Nous allons cr√©er une r√®gle pour v√©rifier la "pertinence" du nom d'une plan√®te. Les r√®gles standard de Laravel ne peuvent pas v√©rifier si un nom est "interdit", nous allons donc √©crire notre propre logique.

**√âtape 1 : G√©n√©ration de la r√®gle**

Laravel fournit une commande Artisan pour cr√©er un "squelette" de classe de r√®gle. Ex√©cutons-la dans le terminal :

```bash
php artisan make:rule ValidPlanetName
```

**√âtape 2 : Modification de `app/Rules/ValidPlanetName.php`**

Ouvrez le fichier cr√©√©. Sa structure est simple et claire. Notre t√¢che est d'impl√©menter la logique √† l'int√©rieur de la m√©thode `validate`.

```php
<?php

namespace App\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;

class ValidPlanetName implements ValidationRule
{
    /**
     * Ex√©cute la r√®gle de validation.
     *
     * @param  \Closure(string): \Illuminate\Translation\PotentiallyTranslatedString  $fail
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        // Notre "liste noire" de noms
        $forbidden = ['–ó–µ–º–ª—è 2.0', '–ù–∏–±–∏—Ä—É', '–ü–ª–∞–Ω–µ—Ç–∞ X'];

        // Nous v√©rifions si la valeur saisie est dans notre liste,
        // en ignorant la casse des lettres.
        if (in_array(strtolower($value), array_map('strtolower', $forbidden))) {
            // Si la validation √©choue, nous appelons la fonction $fail
            // avec le texte d'erreur que l'utilisateur verra.
            $fail('Ce nom de plan√®te est interdit d\'utilisation !');
        }
    }
}
```

**√âtape 3 : Utilisation dans le Form Request**

Maintenant, notre r√®gle personnalis√©e est pr√™te √† √™tre utilis√©e. Nous pouvons l'inclure dans n'importe quel Form Request, en cr√©ant simplement une nouvelle instance de notre classe.

Ouvrons `app/Http/Requests/StorePlanetRequest.php` et ajoutons `new ValidPlanetName` au tableau de r√®gles pour le champ `name`.

```php
<?php
// app/Http/Requests/StorePlanetRequest.php

namespace App\Http\Requests;

use App\Rules\ValidPlanetName; // <-- N'oubliez pas d'importer la classe
use Illuminate\Foundation\Http\FormRequest;

class StorePlanetRequest extends FormRequest
{
    // ... (m√©thode authorize)

    public function rules(): array
    {
        return [
            'name' => [
                'sometimes',
                'string',
                'max:255',
                'unique:planets',
                new ValidPlanetName, // <-- Voici notre r√®gle personnalis√©e
            ],
            'description' => 'sometimes|string',
            'size_km' => 'sometimes|integer|min:100|max:500000',
            'solar_system' => 'sometimes|string|max:100',
            'image_url' => 'nullable|url|max:2048',
            'is_habitable' => 'sometimes|boolean'
        ];
    }

    // ... (m√©thode messages)
}
```
C'est fait. Maintenant, lors de la cr√©ation d'une plan√®te, Laravel appliquera s√©quentiellement toutes les r√®gles au champ `name` et, en arrivant √† `new ValidPlanetName`, ex√©cutera notre logique personnalis√©e.

---

#### **7. Validation pour la mise √† jour (Update)**
Sp√©cificit√©s lors de la mise √† jour des donn√©es :

> Lors de la mise √† jour d'un enregistrement, les r√®gles de validation sont souvent diff√©rentes. La principale particularit√© est la v√©rification de l'unicit√©, qui doit ignorer l'enregistrement actuellement mis √† jour.

**√âtape 1 : Cr√©ation d'un Form Request distinct pour la mise √† jour**
 ```bash
 php artisan make:request UpdatePlanetRequest
 ```
**√âtape 2 : Modification de `app/Http/Requests/UpdatePlanetRequest.php`**
```php
<?php
use Illuminate\Validation\Rule;

public function authorize(): bool
{
    return true;
}
public function rules(): array
{
	$planet = $this->route('planet'); // R√©cup√®re le mod√®le depuis la route

     return [
         'name' => [
             'sometimes', // V√©rifie uniquement si le champ est pr√©sent dans la requ√™te
             'required',
             'string',
             'max:255',
             Rule::unique('planets')->ignore($planetId),
         ],
         'description'  => 'sometimes|required|string',
         'size_km'      => 'sometimes|required|integer|min:100|max:500000',
         // ... les autres champs avec 'sometimes'
     ];
 }
```
**√âtape 3 : Utilisation dans le contr√¥leur**
```php
<?php
 use App\Http\Requests\UpdatePlanetRequest;

 public function update(UpdatePlanetRequest $request, Planet $planet)
 {
     $validated = $request->validated();
     $planet->update($validated);
     return response()->json($planet);
 }
```

---

#### **8. Test de la validation dans Postman**
**Sc√©nario 1 : Erreur d'unicit√© du nom**
```json
POST /api/planets
{
    "name": "Mars",
    "description": "La plan√®te rouge, cible des futures colonisations",
    "size_km": 6779,
    "solar_system": "Solar System",
    "is_habitable": false
}
```
**R√©ponse attendue :**
```json
{
    "message": "Les donn√©es fournies sont invalides.",
    "errors": {
        "name": ["Une plan√®te avec ce nom existe d√©j√† !"]
    }
}
```

**Sc√©nario 2 : Diam√®tre incorrect**
```json
{
    "name": "Plan√®te-Pois",
    "size_km": 50 // < min:100
}
```
**R√©ponse attendue :**
```json
"errors": {
    "size_km": ["Le diam√®tre ne peut √™tre inf√©rieur √† 100 km"]
}
```

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Statut HTTP en cas d'erreurs de validation :</p>
      <label><input type="radio" name="q1" value="a"> a) 400 Bad Request</label>
      <label><input type="radio" name="q1" value="b"> b) 422 Unprocessable Entity</label>
      <label><input type="radio" name="q1" value="c"> c) 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. R√®gle pour v√©rifier l'unicit√© :</p>
      <label><input type="radio" name="q2" value="a"> a) unique:table</label>
      <label><input type="radio" name="q2" value="b"> b) distinct</label>
      <label><input type="radio" name="q2" value="c"> c) only:table</label>
    </div>
    <div class="question">
      <p>3. O√π est-il pr√©f√©rable de placer les r√®gles de validation complexes ?</p>
      <label><input type="radio" name="q3" value="a"> a) Dans le contr√¥leur</label>
      <label><input type="radio" name="q3" value="b"> b) Dans le mod√®le</label>
      <label><input type="radio" name="q3" value="c"> c) Dans Form Request</label>
    </div>
    <div class="question">
      <p>4. La m√©thode `authorize()` dans un Form Request doit retourner :</p>
      <label><input type="radio" name="q4" value="a"> a) false</label>
      <label><input type="radio" name="q4" value="b"> b) true</label>
      <label><input type="radio" name="q4" value="c"> c) null</label>
    </div>
    <div class="question">
      <p>5. La r√®gle sometimes signifie :</p>
      <label><input type="radio" name="q5" value="a"> a) Le champ est obligatoire</label>
      <label><input type="radio" name="q5" value="b"> b) Le champ est v√©rifi√© uniquement s'il est pr√©sent</label>
      <label><input type="radio" name="q5" value="c"> c) Le champ est ignor√©</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>
<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'c', q4: 'b', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> R√©ponse correcte : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez mis en place un syst√®me de protection puissant pour votre API spatiale :

- üõ°Ô∏è R√®gles de validation de base et personnalis√©es
- üìù Messages d'erreur lisibles
- üß© Form Request pour les sc√©narios complexes
- ‚öôÔ∏è R√®gles uniques pour la mise √† jour des donn√©es

**Votre univers est maintenant prot√©g√© !** Ensuite, nous apprendrons √† g√©rer les "accidents spatiaux" - les erreurs de serveur.

> **üìå V√©rification :**

> 1. Cr√©ez une Form Request pour la mise √† jour des plan√®tes
> 2. Ajoutez une r√®gle de validation personnalis√©e pour le nom
> 3. Testez les erreurs via Postman

> **‚ö†Ô∏è Si la validation ne fonctionne pas :**

> - V√©rifiez la connexion de la Form Request dans le contr√¥leur
> - Assurez-vous que `authorize()` renvoie true
> - Pour l'unicit√© lors de la mise √† jour, utilisez `Rule::unique`