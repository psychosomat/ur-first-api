# **Chapitre 2.4 : Contr√¥leur API PlanetController**
**Temps d'√©tude :** 1 heure

---

#### **1. Contr√¥leur : Centre de contr√¥le des objets spatiaux**
Dans l'architecture MVC, le **contr√¥leur** est un interm√©diaire entre les mod√®les et les requ√™tes :

- üì° Re√ßoit les requ√™tes HTTP (GET, POST, PUT, DELETE)
- üîç Extrait les donn√©es de la base via les mod√®les
- üì¶ Forme les r√©ponses JSON pour l'API

> üí° **Analogie spatiale :**
> `PlanetController` = Centre de Contr√¥le des Missions :

> - Re√ßoit les requ√™tes de la Terre (`GET /planets`)
> - Donne des commandes aux "sondes" (mod√®les)
> - Retourne la t√©l√©m√©trie au format JSON

---

#### **2. Cr√©ation d'un contr√¥leur de ressources**
Un contr√¥leur de ressources inclut automatiquement des m√©thodes pour les op√©rations CRUD.

**√âtape 1 : G√©n√©ration du contr√¥leur**
```bash
php artisan make:controller PlanetController --api --model=Planet
```

**Ce qui sera cr√©√© dans `app/Http/Controllers/PlanetController.php` :**
```php
<?php

namespace App\Http\Controllers;

use App\Models\Planet;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule; // N'oubliez pas d'ajouter cette importation

class PlanetController extends Controller
{
    // Afficher la liste des plan√®tes
    public function index(Request $request) {}

    // Cr√©er une nouvelle plan√®te
    public function store(Request $request) {}

    // Afficher une plan√®te sp√©cifique
    public function show(Planet $planet) {}

    // Mettre √† jour une plan√®te
    public function update(Request $request, Planet $planet) {}

    // Supprimer une plan√®te
    public function destroy(Planet $planet) {}
}
```

---

#### **3. Impl√©mentation des m√©thodes d'API**

**A. `index()` - R√©cup√©ration de la liste des plan√®tes**
```php
<?php
public function index(Request $request)
{
    // R√©cup√©rons les plan√®tes avec pagination, 15 par page
    $planets = Planet::paginate($request->get('per_page', 15));
    return response()->json($planets); // Automatiquement 200 OK
}
```

**B. `store()` - Cr√©ation d'une nouvelle plan√®te**
```php
<?php
public function store(Request $request)
{
    $data = $request->validate([
        'name' => 'required|string|max:255|unique:planets',
        'description' => 'required|string',
        'size_km' => 'required|integer|min:100',
        'solar_system' => 'required|string|max:100',
        'image_url' => 'nullable|url',
        'is_habitable' => 'boolean'
    ]);

    $planet = Planet::create($data);
    return response()->json($planet, 201); // 201 Created
}
```

**C. `show()` - Affichage d'une seule plan√®te**
```php
<?php
public function show(Planet $planet)
{
    return response()->json($planet); // Automatique 200 OK
}
```

**D. `update()` - Mise √† jour d'une plan√®te**
```php
<?php
public function update(Request $request, Planet $planet)
{
    $data = $request->validate([
        'name' => [
            'string',
            'max:255',
            Rule::unique('planets')->ignore($planet->id),
        ],
        'description' => 'sometimes|string', // 'sometimes' - valider uniquement si le champ est pr√©sent
        'size_km' => 'sometimes|integer|min:100',
        'solar_system' => 'sometimes|string|max:100',
        'image_url' => 'sometimes|nullable|url',
        'is_habitable' => 'sometimes|boolean'
    ]);

    $planet->update($data);
    return response()->json($planet); // 200 OK
}
```

**E. `destroy()` - Suppression d'une plan√®te**
```php
<?php
public function destroy(Planet $planet)
{
    $planet->delete();
    return response()->json(null, 204); // 204 No Content
}
```

---

#### **4. Liaison de mod√®le de route (Route Model Binding)**
Laravel substitue automatiquement l'objet plan√®te par ID :
```php
// Dans la route : GET /planets/{planet}
// Dans la m√©thode : show(Planet $planet)
```

- Si la plan√®te n'est pas trouv√©e ‚Üí automatiquement 404
- Pas besoin de requ√™tes manuelles `findOrFail()`

---

#### **5. Formatage des r√©ponses**
**Exemple de r√©ponse am√©lior√©e pour `index()` :**
```php
<?php
public function index()
{
    return response()->json([
        'success' => true,
        'data' => Planet::all(),
        'message' => 'Plan√®tes r√©cup√©r√©es avec succ√®s'
    ]);
}
```

**R√©ponse en cas d'erreur 404 (automatique) :**
```json
{
    "message": "No query results for model [App\\Models\\Planet] 123",
    "exception": "Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException"
}
```

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Le drapeau pour cr√©er un contr√¥leur API :</p>
      <label><input type="radio" name="q1" value="a"> a) --api</label>
      <label><input type="radio" name="q1" value="b"> b) --resource</label>
      <label><input type="radio" name="q1" value="c"> c) --model</label>
    </div>
    <div class="question">
      <p>2. Quel statut renvoyer en cas de cr√©ation r√©ussie ?</p>
      <label><input type="radio" name="q2" value="a"> a) 200 OK</label>
      <label><input type="radio" name="q2" value="b"> b) 201 Created</label>
      <label><input type="radio" name="q2" value="c"> c) 204 No Content</label>
    </div>
    <div class="question">
      <p>3. Le Route Model Binding permet de :</p>
      <label><input type="radio" name="q3" value="a"> a) Obtenir automatiquement un objet par ID</label>
      <label><input type="radio" name="q3" value="b"> b) G√©n√©rer des formulaires HTML</label>
      <label><input type="radio" name="q3" value="c"> c) Mettre en cache les requ√™tes</label>
    </div>
    <div class="question">
      <p>4. Lors de la suppression d'une plan√®te, nous renvoyons :</p>
      <label><input type="radio" name="q4" value="a"> a) JSON avec les donn√©es de la plan√®te</label>
      <label><input type="radio" name="q4" value="b"> b) null avec le code 204</label>
      <label><input type="radio" name="q4" value="c"> c) Une cha√Æne vide</label>
    </div>
    <div class="question">
      <p>5. `$request->validate()` est utilis√© pour :</p>
      <label><input type="radio" name="q5" value="a"> a) La validation des donn√©es d'entr√©e</label>
      <label><input type="radio" name="q5" value="b"> b) Le chiffrement des requ√™tes</label>
      <label><input type="radio" name="q5" value="c"> c) La mise en cache des r√©ponses</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'b', q3: 'a', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre r√©sultat : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez cr√©√© le "tableau de bord" du syst√®me plan√©taire ! Votre contr√¥leur est maintenant capable de :

- üåå Afficher la liste des plan√®tes (`index`)
- ü™ê Cr√©er de nouveaux mondes (`store`)
- üî≠ D√©tailler les donn√©es d'une plan√®te (`show`)
- üõ†Ô∏è Mettre √† jour les informations (`update`)
- üí• D√©truire des plan√®tes (`destroy`)

**Il ne reste plus qu'√† d√©finir les routes !** Dans le chapitre suivant, nous connecterons le contr√¥leur aux routes d'API.

> **üìå V√©rification :**

> Assurez-vous que `PlanetController.php` se trouve dans `app/Http/Controllers` avec 5 m√©thodes.

> **‚ö†Ô∏è En cas d'erreurs :**

> - V√©rifiez le nom du mod√®le : `use App\Models\Planet;`
> - V√©rifiez les importations
> - Pour PostgreSQL : assurez-vous que `Planet::all()` renvoie des donn√©es
> - En cas de probl√®mes avec Tinker : ex√©cutez `composer dump-autoload`