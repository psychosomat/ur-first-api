# **Chapitre 4.4 : Gestion des erreurs**
**Temps d'√©tude :** 45 minutes

---

#### **1. Gestion des erreurs : protocoles d'urgence du MCC**
Dans l'espace, tout peut mal tourner : une √©ruption solaire peut interrompre les communications, l'ordinateur de bord du vaisseau peut tomber en panne, et une commande venant de la Terre peut contenir des coordonn√©es incorrectes.

La **gestion des erreurs sur le frontend** est l'√©quivalent des **protocoles d'urgence** de votre MCC. Ils doivent :

- üö® Emp√™cher l'interface enti√®re de "planter" √† cause d'une seule commande d√©fectueuse.
- üì° Informer clairement l'op√©rateur (utilisateur) de ce qui n'a pas fonctionn√©.
- üîß Proposer des actions ult√©rieures possibles.

> üí° **Analogie spatiale :**

> Si un signal `500 Internal Server Error` est re√ßu du vaisseau, l'√©cran du MCC ne doit pas afficher "Erreur JavaScript critique √† la ligne 57". Au lieu de cela, il devrait y avoir : "üö® **D√©faillance √† bord du vaisseau !** Les ing√©nieurs ont d√©j√† √©t√© notifi√©s. Veuillez r√©essayer la commande ult√©rieurement."

---

#### **2. Types d'"anomalies spatiales"**
Sur le frontend, nous rencontrons trois types principaux d'erreurs lors de l'interaction avec une API :

1.  **Erreurs r√©seau :** La connexion au serveur n'a pas √©t√© √©tablie. L'antenne ne fonctionne pas, le c√¢ble est coup√©. `fetch` "tombera" dans le bloc `.catch()`.
2.  **Erreurs client (4xx) :** La commande venant de la Terre √©tait incorrecte. ID invalide, erreur de validation. Le serveur r√©pond, mais avec un statut `4xx`.
3.  **Erreurs serveur (5xx) :** D√©faillance sur le vaisseau lui-m√™me. Probl√®me dans le code de l'API. Le serveur r√©pond, mais avec un statut `500+`.

Nous avons d√©j√† commenc√© √† les g√©rer avec `try...catch` et la v√©rification de `response.ok`. Faisons maintenant cela de mani√®re centralis√©e.

---

#### **3. Fonction de gestion centralis√©e**
R√©p√©ter le m√™me code `try...catch` dans chaque fonction est une mauvaise pratique. Cr√©ons un "wrapper" universel pour nos requ√™tes `fetch`.

**√âtape 1 : Cr√©er `api.js`**
Cr√©ez un nouveau fichier `api.js` √† c√¥t√© de `app.js`. Nous y d√©placerons toute la logique d'interaction avec l'API.
```javascript
// api.js

const API_BASE_URL = 'http://127.0.0.1:8000';

/**
 * Fonction universelle pour ex√©cuter des requ√™tes vers l'API.
 * G√®re les erreurs et retourne du JSON.
 * @param {string} endpoint - Point d'acc√®s de l'API, par exemple, '/spaceships'
 * @param {object} options - Param√®tres pour fetch (method, headers, body)
 */
async function apiRequest(endpoint, options = {}) {
    const url = `${API_BASE_URL}${endpoint}`;

    try {
        const response = await fetch(url, options);

        // Si la r√©ponse n'est pas du tout du JSON, nous levons imm√©diatement une erreur
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            // Exception pour une requ√™te DELETE r√©ussie qui n'a pas de corps
            if (response.status === 204) return null;

            throw new TypeError(`R√©ponse non-JSON re√ßue du serveur : ${response.statusText}`);
        }

        const data = await response.json();

        if (!response.ok) {
            // Si le serveur a renvoy√© du JSON avec une erreur (par exemple, detail de FastAPI)
            const errorMessage = data.detail || `Erreur HTTP ! Statut : ${response.status}`;
            throw new Error(errorMessage);
        }

        return data;

    } catch (error) {
        console.error(`Erreur de requ√™te API vers ${endpoint} :`, error);
        // Nous "relan√ßons" l'erreur pour qu'elle puisse √™tre intercept√©e dans l'UI
        throw error;
    }
}
```

**√âtape 2 : Inclure `api.js` dans `index.html`**
Il est important de l'inclure **AVANT** `app.js`, car `app.js` utilisera ses fonctions.
```html
<!-- index.html -->
<body>
    <!-- ... -->
    <script src="api.js"></script>
    <script src="app.js"></script>
</body>
```

**√âtape 3 : Refactoriser `app.js`**
Nous allons maintenant r√©√©crire nos fonctions en utilisant le nouveau `apiRequest`.
```javascript
// app.js

// const API_BASE_URL = ...; // Cette ligne peut √™tre supprim√©e, elle est maintenant dans api.js

// ...

async function fetchAndDisplayFleet() {
    try {
        fleetList.innerHTML = '<li>Chargement de la t√©l√©m√©trie...</li>';
        const ships = await apiRequest('/spaceships'); // <-- Nous utilisons notre wrapper !

        fleetList.innerHTML = '';
        if (ships.length === 0) {
            fleetList.innerHTML = '<li>Aucun appareil n\'est enregistr√© dans le registre.</li>';
            return;
        }

        ships.forEach(ship => { /* ... le reste du code d'affichage ... */ });
    } catch (error) {
        fleetList.innerHTML = `<li>üî¥ Erreur de chargement de la flotte : ${error.message}</li>`;
    }
}

async function createShip(event) {
    event.preventDefault();
    const shipData = { /* ... collecte des donn√©es du formulaire ... */ };

    try {
        createStatusMessage.textContent = 'Envoi de la commande de lancement...';
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(shipData)
        };
        const newShip = await apiRequest('/spaceships', options); // <-- Nous utilisons notre wrapper !

        createStatusMessage.textContent = `üöÄ Lancement r√©ussi ! L'appareil a l'ID : ${newShip.id}`;
        createShipForm.reset();
        fetchAndDisplayFleet();
    } catch (error) {
        createStatusMessage.textContent = `üî¥ Erreur : ${error.message}`;
    }
}

// R√©√©crivez les autres fonctions (fetchShipById, deleteShip) de la m√™me mani√®re !
```
D√©sormais, toute la logique de gestion des erreurs r√©seau, de v√©rification de `response.ok` et d'analyse du JSON se trouve au m√™me endroit, et le code dans `app.js` est devenu beaucoup plus propre et lisible.

---

#### **4. Affichage des erreurs √† l'utilisateur**
Une bonne interface ne doit pas se contenter d'√©crire l'erreur dans la console, mais la montrer √† l'utilisateur sous une forme compr√©hensible.

**Exemple : Am√©lioration de `createShip`**
Notre code le fait d√©j√† : `createStatusMessage.textContent = ...`. Mais on peut faire encore mieux en cr√©ant une fonction universelle pour afficher les notifications.

**Ajouter √† `app.js` :**
```javascript
// app.js
function showNotification(message, isError = false) {
    const notificationArea = document.getElementById('create-status-message'); // ou un autre √©l√©ment
    notificationArea.textContent = message;
    notificationArea.style.color = isError ? 'red' : 'green';
}

// Utilisation dans createShip :
async function createShip(event) {
    // ...
    try {
        // ...
        const newShip = await apiRequest('/spaceships', options);
        showNotification(`üöÄ Lancement r√©ussi ! ID : ${newShip.id}`);
        // ...
    } catch (error) {
        showNotification(`üî¥ Erreur : ${error.message}`, true);
    }
}
```
Nous avons maintenant un m√©canisme unifi√© pour afficher √† la fois les messages de succ√®s et les erreurs.

---

#### **Quiz de consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Le bloc `.catch()` dans une promesse `fetch` se d√©clenchera si...</p>
      <label><input type="radio" name="q1" value="a"> a) Le serveur a renvoy√© une erreur 404 Not Found</label>
      <label><input type="radio" name="q1" value="b"> b) Une erreur r√©seau s'est produite (par exemple, pas d'internet)</label>
      <label><input type="radio" name="q1" value="c"> c) Le serveur a renvoy√© une erreur 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. Pourquoi est-il n√©cessaire d'avoir une fonction de gestion centralis√©e pour les requ√™tes API ?</p>
      <label><input type="radio" name="q2" value="a"> a) Pour √©viter la duplication de code de gestion des erreurs et rendre la logique UI plus propre</label>
      <label><input type="radio" name="q2" value="b"> b) Pour que toutes les requ√™tes soient envoy√©es simultan√©ment</label>
      <label><input type="radio" name="q2" value="c"> c) C'est une exigence de la norme Fetch API</label>
    </div>
    <div class="question">
      <p>3. `response.headers.get('content-type')` est utilis√© pour...</p>
      <label><input type="radio" name="q3" value="a"> a) D√©finir un en-t√™te dans une requ√™te sortante</label>
      <label><input type="radio" name="q3" value="b"> b) V√©rifier le type de contenu dans la r√©ponse re√ßue du serveur</label>
      <label><input type="radio" name="q3" value="c"> c) Obtenir tous les types de contenu disponibles</label>
    </div>
    <div class="question">
      <p>4. `throw new Error(...)` √† l'int√©rieur de `try...catch` ou `.then()` est utilis√© pour...</p>
      <label><input type="radio" name="q4" value="a"> a) Arr√™ter l'ex√©cution de tout le JavaScript sur la page</label>
      <label><input type="radio" name="q4" value="b"> b) "Faire √©chouer" la promesse et transf√©rer le contr√¥le au bloc `.catch()` le plus proche</label>
      <label><input type="radio" name="q4" value="c"> c) Afficher un message dans une `alert`</label>
    </div>
    <div class="question">
      <p>5. Pourquoi est-il important d'afficher les erreurs √† l'utilisateur, et pas seulement dans la console ?</p>
      <label><input type="radio" name="q5" value="a"> a) Parce que la plupart des utilisateurs ne regardent pas la console</label>
      <label><input type="radio" name="q5" value="b"> b) Pour que l'interface soit compr√©hensible et pr√©visible</label>
      <label><input type="radio" name="q5" value="c"> c) Les deux options sont valables</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'b', q4: 'b', q5: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> R√©ponse correcte : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre r√©sultat : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ R√©sum√© du chapitre :**

Vous avez renforc√© votre MCC en cr√©ant des protocoles d'urgence fiables.

- üõ°Ô∏è Vous comprenez la diff√©rence entre les erreurs r√©seau, client et serveur.
- ‚öôÔ∏è Vous avez cr√©√© une fonction `apiRequest` centralis√©e pour g√©rer toutes les requ√™tes, √©vitant ainsi la duplication de code.
- üì° Votre interface est d√©sormais capable d'informer correctement l'utilisateur des erreurs, la rendant plus conviviale et fiable.
**Boucliers d'urgence lev√©s !** Mais qu'est-ce qui est mieux : les cha√Ænes `.then()` ou le `async/await` moderne ? Dans le chapitre suivant, nous analyserons les deux approches et comprendrons quand utiliser laquelle.

> **üìå V√©rification :**

> - V√©rifiez que votre code dans `app.js` est correctement refactoris√© et utilise la nouvelle fonction `apiRequest`.
> - Essayez d'arr√™ter le serveur FastAPI et de cliquer sur le bouton "Demander des donn√©es". Vous devriez voir une erreur de connexion sur la page.
> - Essayez de cr√©er un vaisseau avec des donn√©es non valides. Vous devriez voir un message d'erreur de validation provenant de FastAPI.

> **‚ö†Ô∏è En cas d'erreurs :**

> - `apiRequest is not defined` : Assurez-vous d'avoir connect√© `api.js` dans `index.html` **avant** `app.js`.
> - V√©rifiez la console du navigateur pour d'autres erreurs de syntaxe en JavaScript.