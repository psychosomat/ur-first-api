# **Chapitre 4.5 : Async/await vs Promise**
**Temps d'√©tude :** 30 minutes

---

#### **1. Asynchronisme : Deux mani√®res de g√©rer la "communication spatiale"**
Imaginez que le Centre de Contr√¥le de Mission (CCM) envoie une commande √† Mars. La r√©ponse n'arrivera que dans quelques minutes. Comment organiser le travail pendant ce temps ?

**M√©thode 1 : "Protocole de rappel" (Promise avec `.then()`)**
Vous envoyez une commande et donnez l'instruction : "**QUAND** la r√©ponse arrivera, **ALORS** ex√©cute cette fonction". Cela ressemble √† une cha√Æne d'√©v√©nements.

**M√©thode 2 : "Mode d'attente" (Async/await)**
Vous dites : "Je **VAIS ATTENDRE** la r√©ponse √† cette commande, mais je ne bloquerai pas les autres pupitres de commande". C'est comme si vous mettiez en pause l'ex√©cution de *cette t√¢che sp√©cifique*, permettant au reste du CCM de continuer √† fonctionner.

Les deux m√©thodes r√©solvent la m√™me t√¢che : la gestion des op√©rations asynchrones. `async/await` est simplement une syntaxe plus moderne et lisible qui fonctionne "au-dessus" des promesses.

> üí° **Analogie spatiale :**

> - **Promise avec `.then()`** : C'est comme √©crire sur un post-it : "Quand le rover martien enverra la photo, la transmettre au d√©partement d'analyse."
> - **Async/await** : C'est comme dire √† un assistant : "Attendez la photo du rover martien, pendant ce temps je m'occupe des calculs pour le lancement d'une nouvelle fus√©e."

---

#### **2. Promise avec `.then()` : La cha√Æne de commandes classique**
C'est la mani√®re fondamentale de travailler avec l'asynchronisme en JavaScript, que nous avons utilis√©e au chapitre 4.1.

**Rappelons notre premier code :**
```javascript
function getIssPositionWithPromises() {
    console.log('Envoi de la requ√™te via le protocole "Promise"...');

    fetch('http://api.open-notify.org/iss-now.json')
        .then(response => {
            // √âtape 1 : R√©ponse re√ßue
            if (!response.ok) {
                throw new Error(`Erreur HTTP : ${response.status}`);
            }
            return response.json(); // On retourne une nouvelle promesse
        })
        .then(data => {
            // √âtape 2 : Donn√©es pars√©es
            console.log('Donn√©es via le protocole "Promise" re√ßues :', data.iss_position);
        })
        .catch(error => {
            // √âtape 3 (Erreur) : Quelque chose s'est mal pass√© √† l'une des √©tapes
            console.error('Panne de communication via le protocole "Promise" :', error);
        });

    console.log('...commande envoy√©e, le CCM continue son travail...');
}
```

**Avantages :**

- Cha√Æne d'actions explicite.
- Convient bien aux op√©rations s√©quentielles simples.

**Inconv√©nients :**

- **"Enfer des rappels" (Callback Hell) :** Avec un grand nombre d'op√©rations asynchrones imbriqu√©es, le code peut se transformer en une "√©chelle" de `.then()` difficile √† lire.
- La gestion des erreurs peut √™tre moins intuitive.

---

#### **3. Async/await : Le style synchrone moderne**
`async/await` est du "sucre syntaxique" au-dessus des promesses, qui permet d'√©crire du code asynchrone comme s'il √©tait synchrone.

**R√®gles d'utilisation :**

1.  Le mot-cl√© `await` ne peut √™tre utilis√© **qu'√† l'int√©rieur d'une fonction** marqu√©e comme `async`.
2.  `await` est plac√© devant un appel qui retourne une promesse (par exemple, `fetch()` ou `response.json()`).
3.  `await` "suspend" l'ex√©cution de la fonction `async` jusqu'√† ce que la promesse soit r√©solue, et retourne son r√©sultat.

**Le m√™me code, r√©√©crit avec `async/await` :**
```javascript
async function getIssPositionWithAsyncAwait() {
    console.log('Envoi de la requ√™te via le protocole "Async/await"...');

    try {
        // √âtape 1 : On attend la r√©ponse du serveur
        const response = await fetch('http://api.open-notify.org/iss-now.json');

        if (!response.ok) {
            throw new Error(`Erreur HTTP : ${response.status}`);
        }

        // √âtape 2 : On attend que le corps de la r√©ponse soit converti en JSON
        const data = await response.json();

        console.log('Donn√©es via le protocole "Async/await" re√ßues :', data.iss_position);
    } catch (error) {
        // √âtape 3 (Erreur) : On attrape toute erreur du bloc try
        console.error('Panne de communication via le protocole "Async/await" :', error);
    }

    console.log('...commande envoy√©e, le CCM continue son travail...');
}
```

**Avantages :**

- **Lisibilit√© :** Le code ressemble presque √† du code synchrone ordinaire, il est facile √† lire de haut en bas.
- **Gestion des erreurs :** Utilise le bloc `try...catch` standard et familier.
- **D√©bogage :** Beaucoup plus facile √† d√©boguer, car on peut placer des points d'arr√™t (breakpoints) sur chaque ligne avec `await`.

**Inconv√©nients :**

- Facile d'oublier `await` ou `async`, ce qui entra√Ænera des erreurs.

---

#### **4. Quand utiliser quel protocole ?**

| Situation | Approche recommand√©e | Pourquoi ? |
|---|---|---|
| **La plupart des cas** | **`async/await`** | Code plus propre, plus facile √† lire et √† d√©boguer. C'est le standard moderne. |
| **Cha√Æne simple de 1-2 actions** | Promise avec `.then()` | Convient parfaitement, le code reste compact. |
| **Ex√©cution parall√®le de plusieurs requ√™tes** | `Promise.all()` | Cette m√©thode permet de lancer plusieurs promesses simultan√©ment et d'attendre qu'elles se terminent toutes. `async/await` se combine parfaitement avec elle. |

**Exemple avec `Promise.all()` :**
```javascript
async function getParallelData() {
    try {
        // On lance les deux requ√™tes simultan√©ment
        const [shipsResponse, launchesResponse] = await Promise.all([
            fetch('https://api.spacexdata.com/v4/rockets'),
            fetch('https://api.spacexdata.com/v4/launches/latest')
        ]);

        if (!shipsResponse.ok || !launchesResponse.ok) {
            throw new Error('Une des requ√™tes a √©chou√© !');
        }

        const rockets = await shipsResponse.json();
        const latestLaunch = await launchesResponse.json();

        console.log(`Nombre total de fus√©es dans la flotte : ${rockets.length}`);
        console.log(`Dernier lancement : ${latestLaunch.name}`);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des donn√©es parall√®les :', error);
    }
}
```

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. `async/await` est...</p>
      <label><input type="radio" name="q1" value="a"> a) Un remplacement des promesses qui fonctionne diff√©remment</label>
      <label><input type="radio" name="q1" value="b"> b) Une syntaxe plus pratique pour travailler avec les promesses</label>
      <label><input type="radio" name="q1" value="c"> c) Un moyen de rendre JavaScript synchrone</label>
    </div>
    <div class="question">
      <p>2. Quel mot-cl√© est obligatoire pour une fonction √† l'int√©rieur de laquelle `await` est utilis√© ?</p>
      <label><input type="radio" name="q2" value="a"> a) `promise`</label>
      <label><input type="radio" name="q2" value="b"> b) `function`</label>
      <label><input type="radio" name="q2" value="c"> c) `async`</label>
    </div>
    <div class="question">
      <p>3. Le principal avantage d' `async/await` par rapport √† `.then()` :</p>
      <label><input type="radio" name="q3" value="a"> a) Une vitesse d'ex√©cution plus √©lev√©e</label>
      <label><input type="radio" name="q3" value="b"> b) Une meilleure lisibilit√© du code et une gestion pratique des erreurs via `try...catch`</label>
      <label><input type="radio" name="q3" value="c"> c) Fonctionne dans les anciens navigateurs sans polyfills</label>
    </div>
    <div class="question">
      <p>4. Que se passe-t-il si vous oubliez `await` avant `fetch()` √† l'int√©rieur d'une fonction `async` ?</p>
      <label><input type="radio" name="q4" value="a"> a) Le code s'ex√©cutera sans erreurs, mais la variable contiendra une promesse et non le r√©sultat</label>
      <label><input type="radio" name="q4" value="b"> b) JavaScript l√®vera une erreur de syntaxe</label>
      <label><input type="radio" name="q4" value="c"> c) La page "g√®lera" en attendant une r√©ponse</label>
    </div>
    <div class="question">
      <p>5. `Promise.all()` est utilis√© pour :</p>
      <label><input type="radio" name="q5" value="a"> a) L'ex√©cution des promesses strictement dans l'ordre</label>
      <label><input type="radio" name="q5" value="b"> b) Le lancement de plusieurs promesses en parall√®le et l'attente de toutes</label>
      <label><input type="radio" name="q5" value="c"> c) La s√©lection de la plus rapide parmi plusieurs promesses</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez appris deux syntaxes pour g√©rer les op√©rations asynchrones et compris pourquoi `async/await` est pr√©f√©rable dans la plupart des projets modernes.

- üîó Vous avez rafra√Æchi vos connaissances sur les **Promise avec `.then()`**.
- üõ†Ô∏è Vous avez profond√©ment compris comment fonctionne **`async/await`** et ses avantages.
- ‚ö° Vous avez d√©couvert `Promise.all` pour l'ex√©cution de requ√™tes parall√®les.

**Les protocoles de communication ont √©t√© √©tudi√©s !** Dans le dernier chapitre de cette section, nous rassemblerons toutes nos connaissances et ach√®verons notre "Centre de Contr√¥le de Mission", en cr√©ant une interface compl√®te pour toutes les op√©rations CRUD.

> **üìå Pratique :**

> - R√©√©crivez toutes les fonctions de votre `app.js` qui utilisent encore `.then()`, en utilisant la syntaxe `async/await`.
> - Essayez d'ajouter une autre requ√™te √† `Promise.all()` (par exemple, vers `https://api.spacexdata.com/v4/starlink`) et d'afficher les donn√©es.

> **‚ö†Ô∏è En cas d'erreurs :**

> - `await is only valid in async functions` : Assurez-vous que la fonction o√π vous utilisez `await` est marqu√©e comme `async`.
> - La variable contient `[object Promise]` : Vous avez oubli√© de placer `await` devant la fonction qui retourne une promesse.