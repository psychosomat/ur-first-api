# **Chapitre 5.4 : Travailler avec les jetons CSRF**
**Temps d'√©tude :** 30 minutes

---

### **1. Qu'est-ce qu'une attaque CSRF ? Le "d√©tournement" de votre vaisseau**

Imaginez que vous √™tes connect√© au panneau de contr√¥le de votre flotte spatiale (`space-api.test`). Dans un onglet voisin, vous ouvrez un site de chats inoffensif (`evil-cats.com`). Sur ce site, il y a un formulaire cach√© qui envoie automatiquement une requ√™te √† votre site √† l'adresse `POST /api/planets/1/delete`.

√âtant donn√© que vous √™tes d√©j√† autoris√© sur `space-api.test`, votre navigateur attachera gentiment tous vos cookies √† cette requ√™te. Le serveur Laravel verra une session valide et pensera que c'est vous qui avez d√©cid√© de d√©classer la plan√®te. **La plan√®te sera supprim√©e √† votre insu.**

C'est ce qu'on appelle la **CSRF (Cross-Site Request Forgery)** ‚Äî une attaque o√π un attaquant force le navigateur d'un utilisateur authentifi√© √† effectuer une action ind√©sirable sur un site de confiance.

> üí° **Analogie spatiale :**

> Vous √™tes le capitaine d'un vaisseau, et vous avez une carte-cl√© (session/cookie). L'attaquant ne peut pas voler votre carte. Mais il peut vous forcer par la ruse √† l'appliquer au terminal de d√©classification des ressources pendant que vous √™tes distrait. Un jeton CSRF, c'est comme un code PIN que vous devez saisir avec la carte. L'attaquant ne conna√Æt pas le code PIN, et son attaque √©choue.

---

### **2. Comment Laravel prot√®ge-t-il contre la CSRF ?**

Laravel prot√®ge par d√©faut toutes les requ√™tes web "non s√©curis√©es" (POST, PUT, PATCH, DELETE) √† l'aide d'un **jeton CSRF**.

1.  Lors de la g√©n√©ration d'une page, Laravel cr√©e un jeton unique et al√©atoire pour la session de l'utilisateur.
2.  Ce jeton est int√©gr√© dans les formulaires HTML.
3.  Lors de l'envoi du formulaire, le jeton est envoy√© avec la requ√™te.
4.  C√¥t√© serveur, le middleware `VerifyCsrfToken` compare le jeton de la requ√™te avec le jeton stock√© dans la session.
5.  **Si les jetons ne correspondent pas, Laravel interrompt la requ√™te avec une erreur 419 (Session expir√©e/Page expir√©e).**

**Important :** Les routes API dans `routes/api.php` ne sont **pas** prot√©g√©es par CSRF, car elles supposent un autre m√©canisme d'authentification (par exemple, les jetons Sanctum), et non des sessions bas√©es sur les cookies. Notre probl√®me actuel concerne sp√©cifiquement les routes web et les pages que nous cr√©ons dans `routes/web.php`.

---

### **3. Utilisation du jeton CSRF dans les formulaires HTML**
C'est le sc√©nario le plus simple. Laravel fournit une directive Blade sp√©ciale pour cela.

**Exemple : Formulaire de cr√©ation de plan√®te**
Cr√©ons un formulaire simple dans le fichier `resources/views/planets/create.blade.php` :

```html
<h2>Formulaire de lancement d'une nouvelle plan√®te</h2>
<form action="/planets" method="POST">
    @csrf {{-- Voil√† la magie ! --}}

    <label for="name">Nom :</label>
    <input type="text" id="name" name="name" required>

    <label for="solar_system">Syst√®me solaire :</label>
    <input type="text" id="solar_system" name="solar_system" required>

    {{-- ... autres champs ... --}}

    <button type="submit">Lancer</button>
</form>
```

La directive `@csrf` g√©n√©rera automatiquement un champ cach√© dans le formulaire :
```html
<input type="hidden" name="_token" value="j2aK3dLf4gH5...jeton_unique...">
```

C'est suffisant pour prot√©ger les formulaires HTML standards.

---

### **4. Utilisation du jeton CSRF dans les requ√™tes AJAX/Fetch**

Dans le chapitre pr√©c√©dent, nous avons envoy√© une requ√™te `DELETE` en utilisant JavaScript. Maintenant, Laravel va la bloquer avec une erreur 419. Nous devons ajouter le jeton CSRF dans les en-t√™tes de notre requ√™te Fetch.

**√âtape 1 : Rendre le jeton accessible √† JavaScript**

Ajoutez une balise meta avec le jeton dans le `<head>` de votre mise en page principale `resources/views/app.blade.php`. C'est une pratique standard dans Laravel.

```blade
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    {{-- Ajout du jeton CSRF dans la balise meta --}}
    <meta name="csrf-token" content="{{ csrf_token() }}">

    {{-- ... --}}
</head>
```

La fonction `csrf_token()` renvoie le jeton actuel.

**√âtape 2 : Modifier JavaScript pour envoyer le jeton**

Maintenant, dans notre `public/js/planets.js`, nous pouvons lire ce jeton et l'ajouter aux en-t√™tes de toutes les requ√™tes "non s√©curis√©es".

```javascript
// ... dans le fichier public/js/planets.js ...

document.addEventListener('DOMContentLoaded', () => {
    // Obtenir le jeton de la balise meta
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const deleteButtons = document.querySelectorAll('.delete-btn');

    deleteButtons.forEach(button => {
        button.addEventListener('click', async (event) => {
            // ... logique de confirmation ...

            try {
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-TOKEN': csrfToken // <-- Ajouter le jeton aux en-t√™tes !
                    }
                });

                // ... reste de la logique de traitement de la r√©ponse ...
            } catch (error) {
                // ...
            }
        });
    });
});
```

-   Le nom de l'en-t√™te `X-CSRF-TOKEN` est la norme que Laravel v√©rifie par d√©faut.

Nos requ√™tes AJAX sont maintenant √©galement prot√©g√©es. Essayez √† nouveau de supprimer une plan√®te ‚Äî cette fois, la requ√™te sera r√©ussie.

---

### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Quelle attaque le jeton CSRF pr√©vient-il ?</p>
      <label><input type="radio" name="q1" value="a"> a) Injections SQL</label>
      <label><input type="radio" name="q1" value="b"> b) Scripting inter-sites (XSS)</label>
      <label><input type="radio" name="q1" value="c"> c) Falsification de requ√™te inter-sites (CSRF)</label>
    </div>
    <div class="question">
      <p>2. Quelle directive Blade ajoute un champ cach√© avec le jeton CSRF √† un formulaire ?</p>
      <label><input type="radio" name="q2" value="a"> a) @token</label>
      <label><input type="radio" name="q2" value="b"> b) @csrf</label>
      <label><input type="radio" name="q2" value="c"> c) @form_token</label>
    </div>
    <div class="question">
      <p>3. Que se passe-t-il si vous envoyez une requ√™te POST sans jeton CSRF √† une route web ?</p>
      <label><input type="radio" name="q3" value="a"> a) Erreur 500 (Internal Server Error)</label>
      <label><input type="radio" name="q3" value="b"> b) Erreur 403 (Forbidden)</label>
      <label><input type="radio" name="q3" value="c"> c) Erreur 419 (Page expir√©e / Session expir√©e)</label>
    </div>
    <div class="question">
      <p>4. Quel en-t√™te HTTP standard est utilis√© pour envoyer le jeton CSRF dans les requ√™tes AJAX ?</p>
      <label><input type="radio" name="q4" value="a"> a) Authorization</label>
      <label><input type="radio" name="q4" value="b"> b) X-CSRF-TOKEN</label>
      <label><input type="radio" name="q4" value="c"> c) Content-Type</label>
    </div>
    <div class="question">
      <p>5. Pourquoi les routes API (`routes/api.php`) n'utilisent-elles pas la protection CSRF par d√©faut ?</p>
      <label><input type="radio" name="q5" value="a"> a) Parce qu'elles sont destin√©es √† l'authentification sans √©tat</label>
      <label><input type="radio" name="q5" value="b"> b) C'est une erreur dans Laravel, elles doivent √™tre activ√©es manuellement</label>
      <label><input type="radio" name="q5" value="c"> c) Parce que les requ√™tes API ne peuvent pas √™tre falsifi√©es</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'c', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> R√©ponse correcte : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez install√© un "syst√®me d'identification ami ou ennemi" sur votre vaisseau spatial, le prot√©geant ainsi des attaques CSRF. Vous avez appris √† :

-   Comprendre l'essence et le danger des attaques CSRF.
-   Prot√©ger les formulaires HTML standards √† l'aide de la directive `@csrf`.
-   Transmettre le jeton CSRF √† JavaScript via une balise meta.
-   Inclure le jeton dans les en-t√™tes des requ√™tes AJAX/Fetch pour leur ex√©cution r√©ussie.

**Vos interfaces web sont maintenant non seulement interactives, mais aussi s√©curis√©es.** Dans le chapitre suivant, nous terminerons la cr√©ation de notre interface web en examinant comment organiser correctement le routage pour les pages web.