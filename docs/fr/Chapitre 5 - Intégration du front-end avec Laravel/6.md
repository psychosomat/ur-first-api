# **Chapitre 5.6 : Affichage des donn√©es via Blade + Fetch**
**Temps d'√©tude :** 50 minutes

---

### **1. Approche hybride : Le meilleur des deux mondes**

Nous pouvons construire une page de deux mani√®res :

1.  **Rendu c√¥t√© serveur complet (SSR) :** Laravel g√©n√®re tout le HTML, y compris la liste des plan√®tes. Pour toute mise √† jour (suppression, ajout), la page est enti√®rement recharg√©e.
2.  **Rendu c√¥t√© client complet (CSR) :** Laravel renvoie une "coque" HTML vide, et JavaScript demande toutes les donn√©es √† l'API et les rend c√¥t√© client. (C'est l'approche Single Page Application - SPA).

**Notre choix ‚Äî l'approche hybride :**

-   **Premier chargement (SSR) :** Laravel renvoie imm√©diatement la page avec une liste de plan√®tes d√©j√† pr√™te. C'est rapide et bon pour le SEO. L'utilisateur voit imm√©diatement le contenu.
-   **Actions suivantes (CSR) :** JavaScript intercepte les actions de l'utilisateur (clics sur les boutons) et interagit avec l'API, ne mettant √† jour que les parties n√©cessaires de la page, sans rechargement complet.

> üí° **Analogie spatiale :**

> En entrant sur la passerelle, on vous remet imm√©diatement une carte de navigation principale, imprim√©e au centre de contr√¥le (SSR). Vous l'avez d√©j√† en main, pas besoin d'attendre. Mais ensuite, vous activez le "mode direct" sur votre tablette (CSR), et elle commence √† recevoir des mises √† jour des satellites en temps r√©el, redessinant les objets sur votre carte.

---

### **2. √âtape 1 : Pr√©paration de la page**

Nous allons travailler avec notre page de liste des plan√®tes `resources/views/planets/index.blade.php`. Elle sait d√©j√† afficher les donn√©es transmises par le contr√¥leur. Nous allons maintenant y ajouter des √©l√©ments de contr√¥le qui fonctionneront via JS.

**Ajoutons le bouton "Actualiser la liste" et un conteneur pour les notifications :**
```html
    <div class="controls">
        <h2>Liste de toutes les plan√®tes connues</h2>
        <button id="refresh-btn">Actualiser via API</button>
    </div>
    <div id="notification-area" class="notification"></div>
    <hr>
    {{-- Ce div sera notre conteneur pour la mise √† jour dynamique --}}
    <div id="planet-list-container" class="planet-list">
        {{-- Inclut la vue "enfant" qui rend la liste initiale --}}
        @include('planets.partials.list', ['planets' => $planets])
    </div>
```

Notez bien `@include('planets.partials.list', ...)`. Nous avons extrait la logique d'affichage de la liste dans un fichier s√©par√© et r√©utilisable.

---

### **√âtape 2 : Cr√©ation d'une vue "partielle" r√©utilisable (Partial)**

Extraire les parties r√©p√©titives dans des fichiers s√©par√©s est une bonne pratique.

Cr√©ez le fichier `resources/views/planets/partials/list.blade.php` :

```blade
@forelse($planets as $planet)
    <div class="planet-card" id="planet-card-{{ $planet->id }}">
        <h3>{{ $planet->name }}</h3>
        <p>Syst√®me solaire : {{ $planet->solar_system }}</p>
        <p>Diam√®tre : {{ number_format($planet->size_km, 0, '.', ' ') }} km</p>
        <a href="{{ route('planets.show', $planet) }}">En savoir plus &rarr;</a>
        <button class="delete-btn" data-id="{{ $planet->id }}" data-url="{{ route('api.planets.destroy', $planet) }}">
            D√©saffecter
        </button>
    </div>
@empty
    <p>Il n'y a aucune plan√®te dans la base de donn√©es.</p>
@endforelse
```

-   **Important :** Notez que l'URL du bouton de suppression est maintenant g√©n√©r√©e pour la route API : `route('api.planets.destroy', $planet)`. Pour cela, assurez-vous d'avoir une ressource nomm√©e dans `routes/api.php` : `Route::apiResource('planets', ...)->name('api.planets');`

---

### **√âtape 3 : √âcriture du JavaScript pour la mise √† jour dynamique**

Maintenant, la partie la plus int√©ressante. Cr√©ons un JavaScript qui, via un bouton, demandera une liste de plan√®tes actualis√©e √† l'API et la redessinera.

Cr√©ez le fichier `public/js/planet-manager.js` et incluez-le dans `layouts/app.blade.php`.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refresh-btn');
    const planetListContainer = document.getElementById('planet-list-container');
    const notificationArea = document.getElementById('notification-area');

    // Fonction pour afficher les notifications
    function showNotification(message, isError = false) {
        notificationArea.textContent = message;
        notificationArea.className = isError ? 'notification error' : 'notification success';
        setTimeout(() => {
            notificationArea.textContent = '';
            notificationArea.className = 'notification';
        }, 3000);
    }

    // Fonction pour dessiner une seule carte de plan√®te
    function createPlanetCardHtml(planet) {
        // IMPORTANT : Nous g√©n√©rons le m√™me HTML que dans notre vue partielle
        return `
            <div class="planet-card" id="planet-card-${planet.id}">
                <h3>${planet.name}</h3>
                <p>Syst√®me solaire : ${planet.solar_system}</p>
                <p>Diam√®tre : ${new Intl.NumberFormat().format(planet.size_km)} km</p>
                <a href="/planets/${planet.id}">En savoir plus &rarr;</a>
                <button class="delete-btn" data-id="${planet.id}" data-url="/api/planets/${planet.id}">
                    D√©commissionner (JS)
                </button>
            </div>
        `;
    }

    // Fonction pour demander et redessiner la liste des plan√®tes
    async function fetchAndRenderPlanets() {
        showNotification('Requ√™te de donn√©es fra√Æches aupr√®s des satellites orbitaux...');
        try {
            const response = await fetch('/api/planets', {
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) {
                throw new Error('Erreur r√©seau lors de la r√©cup√©ration des donn√©es.');
            }

            const planets = await response.json(); // Laravel retournera par d√©faut { data: [...] } pour une ressource pagin√©e

            planetListContainer.innerHTML = ''; // Nettoyage de l'ancienne liste

            if (planets.data.length === 0) {
                planetListContainer.innerHTML = '<p>Il n\'y a aucune plan√®te dans la base de donn√©es.</p>';
            } else {
                planets.data.forEach(planet => {
                    const cardHtml = createPlanetCardHtml(planet);
                    planetListContainer.innerHTML += cardHtml;
                });
            }
            showNotification('Donn√©es mises √† jour avec succ√®s !', false);
        } catch (error) {
            console.error('Erreur lors de la mise √† jour de la liste des plan√®tes :', error);
            showNotification(error.message, true);
        }
    }

    // Attacher le gestionnaire au bouton
    if (refreshBtn) {
        refreshBtn.addEventListener('click', fetchAndRenderPlanets);
    }

    // La logique de suppression du chapitre pr√©c√©dent pourra √™tre d√©plac√©e ici,
    // afin que tout le JS soit au m√™me endroit.
});
```

---

### **3. V√©rification finale**

1.  **Lancez le serveur** (`php artisan serve` ou assurez-vous que Herd fonctionne).
2.  **Recr√©ez la base de donn√©es,** si n√©cessaire : `php artisan migrate:fresh --seed`.
3.  **Ouvrez la page `/planets`** dans le navigateur.
    -   Vous devriez voir imm√©diatement la liste des plan√®tes, g√©n√©r√©e par le serveur.
4.  **Cliquez sur le bouton "Actualiser via API"**.
    -   Vous verrez une notification de chargement.
    -   La liste devrait dispara√Ætre un instant et r√©appara√Ætre, mais cette fois-ci, elle sera g√©n√©r√©e par JavaScript √† partir des donn√©es re√ßues de l'API.

Vous avez impl√©ment√© avec succ√®s un mod√®le hybride !

---

### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Qu'est-ce que l'approche hybride de rendu (SSR + CSR) ?</p>
      <label><input type="radio" name="q1" value="a"> a) Une page vide est d'abord rendue, puis JS charge tout le contenu</label>
      <label><input type="radio" name="q1" value="b"> b) Le serveur renvoie une page enti√®rement pr√™te, et elle ne change jamais c√¥t√© client</label>
      <label><input type="radio" name="q1" value="c"> c) Le serveur renvoie une page pr√™te pour un premier chargement rapide, et les mises √† jour ult√©rieures se font c√¥t√© client via JS</label>
    </div>
    <div class="question">
      <p>2. Quel est l'avantage principal du rendu c√¥t√© serveur initial (SSR) ?</p>
      <label><input type="radio" name="q2" value="a"> a) R√©duction de la charge sur le serveur</label>
      <label><input type="radio" name="q2" value="b"> b) Rendu rapide du contenu pour l'utilisateur et bonne indexation SEO</label>
      <label><input type="radio" name="q2" value="c"> c) Simplification du code JavaScript</label>
    </div>
    <div class="question">
      <p>3. Pourquoi `@include('planets.partials.list')` est-il utilis√© dans l'exemple ?</p>
      <label><input type="radio" name="q3" value="a"> a) C'est une exigence de Blade pour les boucles</label>
      <label><input type="radio" name="q3" value="b"> b) Pour r√©utiliser le code et s√©parer la logique d'affichage de la liste</label>
      <label><input type="radio" name="q3" value="c"> c) Pour le chargement asynchrone d'une partie de la page</label>
    </div>
    <div class="question">
      <p>4. Dans le code JavaScript, nous dupliquons la structure HTML de la carte. Quel pourrait √™tre un moyen plus avanc√© d'√©viter cela ?</p>
      <label><input type="radio" name="q4" value="a"> a) Demander √† l'API non pas du JSON, mais du HTML d√©j√† rendu pour une seule carte</label>
      <label><input type="radio" name="q4" value="b"> b) Utiliser des moteurs de templates JavaScript (comme Mustache, Handlebars) ou des frameworks (Vue, React)</label>
      <label><input type="radio" name="q4" value="c"> c) Les deux options sont valables</label>
    </div>
    <div class="question">
      <p>5. Pourquoi est-il important que l'API (`/api/planets`) et le code JavaScript (`createPlanetCardHtml`) g√©n√®rent des donn√©es/HTML coh√©rents ?</p>
      <label><input type="radio" name="q5" value="a"> a) Sinon, l'utilisateur verra un "saut" ou un changement dans l'interface lors de la mise √† jour via l'API</label>
      <label><input type="radio" name="q5" value="b"> b) Cela est requis par la sp√©cification Fetch API</label>
      <label><input type="radio" name="q5" value="c"> c) Sinon, Laravel renverra une erreur 500</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'c', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
```
if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre r√©sultat : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ F√©licitations pour avoir termin√© le Chapitre 5 !**

Vous avez parcouru un long chemin, des bases de Blade √† la cr√©ation de pages hybrides interactives. Vous avez appris √† :

-   Cr√©er et utiliser des mod√®les et des mises en page Blade.
-   Organiser des routes web et des contr√¥leurs pour les op√©rations CRUD.
-   Prot√©ger les formulaires web et les requ√™tes AJAX √† l'aide de jetons CSRF.
-   Int√©grer JavaScript pour une interaction dynamique avec l'API sans recharger la page.

**Votre Centre de contr√¥le de vol est enti√®rement fonctionnel, s√©curis√© et interactif.** Vous √™tes pr√™t pour la prochaine grande √©tape : comparer cette approche avec d'autres frameworks et explorer les meilleures pratiques pour la production.