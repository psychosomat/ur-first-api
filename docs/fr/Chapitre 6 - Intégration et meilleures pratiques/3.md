# **Chapitre 6.3 : Authentification de base**
**Temps d'√©tude :** 1 heure

---

#### **1. Authentification API : Le laissez-passer du Centre de Contr√¥le Mission**
L'**authentification** est le processus de v√©rification de l'identit√© d'un utilisateur. Contrairement aux sites web avec sessions et cookies, les API stateless (sans √©tat) utilisent g√©n√©ralement des **jetons**.

**Le processus se d√©roule comme suit :**

1.  L'utilisateur envoie son nom d'utilisateur et son mot de passe √† un point d'extr√©mit√© d√©di√© (par exemple, `/login`).
2.  Le serveur les v√©rifie. Si tout est correct, il g√©n√®re un **jeton** unique et chiffr√© (une longue cha√Æne de caract√®res) et le renvoie.
3.  Pour chaque requ√™te ult√©rieure aux ressources prot√©g√©es (par exemple, `POST /planets`), l'utilisateur doit joindre ce jeton dans l'en-t√™te `Authorization`.
4.  Le serveur v√©rifie la validit√© du jeton et, s'il est correct, ex√©cute la requ√™te.

> üí° **Analogie spatiale :**

> - **Nom d'utilisateur/mot de passe** = Votre scan biom√©trique pour obtenir le laissez-passer.
> - **Jeton** = Le laissez-passer √©lectronique (carte d'identit√©) que vous recevez √† l'entr√©e du Centre de Contr√¥le Mission.
> - **En-t√™te `Authorization: Bearer <jeton>`** = Vous pr√©sentez votre laissez-passer au lecteur devant chaque porte s√©curis√©e.
> - **Points d'extr√©mit√© prot√©g√©s (POST, PUT, DELETE)** = Les portes menant √† la salle des serveurs ou au pupitre de commande de lancement.

---

#### **2. Authentification dans Laravel : Sanctum**
Laravel offre une solution √©l√©gante pour l'authentification API ‚Äî **Laravel Sanctum**. Il est id√©al pour les SPA (applications monopages), les applications mobiles et les API simples bas√©es sur des jetons.

**√âtape 1 : Installation et configuration de Sanctum**

*Sanctum est d√©j√† install√© dans une application Laravel standard, mais nous allons v√©rifier la configuration.*

1.  **Publication de la configuration (si ce n'est pas d√©j√† fait) :**
    ```bash
    php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"
    ```
2.  **Ex√©cution des migrations (cr√©era la table `personal_access_tokens`) :**
    ```bash
    php artisan migrate
    ```
3.  **Ajout du trait au mod√®le `User` :**
    Ouvrez `app/Models/User.php` et assurez-vous qu'il utilise le trait `HasApiTokens`.
    ```php
    // app/Models/User.php
    use Laravel\Sanctum\HasApiTokens;

    class User extends Authenticatable
    {
        use HasApiTokens, HasFactory, Notifiable;
        // ...
    }
    ```

**√âtape 2 : Cr√©ation d'un point d'extr√©mit√© pour l'√©mission de jetons**
Nous avons besoin d'une route vers laquelle l'utilisateur enverra son nom d'utilisateur/mot de passe.

Ajoutez √† `routes/api.php` :
```php
// routes/api.php
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use App\Models\User;
use Illuminate\Validation\ValidationException;

Route::post('/login', function (Request $request) {
    $request->validate([
        'email' => 'required|email',
        'password' => 'required',
    ]);

    $user = User::where('email', $request->email)->first();

    if (! $user || ! Hash::check($request->password, $user->password)) {
        throw ValidationException::withMessages([
            'email' => ['Les identifiants sont incorrects.'],
        ]);
    }

    // Retourne le jeton
    return response()->json([
        'token' => $user->createToken('api-token')->plainTextToken
    ]);
});
```

*Pour les tests, vous pouvez cr√©er un utilisateur via un seeder ou Tinker.*

**√âtape 3 : Protection des routes**
Maintenant, prot√©geons nos op√©rations CRUD. Modifions `routes/api.php` :

```php
// routes/api.php
use App\Http\Controllers\PlanetController;

// Route publique pour visualiser les plan√®tes
Route::get('/planets', [PlanetController::class, 'index']);
Route::get('/planets/{planet}', [PlanetController::class, 'show']);

// Groupe de routes prot√©g√©es
Route::middleware('auth:sanctum')->group(function () {
    Route::post('/planets', [PlanetController::class, 'store']);
    Route::put('/planets/{planet}', [PlanetController::class, 'update']);
    Route::delete('/planets/{planet}', [PlanetController::class, 'destroy']);

    // Route pour la d√©connexion (suppression du jeton)
    Route::post('/logout', function (Request $request) {
        $request->user()->currentAccessToken()->delete();
        return response()->json(['message' => 'Vous avez √©t√© d√©connect√© avec succ√®s'], 200);
    });
});
```

Le middleware `auth:sanctum` v√©rifiera la pr√©sence d'un jeton valide dans l'en-t√™te `Authorization`.

---

#### **3. Authentification dans FastAPI : OAuth2 et JWT**

FastAPI ne dispose pas de syst√®me d'authentification int√©gr√©, mais il offre de puissants outils pour sa mise en ≈ìuvre. La norme de facto est **OAuth2 avec des jetons JWT**.

**√âtape 1 : Installation des d√©pendances**
```bash
pip install "python-jose[cryptography]" "passlib[bcrypt]" "python-multipart"
```

- `python-jose` : pour la cr√©ation et la v√©rification des jetons JWT.
- `passlib` : pour le hachage et la v√©rification des mots de passe.
- `python-multipart` : pour le traitement des donn√©es de formulaire (`username` et `password`).

**√âtape 2 : Cr√©ation du module de s√©curit√© (`security.py`)**
C'est une bonne pratique de d√©placer toute la logique d'authentification dans un fichier s√©par√©.

**Cr√©ez le fichier `security.py` :**

```python
# security.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta, timezone

# --- Param√®tres ---
SECRET_KEY = "your-super-secret-key-that-is-long-and-random" # ‚ö†Ô∏è Remplacez par votre propre cl√© !
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# --- Utilitaires ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/login")

# --- Fonctions ---
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# --- Fonction de d√©pendance pour la v√©rification du jeton ---
def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Impossible de valider les identifiants",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    # Ici, vous pouvez retourner l'utilisateur depuis la BDD, pour l'instant, nous retournons juste le nom
    return {"username": username}
```

**√âtape 3 : Int√©gration dans `main.py`**
Maintenant, int√©grons cela √† notre application.

1.  **Cr√©ons un point d'extr√©mit√© `/login` :**
    ```python
    # main.py
    from fastapi.security import OAuth2PasswordRequestForm
    from fastapi import Depends, APIRouter
    from . import security # Importons notre module

    # ... votre code FastAPI ...
    router = APIRouter(prefix="/api/v1")

    @router.post("/login")
    def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
        # Ici, la v√©rification de l'utilisateur dans la BDD doit avoir lieu
        # Pour l'exemple, nous avons un utilisateur de test
        is_user_valid = (form_data.username == "testuser" and
                         security.verify_password("testpass", security.get_password_hash("testpass")))

        if not is_user_valid:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Nom d'utilisateur ou mot de passe incorrect",
            )
        access_token = security.create_access_token(data={"sub": form_data.username})
        return {"access_token": access_token, "token_type": "bearer"}

    # ...
    app.include_router(router)
    ```

2.  **Prot√©geons les points d'extr√©mit√© :**

    Utilisons notre d√©pendance `get_current_user`.
    ```python
    # main.py ou dans votre routeur de plan√®tes

    @router.post("/planets", status_code=status.HTTP_201_CREATED)
    def create_planet(
        planet: PlanetCreate,
        current_user: dict = Depends(security.get_current_user) # <-- Protection !
    ):
        # Logique de cr√©ation de plan√®te...
        print(f"L'utilisateur {current_user['username']} cr√©e une plan√®te.")
        # ...
        return new_planet

    # Prot√©geons √©galement PUT et DELETE
    ```

---

#### **4. Utilisation des jetons sur le frontend**

Notre frontend doit maintenant d'abord obtenir le jeton, le stocker (par exemple, dans `localStorage`) et le joindre √† chaque requ√™te prot√©g√©e.

**Exemple en JavaScript (`fetch`) :**
```javascript
// 1. Connexion
async function login(email, password) {
    const response = await fetch('http://localhost:8001/api/login', { // Adresse de l'API Laravel
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({email, password})
    });
    const data = await response.json();

    if (data.token) {
        localStorage.setItem('api_token', data.token); // Stocke le jeton
    }
}

// 2. Effectue une requ√™te prot√©g√©e
async function createPlanet(planetData) {
    const token = localStorage.getItem('api_token');

    const response = await fetch('http://localhost:8001/api/planets', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}` // <--- Joindre le jeton !
        },
        body: JSON.stringify(planetData)
    });
    // ...
}
```

---

#### **Quiz pour la consolidation**


<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Les API Stateless utilisent le plus souvent pour l'authentification :</p>
      <label><input type="radio" name="q1" value="a"> a) Sessions et cookies</label>
      <label><input type="radio" name="q1" value="b"> b) Jetons (par exemple, JWT)</label>
      <label><input type="radio" name="q1" value="c"> c) Adresses IP</label>
    </div>
    <div class="question">
      <p>2. Dans Laravel, pour prot√©ger les routes avec des jetons, le middleware utilis√© est :</p>
      <label><input type="radio" name="q2" value="a"> a) auth:api</label>
      <label><input type="radio" name="q2" value="b"> b) auth:sanctum</label>
      <label><input type="radio" name="q2" value="c"> c) verified</label>
    </div>
    <div class="question">
      <p>3. Dans FastAPI, pour obtenir les donn√©es d'un formulaire de connexion, la d√©pendance utilis√©e est :</p>
      <label><input type="radio" name="q3" value="a"> a) Body()</label>
      <label><input type="radio" name="q3" value="b"> b) Form()</label>
      <label><input type="radio" name="q3" value="c"> c) OAuth2PasswordRequestForm = Depends()</label>
    </div>
    <div class="question">
      <p>4. Comment le jeton est-il transmis du client au serveur dans une requ√™te prot√©g√©e ?</p>
      <label><input type="radio" name="q4" value="a"> a) Dans le param√®tre URL `?token=...`</label>
      <label><input type="radio" name="q4" value="b"> b) Dans le corps de la requ√™te</label>
      <label><input type="radio" name="q4" value="c"> c) Dans l'en-t√™te HTTP `Authorization: Bearer <jeton>`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>
<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'c', q4: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:red;">Incorrect.</span> R√©ponse correcte : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)}: <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez mis en place un "syst√®me de contr√¥le d'acc√®s" sur vos API. D√©sormais, n'importe qui ne peut plus modifier votre "base de donn√©es galactique".

- ‚úÖ Compris le principe de l'authentification bas√©e sur les jetons.
- üîê Mis en ≈ìuvre l'√©mission de jetons et la protection des routes dans Laravel Sanctum.
- ‚öôÔ∏è Configur√©e l'authentification bas√©e sur OAuth2 et JWT dans FastAPI.
- üõ∞Ô∏è Appris comment le frontend doit stocker et utiliser le jeton.

**Vos API sont devenues non seulement fonctionnelles, mais aussi s√©curis√©es.** Cependant, pour que d'autres d√©veloppeurs puissent les utiliser, ils ont besoin d'"instructions d'utilisation".

> **üìå V√©rification :**

> - Essayez de faire une requ√™te `POST` √† `/api/planets` (dans Laravel) ou `/api/v1/planets` (dans FastAPI) sans jeton en utilisant Postman ou Insomnia. Vous devriez obtenir une erreur `401 Unauthorized`.
> - Faites une requ√™te √† `/login`, obtenez un jeton, ajoutez-le √† l'en-t√™te `Authorization` et r√©p√©tez la requ√™te `POST`. Elle devrait s'ex√©cuter avec succ√®s.