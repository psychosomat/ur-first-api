# **Chapitre 6.1 : Connexion de FastAPI au Frontend**
**Temps d'√©tude :** 30 minutes

---

#### **1. Retour au "moteur hyperdrive" : Comparaison des protocoles**
Dans le chapitre pr√©c√©dent, nous avons amarr√© notre MCC (frontend) √† la "SSI" (API Laravel). Nous allons maintenant revenir √† notre **chasseur supraluminique** (FastAPI) et effectuer la m√™me op√©ration.

L'objectif de ce chapitre n'est pas seulement de r√©p√©ter les actions, mais de **comparer deux approches**. C'est comme si le m√™me vaisseau Dragon s'amarrait d'abord √† la SSI, puis √† la station chinoise "Tiangong". Le m√©canisme d'amarrage est le m√™me (REST), mais il peut y avoir des nuances dans les proc√©dures et l'emplacement des ports.

> üí° **Analogie spatiale :**

> Le processus est le m√™me : approcher, s'aligner, s'amarrer. Mais pour la "SSI", il fallait utiliser le port `/api/planets`, et pour "Tiangong" ‚Äî le port `/spaceships`. Notre op√©rateur au MCC doit conna√Ætre ces d√©tails pour que la mission r√©ussisse.

---

#### **2. Pr√©paration du "chasseur" (FastAPI) pour l'amarrage**

Nous l'avons d√©j√† fait au Chapitre 4.2, mais assurons-nous que tout est en place.

**√âtape 1 : D√©marrer le serveur FastAPI**

1.  Arr√™tez le serveur Laravel s'il est en cours d'ex√©cution (pour √©viter les conflits de ports).
2.  Ouvrez un terminal dans le dossier de votre projet FastAPI.
3.  Activez l'environnement virtuel :

    - **Windows :** `.\venv\Scripts\Activate.ps1`
    - **macOS / Linux :** `source venv/bin/activate`

4.  D√©marrez le serveur :
    ```bash
    uvicorn main:app --reload
    ```
    Le serveur sera accessible √† l'adresse `http://127.0.0.1:8000`.

**√âtape 2 : V√©rifier les param√®tres CORS dans `main.py`**

Assurez-vous que votre projet FastAPI contient le `CORSMiddleware` configur√© que nous avons ajout√© pr√©c√©demment. Il doit autoriser les requ√™tes provenant de l'adresse de votre frontend.
```python
# main.py
from fastapi.middleware.cors import CORSMiddleware

# ...

origins = [
    "http://127.0.0.1:5500", # Adresse du Live Server
    "null", # Pour file:///
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ...
```
Si tout est en place, votre serveur FastAPI est enti√®rement pr√™t.

---

#### **3. Reconfiguration de l'"antenne" du MCC vers FastAPI**

Maintenant, le plus int√©ressant : les modifications minimales √† apporter √† notre JavaScript pour qu'il fonctionne √† nouveau avec FastAPI.

**√âtape 1 : Modifier l'URL de base**

Ouvrez `api.js` et restaurez `API_BASE_URL` √† sa valeur initiale.
```javascript
// api.js

// Sp√©cifiez l'URL de notre API FastAPI
const API_BASE_URL = 'http://127.0.0.1:8000'; // <-- Sans /api !

// ... reste du code apiRequest ...
```

**√âtape 2 : Adaptation √† la structure de la r√©ponse FastAPI**

Rappelons que notre `GET /spaceships` dans FastAPI renvoie un **simple tableau**, et non un objet avec pagination. Cela signifie que nous devons restaurer le code de `fetchAndDisplayFleet` √† son √©tat initial.

**Modifiez la fonction `fetchAndDisplayFleet` dans `app.js` :**
```javascript
// app.js

async function fetchAndDisplayFleet() {
    try {
        fleetListContainer.innerHTML = '<p>Chargement de la t√©l√©m√©trie depuis FastAPI...</p>';
        const ships = await apiRequest('/spaceships'); // <-- Requ√™te vers /spaceships

        // Dans FastAPI, nous avons un simple tableau, donc la cl√© .data n'est pas n√©cessaire !

        fleetListContainer.innerHTML = '';
        if (ships.length === 0) {
            fleetListContainer.innerHTML = '<p>Il n\'y a pas d\'appareils dans le registre.</p>';
            return;
        }

        ships.forEach(ship => {
            // Restaurons notre fonction originale pour cr√©er des cartes
            const card = createShipCard(ship);
            fleetListContainer.appendChild(card);
        });
    } catch (error) {
        fleetListContainer.innerHTML = `<p style="color: #ff6b6b;">Erreur lors du chargement de la flotte : ${error.message}</p>`;
    }
}

// Fonction originale pour cr√©er des cartes de vaisseaux
function createShipCard(ship) {
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
        <h3>${ship.name} (ID: ${ship.id})</h3>
        <p>Type: ${ship.type}</p>
        <p>Ann√©e de lancement: ${ship.launch_year}</p>
        <p>Statut: ${ship.status}</p>
        <div class="card-actions">
            <button class="edit-btn" data-ship-id="${ship.id}">Modifier</button>
            <button class="delete-btn" data-ship-id="${ship.id}">Radier</button>
        </div>
    `;
    return card;
}
```

**√âtape 3 : V√©rification des op√©rations CRUD**

√âtant donn√© que nos mod√®les Pydantic dans FastAPI et les champs du formulaire HTML correspondent (`name`, `type`, `launch_year`, `status`), les fonctions `handleSaveShip` et `handleDeleteShip` devraient fonctionner **sans modifications**, car elles ciblent d√©j√† le point de terminaison `/spaceships`.

---

#### **4. Bilan comparatif : Qu'est-ce que cela signifie pour le d√©veloppeur frontend ?**

- **Universalit√© de REST :** Vous avez clairement constat√© que pour le frontend, peu importe le backend utilis√© (PHP/Laravel ou Python/FastAPI), tant qu'il respecte les principes REST.
- **Importance de la documentation :** Les principales diff√©rences r√©sidaient dans les **URL des points de terminaison** et la **structure des r√©ponses JSON**. C'est pr√©cis√©ment ce qui doit √™tre d√©crit dans la documentation de l'API. Sans elle, le d√©veloppeur frontend travaillerait "√† l'aveugle".
- **Flexibilit√© du frontend :** Votre code JavaScript doit √™tre suffisamment flexible pour s'adapter facilement √† diff√©rents formats de donn√©es (par exemple, v√©rifier s'il y a une cl√© `data`, ou si c'est juste un tableau).

**Conclusion :** La comp√©tence √† travailler avec une API REST est une **cl√© universelle** qui ouvre les portes √† l'interaction avec n'importe quel backend moderne.

---

#### **Quiz pour la consolidation**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. La principale diff√©rence dans l'URL entre notre API Laravel et notre API FastAPI √©tait...</p>
      <label><input type="radio" name="q1" value="a"> a) L'utilisation de ports diff√©rents</label>
      <label><input type="radio" name="q1" value="b"> b) La pr√©sence du pr√©fixe `/api` chez Laravel</label>
      <label><input type="radio" name="q1" value="c"> c) L'utilisation de HTTPS chez FastAPI</label>
    </div>
    <div class="question">
      <p>2. Quel a √©t√© le principal changement requis dans le code JS lors du passage d'une r√©ponse pagin√©e de Laravel √† un simple tableau de FastAPI ?</p>
      <label><input type="radio" name="q2" value="a"> a) Cesser d'acc√©der √† `responseData.data` et utiliser `responseData` directement</label>
      <label><input type="radio" name="q2" value="b"> b) Utiliser une autre m√©thode `fetch`</label>
      <label><input type="radio" name="q2" value="c"> c) Modifier le `Content-Type` dans les en-t√™tes</label>
    </div>
    <div class="question">
      <p>3. Cette exp√©rience prouve que pour un d√©veloppeur frontend...</p>
      <label><input type="radio" name="q3" value="a"> a) Il est important de conna√Ætre √† la fois PHP et Python</label>
      <label><input type="radio" name="q3" value="b"> b) Il est important de comprendre les principes REST et de savoir lire la documentation API</label>
      <label><input type="radio" name="q3" value="c"> c) Laravel et FastAPI sont absolument identiques</label>
    </div>
    <div class="question">
      <p>4. La configuration CORS est une t√¢che...</p>
      <label><input type="radio" name="q4" value="a"> a) Du d√©veloppeur frontend</label>
      <label><input type="radio" name="q4" value="b"> b) De l'administrateur syst√®me</label>
      <label><input type="radio" name="q4" value="c"> c) Du d√©veloppeur backend</label>
    </div>
    <div class="question">
      <p>5. Si FastAPI utilisait la pagination, comme Laravel, que devrions-nous faire c√¥t√© frontend ?</p>
      <label><input type="radio" name="q5" value="a"> a) Rien, le code fonctionnerait tout seul</label>
      <label><input type="radio" name="q5" value="b"> b) Modifier √† nouveau la logique pour extraire le tableau de la cl√© `data` (ou similaire)</label>
      <label><input type="radio" name="q5" value="c"> c) Passer de `fetch` √† la biblioth√®que Axios</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">V√©rifier</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'b', q4: 'c', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>R√©sultats :</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:green;">Correct !</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:red;">Incorrect.</span> Bonne r√©ponse : <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Question ${question.slice(1)} : <span style="color:orange;">Pas de r√©ponse.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Votre score : ${score} sur ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ R√©sum√© du chapitre :**

Vous avez r√©ussi √† changer les "protocoles de communication" de votre MCC et √† comparer en pratique le travail avec deux syst√®mes backend diff√©rents.

- ‚úÖ Vous avez consolid√© la comp√©tence de configuration de `API_BASE_URL` pour basculer entre les serveurs.
- ‚úÖ Vous avez compris l'importance de la structure de la r√©ponse (`data` vs simple tableau) et comment y adapter le frontend.
- ‚úÖ Vous avez r√©alis√© qu'un bon d√©veloppeur frontend doit √™tre pr√™t √† travailler avec n'importe quelle API RESTful, en √©tudiant attentivement sa documentation.

**La comp√©tence d'amarrage universel est acquise !** Maintenant que nous savons configurer la connexion de base, il est temps de parler de protocoles plus complexes : CORS, authentification et s√©curit√©.

> **üìå V√©rification :**

> - Assurez-vous que votre serveur FastAPI est en cours d'ex√©cution.
> - Assurez-vous d'avoir restaur√© `API_BASE_URL` et la logique de traitement de la r√©ponse dans `app.js` √† la version pour FastAPI.
> - V√©rifiez que votre frontend ex√©cute √† nouveau correctement toutes les op√©rations CRUD avec le backend FastAPI.

> **‚ö†Ô∏è En cas d'erreurs :**

> - **Erreur CORS :** Assurez-vous que le serveur FastAPI est d√©marr√© avec les bons param√®tres CORS.
> - **Erreur `Cannot read properties of undefined (reading 'length')` :** Vous avez peut-√™tre oubli√© de supprimer l'acc√®s √† `.data` de `responseData`.
> - **404 Not Found :** V√©rifiez `API_BASE_URL` ‚Äî FastAPI n'a pas de pr√©fixe `/api`.