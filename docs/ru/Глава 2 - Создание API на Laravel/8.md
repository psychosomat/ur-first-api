# **Глава 2.8: Тестирование API**
**Время изучения:** 1 час

---

#### **1. Зачем нужны тесты?**

Представьте, что вы построили космический корабль. Прежде чем отправлять его на Марс, вы проводите тысячи проверок на Земле. Тесты в программировании — это то же самое. Они:

-   **Дают уверенность:** Вы можете менять код, и если тесты проходят — значит, вы ничего не сломали.
-   **Экономят время:** Вместо того чтобы вручную "прокликивать" все в Postman после каждого изменения, вы запускаете одну команду, и она проверяет все за вас за секунды.
-   **Служат документацией:** Хорошие тесты показывают, как должен работать ваш API.

---

#### **2. Настройка тестовой "Лаборатории"**

Laravel делает настройку тестов невероятно простой. По умолчанию, он использует отдельную конфигурацию, чтобы не затронуть вашу основную базу данных.

**База данных для тестов:**
По умолчанию Laravel использует базу данных **в оперативной памяти** (`:memory:`). Это самый быстрый способ, потому что не нужно ничего писать на диск. База создается перед тестами и уничтожается после них. Нам даже не нужно ничего настраивать для этого!

**Создание тестового файла:**
Давайте создадим специальный файл для тестов, связанных с планетами.

```bash
php artisan make:test PlanetApiTest
```

Эта команда создаст файл `tests/Feature/PlanetApiTest.php`. Слово `Feature` означает, что мы будем тестировать функциональность в целом (например, "может ли пользователь создать планету?"), а не отдельный маленький класс.

---

#### **3. Анатомия теста: Подготовка, Действие, Проверка**

Откройте `tests/Feature/PlanetApiTest.php`. Внутри мы напишем наш первый тест. Хороший тест всегда состоит из трех частей (Arrange, Act, Assert).

```php
<?php

namespace Tests\Feature;

use App\Models\Planet; // Не забудьте импортировать модель
use Illuminate\Foundation\Testing\RefreshDatabase; // Важнейший инструмент!
use Tests\TestCase;

class PlanetApiTest extends TestCase
{
    // Этот трейт "волшебным образом" очищает и пересоздает
    // нашу тестовую базу данных перед каждым тестом.
    // Это гарантирует, что тесты не влияют друг на друга.
    use RefreshDatabase;

    /**
     * Тест: эндпоинт для получения списка планет работает корректно.
     * Названия тестов должны быть осмысленными!
     */
    public function test_can_get_all_planets(): void
    {
        // 1. ПОДГОТОВКА (Arrange)
        // Создаем 3 фейковые планеты в нашей тестовой базе данных
        // с помощью фабрики, которую мы создали ранее.
        Planet::factory()->count(3)->create();

        // 2. ДЕЙСТВИЕ (Act)
        // Имитируем настоящий GET-запрос к нашему API.
        $response = $this->getJson('/api/planets');

        // 3. ПРОВЕРКА (Assert)
        // Проверяем, что все прошло как надо.
        $response->assertStatus(200); // Ожидаем, что сервер ответил "200 OK"
        $response->assertJsonCount(3); // Ожидаем, что в ответе ровно 3 планеты
    }
}
```
**Ключевые моменты:**

-   `use RefreshDatabase`: Этот трейт — ваш лучший друг. Он гарантирует, что каждый тест начинается с "чистого листа", с пустой базой данных.
-   `Planet::factory()`: Фабрики идеально подходят для создания тестовых данных.
-   `$this->getJson()`: Это специальный метод Laravel для отправки API-запросов внутри тестов.
-   `assert...()`: Это "утверждения" или "проверки". Если хотя бы одна из них не выполнится, тест провалится.

---

#### **4. Тестирование основных операций (CRUD)**

Давайте напишем тесты для создания, обновления и удаления планет.

**A. Тест на создание планеты (POST)**

```php
<?php
public function test_can_create_a_planet(): void
{
    // 1. Подготовка: готовим данные для новой планеты
    $planetData = [
        'name' => 'Kepler-186f',
        'description' => 'Первая экзопланета размером с Землю в обитаемой зоне.',
        'size_km' => 14000,
        'solar_system' => 'Kepler-186'
    ];

    // 2. Действие: отправляем POST-запрос с данными
    $response = $this->postJson('/api/planets', $planetData);

    // 3. Проверка
    $response->assertStatus(201); // Ожидаем статус "201 Created"
    $response->assertJsonFragment(['name' => 'Kepler-186f']); // Проверяем, что в ответе есть созданное имя

    // Самая важная проверка: действительно ли данные попали в базу?
    $this->assertDatabaseHas('planets', [
        'name' => 'Kepler-186f'
    ]);
}
```

**B. Тест на удаление планеты (DELETE)**
```php
<?php
public function test_can_delete_a_planet(): void
{
    // 1. Подготовка: создаем планету, которую будем удалять
    $planet = Planet::factory()->create();

    // 2. Действие: отправляем DELETE-запрос
    $response = $this->deleteJson("/api/planets/{$planet->id}");

    // 3. Проверка
    $response->assertStatus(204); // Ожидаем "204 No Content" - успешное удаление

    // Проверяем, что запись действительно исчезла из базы
    $this->assertDatabaseMissing('planets', [
        'id' => $planet->id
    ]);
}
```

---

#### **5. Тестирование "плохих" сценариев**

Тестировать успешные случаи — это хорошо. Но еще важнее тестировать ошибки!

**A. Тест на ошибку валидации**
```php
<?php
public function test_creation_fails_with_invalid_data(): void
{
    // 2. Действие: отправляем заведомо некорректные данные
    $response = $this->postJson('/api/planets', ['name' => '']); // Пустое имя

    // 3. Проверка
    $response->assertStatus(422); // Ожидаем "422 Unprocessable Entity"
    $response->assertJsonValidationErrors('name'); // Ожидаем, что ошибка именно в поле 'name'
}
```

**B. Тест на "не найдено" (404)**
```php
<?php
public function test_returns_404_for_non_existent_planet(): void
{
    // 2. Действие: запрашиваем планету с несуществующим ID
    $response = $this->getJson('/api/planets/99999');

    // 3. Проверка
    $response->assertStatus(404); // Ожидаем "404 Not Found"
}
```

---

#### **6. Запуск тестов**

Теперь, когда тесты написаны, запустить их очень просто. Выполните в терминале:

```bash
php artisan test
```

Laravel найдет все ваши тесты и выполнит их один за другим. Если все пройдет успешно, вы увидите зеленый вывод. Если какой-то тест провалится, вы увидите красный вывод с подробным описанием ошибки, что позволит вам быстро ее исправить.

**Чтобы запустить только один конкретный файл:**
```bash
php artisan test tests/Feature/PlanetApiTest.php
```

---

#### **8. Покрытие кода (Code Coverage)**
**Шаг 1: Установка Xdebug**

Для сбора информации о покрытии кода требуется расширение PHP — [Xdebug](https://xdebug.org/wizard).
>Отправьте в wizard ваш `php -i` и следуйте инструкциям.

**Шаг 2: Настройка `phpunit.xml`**
```xml
<phpunit ... >
    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">./app</directory>
        </include>
    </coverage>
</phpunit>
```

**Шаг 3: Запуск с отчетом**
```bash
php artisan test --coverage-html=coverage
```
Отчет: Откройте `coverage/index.html` в браузере

---

#### **9. Интеграция с Postman**
**Автоматизация через Newman:**

1. Экспортируйте коллекцию Postman в `tests/Postman/SpaceApi.postman_collection.json`
2. Установите Newman:
```bash
npm install -g newman
```
3. Добавьте скрипт в `composer.json`:
```json
"scripts": {
    "test:postman": "newman run tests/Postman/SpaceApi.postman_collection.json"
}
```
4. Запуск:
```bash
composer test:postman
```

---

#### **Квиз для закрепления**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Команда для создания тестового класса:</p>
      <label><input type="radio" name="q1" value="a"> a) php artisan make:test</label>
      <label><input type="radio" name="q1" value="b"> b) php artisan generate:test</label>
      <label><input type="radio" name="q1" value="c"> c) php artisan test:create</label>
    </div>
    <div class="question">
      <p>2. Трейт RefreshDatabase используется для:</p>
      <label><input type="radio" name="q2" value="a"> a) Очистки БД после тестов</label>
      <label><input type="radio" name="q2" value="b"> b) Наполнения БД тестовыми данными</label>
      <label><input type="radio" name="q2" value="c"> c) Создания структуры БД</label>
    </div>
    <div class="question">
      <p>3. Метод для проверки JSON-структуры:</p>
      <label><input type="radio" name="q3" value="a"> a) assertJsonFormat()</label>
      <label><input type="radio" name="q3" value="b"> b) assertJsonStructure()</label>
      <label><input type="radio" name="q3" value="c"> c) assertJsonSchema()</label>
    </div>
    <div class="question">
      <p>4. Фабрики в Laravel нужны для:</p>
      <label><input type="radio" name="q4" value="a"> a) Генерации тестовых данных</label>
      <label><input type="radio" name="q4" value="b"> b) Создания миграций</label>
      <label><input type="radio" name="q4" value="c"> c) Обработки ошибок</label>
    </div>
    <div class="question">
      <p>5. Инструмент для запуска Postman-коллекций из CLI:</p>
      <label><input type="radio" name="q5" value="a"> a) Newman</label>
      <label><input type="radio" name="q5" value="b"> b) Postman CLI</label>
      <label><input type="radio" name="q5" value="c"> c) Artisan</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Проверить</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'a', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Результаты:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:green;">Верно!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:red;">Неверно.</span> Правильный ответ: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:orange;">Нет ответа.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Ваш результат: ${score} из ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 Итог главы:**

Вы провели полный цикл предполетных испытаний! Теперь ваш API:

- ✅ Настраивать тестовую среду без лишних усилий
- 🛡️ Писать тесты по принципу "Подготовка-Действие-Проверка".
- 📊 Тестировать как успешные сценарии (CRUD), так и ошибки (валидация, 404).
- 🔁 Запускать тесты одной командой и быть уверенным в своем коде.

**Космический корабль к запуску готов!** Вы завершили раздел по созданию API на Laravel.

> **📌 Финальная проверка:**

> 1. Запустите `php artisan test`
> 2. Убедитесь, что все тесты проходят (зеленый свет!)
> 3. Проверьте отчет о покрытии

> **⚠️ Если тесты падают:**

> - Проверьте работу API через Postman
> - Убедитесь, что тестовая БД настроена
> - Используйте `dd($response->content())` для отладки

**Поздравляем с завершением Главы 2!** Вы не просто создали API, вы создали надежный и проверенный "космический корабль", готовый к дальнейшим миссиям.

> **🌌 Дальнейшие шаги:**

> 1. Настройка аутентификации (Sanctum)
> 2. Документирование API с помощью Swagger
> 3. Развертывание на сервере (Forge, VPS)
> 4. Написание фронтенда на Vue/React

**Успешного запуска вашей космической миссии! В следующей главе мы рассмотрим написание API с нуля** 🚀
