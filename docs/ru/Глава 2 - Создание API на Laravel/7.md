# **Глава 2.7: Обработка ошибок**
**Время изучения:** 40 минут

---

#### **1. Почему стандартные ошибки — это плохо?**

Если в вашем Laravel-приложении происходит ошибка (например, не найдена запись в базе), а вы это никак не обработали, пользователь увидит огромную HTML-страницу с отладочной информацией или неинформативное сообщение "Server Error".

Для API это катастрофа. Ваше фронтенд-приложение ожидает получить JSON, а не HTML. Наша задача — перехватить любую ошибку и превратить ее в структурированный JSON-ответ.

---

#### **2. Центральный диспетчер ошибок: `bootstrap/app.php`**

В старых версиях Laravel был громоздкий файл `App\Exceptions\Handler.php`. В Laravel 11/12 все стало гораздо проще и элегантнее. Центр управления ошибками теперь находится прямо в файле конфигурации вашего приложения — `bootstrap/app.php`.

Откройте `bootstrap/app.php`. В самом низу вы увидите блок `.withExceptions(...)`. Это и есть наш "центральный диспетчер".

```php
<?php
// bootstrap/app.php

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        api: __DIR__.'/../routes/api.php',
        commands: __DIR__.'/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        // ...
    })
    ->withExceptions(function (Exceptions $exceptions) {
        // <-- ВОТ ЗДЕСЬ МЫ БУДЕМ РАБОТАТЬ
    })->create();
```

---

#### **3. Обрабатываем самую частую ошибку: "Не найдено" (404)**

Самая распространенная ошибка в API — это когда пользователь запрашивает ресурс, которого не существует (например, `GET /api/planets/999`). Laravel в этом случае генерирует исключение `ModelNotFoundException` или `NotFoundHttpException`. Давайте их перехватим.

Добавьте следующий код внутрь `.withExceptions(...)`:

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // Перехватываем исключение, когда модель не найдена в базе данных
    $exceptions->render(function (ModelNotFoundException $e, Request $request) {
        // Проверяем, что запрос пришел именно на наш API
        if ($request->is('api/*')) {
            return response()->json([
                'message' => 'Запрашиваемый ресурс не найден в нашей галактике.'
            ], 404);
        }
    });

    // Перехватываем исключение, когда сам маршрут не найден
    $exceptions->render(function (NotFoundHttpException $e, Request $request) {
        if ($request->is('api/*')) {
            return response()->json([
                'message' => 'Такого космического маршрута не существует.'
            ], 404);
        }
    });

})->create();
```
**Что мы сделали?**

1.  `$exceptions->render(...)` — мы регистрируем "обработчик". Он говорит: "Если произойдет исключение типа `ModelNotFoundException`, выполни этот код".
2.  `if ($request->is('api/*'))` — это важная проверка. Она гарантирует, что наш красивый JSON-ответ будет отправляться только для API-запросов, не затрагивая обычные веб-страницы.
3.  `return response()->json(...)` — мы создаем и возвращаем стандартизированный JSON-ответ с кодом 404.

Теперь, если вы запросите несуществующую планету, вместо уродливой HTML-страницы вы получите аккуратный JSON.

---

#### **4. Кастомные исключения: Создаем собственные "сигналы тревоги"**

Иногда стандартных исключений недостаточно. Представим, что у нас есть бизнес-правило: "нельзя удалять планету 'Земля'". Если кто-то попытается это сделать, мы должны вернуть осмысленную ошибку.

**Шаг 1: Создаем свой класс исключения**
Выполним в терминале:
```bash
php artisan make:exception CannotDeleteEarthException
```

**Шаг 2: Используем его в контроллере**
Откроем `PlanetController.php` и изменим метод `destroy`:

```php
<?php
// app/Http/Controllers/PlanetController.php
use App\Exceptions\CannotDeleteEarthException; // <-- Импортируем наше исключение
use App\Models\Planet;

public function destroy(Planet $planet)
{
    // Наше новое бизнес-правило
    if (strtolower($planet->name) === 'земля') {
        throw new CannotDeleteEarthException('Удаление планеты Земля запрещено Галактическим Кодексом.');
    }

    $planet->delete();
    return response()->json(null, 204);
}
```
Теперь, если кто-то попытается выполнить `DELETE /api/planets/1` (где 1 — это ID Земли), наш код выбросит исключение `CannotDeleteEarthException`.

**Шаг 3: Учим Laravel красиво обрабатывать нашу "тревогу"**
Вернемся в `bootstrap/app.php` и добавим новый обработчик для нашего исключения.

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // Наш новый обработчик
    $exceptions->render(function (CannotDeleteEarthException $e, Request $request) {
        return response()->json([
            'message' => 'Операция запрещена.',
            'details' => $e->getMessage() // Получаем сообщение, которое мы передали в throw
        ], 403); // 403 Forbidden - "Доступ запрещен"
    });

    // ... (остальные обработчики для 404)

})->create();
```
Готово! Мы создали собственное именованное исключение, которое делает код контроллера чище, и научили Laravel превращать его в красивый, осмысленный JSON-ответ с правильным HTTP-статусом.

---

#### **5. Обработка всех остальных сбоев (500 Internal Server Error)**

Что делать со всеми остальными, непредвиденными ошибками? Например, если отвалилась база данных или в коде синтаксическая ошибка. Для этого мы можем зарегистрировать "универсальный" обработчик для самого общего типа ошибок — `Throwable`.

**Важно:** Этот обработчик должен быть **последним**, чтобы не перехватывать более специфичные исключения, которые мы определили выше.

```php
<?php
// bootstrap/app.php

->withExceptions(function (Exceptions $exceptions) {

    // ... (обработчики для CannotDeleteEarthException и 404)

    // УНИВЕРСАЛЬНЫЙ ОБРАБОТЧИК (в самом конце)
    $exceptions->render(function (Throwable $e, Request $request) {
        if ($request->is('api/*')) {
            // В режиме отладки можно показать настоящее сообщение об ошибке
            $message = config('app.debug')
                ? 'Произошла ошибка: ' . $e->getMessage()
                : 'На борту произошла непредвиденная ошибка. Инженеры уже вызваны.';

            return response()->json(['message' => $message], 500);
        }
    });

})->create();
```

Теперь любое "неизвестное" исключение будет аккуратно перехвачено и превращено в JSON с кодом 500, не ломая ваше API и не показывая пользователю лишней информации.

---

#### **6. Логирование ошибок: Черный ящик космического корабля**
Настройки логирования в `config/logging.php`:
```php
<?php
'channels' => [
    'space_api' => [
        'driver' => 'daily',
        'path' => storage_path('logs/space_api.log'),
        'level' => 'error',
        'days' => 14,
    ],
],
```

**Добавление записи в лог:**
```php
<?php
try {
    // Код с риском ошибки
} catch (Exception $e) {
    Log::channel('space_api')->error('Ошибка доступа к планетам', [
        'exception' => $e,
        'request' => request()->all(),
        'user_id' => auth()->id()
    ]);
    throw $e;
}
```

---

#### **Квиз для закрепления**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. HTTP-статус для "Планета не найдена:</p>
      <label><input type="radio" name="q1" value="a"> a) 400</label>
      <label><input type="radio" name="q1" value="b"> b) 404</label>
      <label><input type="radio" name="q1" value="c"> c) 500</label>
    </div>
    <div class="question">
      <p>2. Класс для глобальной обработки ошибок:</p>
      <label><input type="radio" name="q2" value="a"> a) Handler.php</label>
      <label><input type="radio" name="q2" value="b"> b) ErrorController.php</label>
      <label><input type="radio" name="q2" value="c"> c) Middleware/Error.php</label>
    </div>
    <div class="question">
      <p>3. Метод для создания кастомного исключения:</p>
      <label><input type="radio" name="q3" value="a"> a) php artisan make:exception</label>
      <label><input type="radio" name="q3" value="b"> b) php artisan exception:create</label>
      <label><input type="radio" name="q3" value="c"> c) php artisan generate:exception</label>
    </div>
    <div class="question">
      <p>4. Канал для раздельного логирования ошибок API:</p>
      <label><input type="radio" name="q4" value="a"> a) Настройка в config/logging.php</label>
      <label><input type="radio" name="q4" value="b"> b) Параметр в .env</label>
      <label><input type="radio" name="q4" value="c"> c) Указание в контроллере</label>
    </div>
    <div class="question">
      <p>5. Главное преимущество создания кастомных исключений:</p>
      <label><input type="radio" name="q5" value="a"> a) Повышение производительности</label>
      <label><input type="radio" name="q5" value="b"> b) Создание семантически понятных ошибок для специфических бизнес-сценариев</label>
      <label><input type="radio" name="q5" value="c"> c) Автоматическое добавление в .env</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Проверить</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'a', q4: 'a', q5: 'b' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Результаты:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:green;">Верно!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:red;">Неверно.</span> Правильный ответ: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Вопрос ${question.slice(1)}: <span style="color:orange;">Нет ответа.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Ваш результат: ${score} из ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 Итог главы:**

Вы оснастили свое API надежной системой спасения:

- 🛟 Глобальный перехват стандартных ошибок
- 🪐 Кастомные исключения с понятными кодами
- 📝 Единый JSON-формат для всех ошибок
- 🔍 Логирование с деталями инцидента
- 📡 Интеграция с системами мониторинга

**Космический корабль готов к аварийным ситуациям!** В финальной главе раздела мы протестируем все системы.

> **📌 Проверка:**

> 1. Создайте исключение `PlanetNotFoundException`
> 2. Добавьте обработку 404 ошибок в ```->withExceptions```
> 3. Протестируйте запрос к несуществующей планете

> **⚠️ Если ошибки не перехватываются:**

> - Убедитесь что `is('api/*')` соответствует вашим роутам
> - Проверьте порядок обработчиков в `register()`
> - Для кастомных исключений используйте `throw new`
