# **Cap√≠tulo 6.3: Autentica√ß√£o B√°sica**
**Tempo de estudo:** 1 hora

---

#### **1. Autentica√ß√£o de API: Passe para o MCC**
**Autentica√ß√£o** √© o processo de verificar a identidade de um usu√°rio. Ao contr√°rio de sites com sess√µes e cookies, APIs stateless (que n√£o mant√™m estado) geralmente usam **tokens**.

**O processo √© o seguinte:**

1.  O usu√°rio envia seu login e senha para um endpoint especial (por exemplo, `/login`).
2.  O servidor os verifica. Se tudo estiver correto, ele gera um **token** √∫nico, criptografado (uma string longa) e o envia de volta.
3.  A cada requisi√ß√£o subsequente a recursos protegidos (por exemplo, `POST /planets`), o usu√°rio deve anexar este token no cabe√ßalho `Authorization`.
4.  O servidor verifica a validade do token e, se estiver correto, executa a requisi√ß√£o.

> üí° **Analogia Espacial:**

> - **Login/senha** = Seu scan biom√©trico para obter um passe.
> - **Token** = Passe eletr√¥nico (cart√£o de identifica√ß√£o) que voc√™ recebe na entrada do MCC.
> - **Cabe√ßalho `Authorization: Bearer <token>`** = Voc√™ encosta seu passe no leitor em cada porta protegida.
> - **Endpoints protegidos (POST, PUT, DELETE)** = Portas para a sala do servidor ou para o painel de controle de lan√ßamento.

---

#### **2. Autentica√ß√£o no Laravel: Sanctum**
Laravel oferece uma solu√ß√£o elegante para autentica√ß√£o de API ‚Äî **Laravel Sanctum**. √â ideal para SPA (Single Page Applications), aplicativos m√≥veis e APIs simples baseadas em token.

**Passo 1: Instala√ß√£o e Configura√ß√£o do Sanctum**

*O Sanctum j√° vem instalado na aplica√ß√£o Laravel padr√£o, mas vamos verificar a configura√ß√£o.*

1.  **Publica√ß√£o da configura√ß√£o (se ainda n√£o o fez):**
    ```bash
    php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"
    ```
2.  **Execu√ß√£o das migra√ß√µes (criar√° a tabela `personal_access_tokens`):**
    ```bash
    php artisan migrate
    ```
3.  **Adi√ß√£o da trait ao modelo `User`:**
    Abra `app/Models/User.php` e certifique-se de que ele usa a trait `HasApiTokens`.
    ```php
    // app/Models/User.php
    use Laravel\Sanctum\HasApiTokens;

    class User extends Authenticatable
    {
        use HasApiTokens, HasFactory, Notifiable;
        // ...
    }
    ```

**Passo 2: Cria√ß√£o de um endpoint para emiss√£o de tokens**
Precisamos de uma rota onde o usu√°rio enviar√° seu login/senha.

Adicione em `routes/api.php`:`
```php
// routes/api.php
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use App\Models\User;
use Illuminate\Validation\ValidationException;

Route::post('/login', function (Request $request) {
    $request->validate([
        'email' => 'required|email',
        'password' => 'required',
    ]);

    $user = User::where('email', $request->email)->first();

    if (! $user || ! Hash::check($request->password, $user->password)) {
        throw ValidationException::withMessages([
            'email' => ['As credenciais est√£o incorretas.'],
        ]);
    }

    // Retorna o token
    return response()->json([
        'token' => $user->createToken('api-token')->plainTextToken
    ]);
});
```

*Para teste, voc√™ pode criar um usu√°rio via seeder ou Tinker.*

**Passo 3: Prote√ß√£o de rotas**
Agora vamos proteger nossas opera√ß√µes CRUD. Modifique `routes/api.php`:`

```php
// routes/api.php
use App\Http\Controllers\PlanetController;

// Rota p√∫blica para visualiza√ß√£o de planetas
Route::get('/planets', [PlanetController::class, 'index']);
Route::get('/planets/{planet}', [PlanetController::class, 'show']);

// Grupo de rotas protegidas
Route::middleware('auth:sanctum')->group(function () {
    Route::post('/planets', [PlanetController::class, 'store']);
    Route::put('/planets/{planet}', [PlanetController::class, 'update']);
    Route::delete('/planets/{planet}', [PlanetController::class, 'destroy']);

    // Rota para logout (exclus√£o do token)
    Route::post('/logout', function (Request $request) {
        $request->user()->currentAccessToken()->delete();
        return response()->json(['message' => 'Voc√™ saiu com sucesso'], 200);
    });
});
```

O Middleware `auth:sanctum` verificar√° a presen√ßa de um token v√°lido no cabe√ßalho `Authorization`.

---

#### **3. Autentica√ß√£o no FastAPI: OAuth2 e JWT**

No FastAPI, n√£o h√° um sistema de autentica√ß√£o embutido, mas existem ferramentas poderosas para implement√°-lo. O padr√£o de fato √© o **OAuth2 com tokens JWT**.

**Passo 1: Instala√ß√£o das depend√™ncias**
```bash
pip install "python-jose[cryptography]" "passlib[bcrypt]" "python-multipart"
```

- `python-jose`: para criar e verificar tokens JWT.
- `passlib`: para hashing e verifica√ß√£o de senhas.
- `python-multipart`: para processar dados de formul√°rio (`username` e `password`).

**Passo 2: Cria√ß√£o do m√≥dulo de seguran√ßa (`security.py`)**
√â uma boa pr√°tica mover toda a l√≥gica de autentica√ß√£o para um arquivo separado.

**Crie o arquivo `security.py`:**

```python
# security.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta, timezone

# --- Configura√ß√µes ---
SECRET_KEY = "your-super-secret-key-that-is-long-and-random" # ‚ö†Ô∏è Substitua pela sua chave!
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# --- Utilit√°rios ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/login")

# --- Fun√ß√µes ---
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# --- Fun√ß√£o de depend√™ncia para verificar o token ---
def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="N√£o foi poss√≠vel validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    # Aqui voc√™ pode retornar o usu√°rio do DB, por enquanto apenas retornamos o nome
    return {"username": username}
```

**Passo 3: Integra√ß√£o no `main.py`**
Agora vamos conectar isso √† nossa aplica√ß√£o.

1.  **Vamos criar o endpoint `/login`:**
    ```python
    # main.py
    from fastapi.security import OAuth2PasswordRequestForm
    from fastapi import Depends, APIRouter
    from . import security # Importamos nosso m√≥dulo

    # ... seu c√≥digo FastAPI ...
    router = APIRouter(prefix="/api/v1")

    @router.post("/login")
    def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
        # Aqui deve haver a verifica√ß√£o do usu√°rio no DB
        # Por exemplo, temos um usu√°rio de teste
        is_user_valid = (form_data.username == "testuser" and
                         security.verify_password("testpass", security.get_password_hash("testpass")))

        if not is_user_valid:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Nome de usu√°rio ou senha inv√°lidos",
            )
        access_token = security.create_access_token(data={"sub": form_data.username})
        return {"access_token": access_token, "token_type": "bearer"}

    # ...
    app.include_router(router)
    ```

2.  **Vamos proteger os endpoints:**

    Usamos nossa depend√™ncia `get_current_user`.
    ```python
    # main.py ou no seu roteador de planetas

    @router.post("/planets", status_code=status.HTTP_201_CREATED)
    def create_planet(
        planet: PlanetCreate,
        current_user: dict = Depends(security.get_current_user) # <-- Prote√ß√£o!
    ):
        # L√≥gica de cria√ß√£o de planetas...
        print(f"O usu√°rio {current_user['username']} est√° criando um planeta.")
        # ...
        return new_planet

    # Protegemos PUT e DELETE tamb√©m
    ```

---

#### **4. Uso de tokens no frontend**

Nosso frontend agora deve primeiro obter o token, salv√°-lo (por exemplo, em `localStorage`) e anex√°-lo a cada requisi√ß√£o protegida.

**Exemplo em JavaScript (`fetch`):**
```javascript
// 1. Fazendo login
async function login(email, password) {
    const response = await fetch('http://localhost:8001/api/login', { // Endere√ßo da API Laravel
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({email, password})
    });
    const data = await response.json();

    if (data.token) {
        localStorage.setItem('api_token', data.token); // Salva o token
    }
}

// 2. Fazendo uma requisi√ß√£o protegida
async function createPlanet(planetData) {
    const token = localStorage.getItem('api_token');

    const response = await fetch('http://localhost:8001/api/planets', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}` // <--- Anexa o token!
        },
        body: JSON.stringify(planetData)
    });
    // ...
}
```

---

#### **Quiz para fixa√ß√£o**


<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
</style>
```html
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. APIs sem estado geralmente usam para autentica√ß√£o:</p>
      <label><input type="radio" name="q1" value="a"> a) Sess√µes e cookies</label>
      <label><input type="radio" name="q1" value="b"> b) Tokens (por exemplo, JWT)</label>
      <label><input type="radio" name="q1" value="c"> c) Endere√ßos IP</label>
    </div>
    <div class="question">
      <p>2. No Laravel, o middleware usado para proteger rotas com tokens √©:</p>
      <label><input type="radio" name="q2" value="a"> a) auth:api</label>
      <label><input type="radio" name="q2" value="b"> b) auth:sanctum</label>
      <label><input type="radio" name="q2" value="c"> c) verified</label>
    </div>
    <div class="question">
      <p>3. No FastAPI, a depend√™ncia usada para obter dados do formul√°rio de login √©:</p>
      <label><input type="radio" name="q3" value="a"> a) Body()</label>
      <label><input type="radio" name="q3" value="b"> b) Form()</label>
      <label><input type="radio" name="q3" value="c"> c) OAuth2PasswordRequestForm = Depends()</label>
    </div>
    <div class="question">
      <p>4. Como o token √© transmitido do cliente para o servidor em uma requisi√ß√£o protegida?</p>
      <label><input type="radio" name="q4" value="a"> a) No par√¢metro URL `?token=...`</label>
      <label><input type="radio" name="q4" value="b"> b) No corpo da requisi√ß√£o</label>
      <label><input type="radio" name="q4" value="c"> c) No cabe√ßalho HTTP `Authorization: Bearer <token>`</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'b', q3: 'c', q4: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ instalou um "sistema de controle de acesso" nas suas APIs. Agora, nem todo mundo pode fazer altera√ß√µes no seu "banco de dados gal√°ctico".

- ‚úÖ Entendeu o princ√≠pio da autentica√ß√£o baseada em token.
- üîê Implementou a emiss√£o de tokens e a prote√ß√£o de rotas no Laravel Sanctum.
- ‚öôÔ∏è Configurou a autentica√ß√£o baseada em OAuth2 e JWT no FastAPI.
- üõ∞Ô∏è Aprendeu como o frontend deve armazenar e usar o token.

**Suas APIs se tornaram n√£o apenas funcionais, mas tamb√©m seguras.** No entanto, para que outros desenvolvedores possam us√°-las, eles precisam de "instru√ß√µes de opera√ß√£o".

> **üìå Verifica√ß√£o:**

> - Tente fazer uma requisi√ß√£o `POST` para `/api/planets` (no Laravel) ou `/api/v1/planets` (no FastAPI) sem um token usando Postman ou Insomnia. Voc√™ deve receber um erro `401 Unauthorized`.
> - Fa√ßa uma requisi√ß√£o para `/login`, obtenha o token, adicione-o ao cabe√ßalho `Authorization` e repita a requisi√ß√£o `POST`. Ela deve ser executada com sucesso.
```