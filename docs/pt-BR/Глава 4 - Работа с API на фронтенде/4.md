# **Cap√≠tulo 4.4: Tratamento de Erros**
**Tempo de estudo:** 45 minutos

---

#### **1. Tratamento de Erros: Protocolos de Emerg√™ncia do Centro de Controle de Miss√£o (CCM)**
No espa√ßo, nem tudo pode sair como planeado: uma explos√£o solar pode interromper a comunica√ß√£o, o computador de bordo da nave pode falhar, e a equipa da Terra pode enviar coordenadas incorretas.

**O tratamento de erros no frontend** s√£o os **protocolos de emerg√™ncia** do seu CCM. Eles devem:

- üö® Evitar que toda a interface "expluda" devido a um √∫nico comando falho.
- üì° Comunicar claramente ao operador (utilizador) o que exatamente deu errado.
- üîß Sugerir poss√≠veis a√ß√µes futuras.

> üí° **Analogia espacial:**

> Se a nave envia um sinal `500 Internal Server Error`, o ecr√£ do CCM n√£o deve mostrar "Erro Cr√≠tico de JavaScript na linha 57". Em vez disso, deve aparecer: "üö® **Falha a bordo da nave!** Os engenheiros j√° foram notificados. Tente repetir o comando mais tarde."

---

#### **2. Tipos de "Anomalias Espaciais"**
No frontend, deparamo-nos com tr√™s tipos principais de erros ao trabalhar com a API:

1.  **Erros de Rede:** A comunica√ß√£o com o servidor n√£o foi estabelecida. A antena n√£o funciona, o cabo est√° cortado. `fetch` "cair√°" no bloco `.catch()`.
2.  **Erros de Cliente (4xx):** O comando da Terra estava incorreto. ID inv√°lido, erro de valida√ß√£o. O servidor responde, mas com o status `4xx`.
3.  **Erros de Servidor (5xx):** Falha na pr√≥pria nave. Problema no c√≥digo da API. O servidor responde, mas com o status `500+`.

J√° come√ß√°mos a trat√°-los com `try...catch` e a verifica√ß√£o de `response.ok`. Agora, vamos fazer isso de forma centralizada.

---

#### **3. Fun√ß√£o Centralizada de Manipula√ß√£o**
Repetir o mesmo c√≥digo `try...catch` em cada fun√ß√£o √© uma m√° pr√°tica. Vamos criar um "wrapper" universal para as nossas requisi√ß√µes `fetch`.

**Passo 1: Criar `api.js`**
Crie um novo ficheiro `api.js` ao lado de `app.js`. Nele, moveremos toda a l√≥gica de intera√ß√£o com a API.
```javascript
// api.js

const API_BASE_URL = 'http://127.0.0.1:8000';

/**
 * Fun√ß√£o universal para executar requisi√ß√µes √† API.
 * Lida com erros e retorna JSON.
 * @param {string} endpoint - Endpoint da API, por exemplo, '/spaceships'
 * @param {object} options - Par√¢metros para fetch (method, headers, body)
 */
async function apiRequest(endpoint, options = {}) {
    const url = `${API_BASE_URL}${endpoint}`;

    try {
        const response = await fetch(url, options);

        // Se a resposta n√£o for JSON, lan√ßa um erro imediatamente
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            // Exce√ß√£o para requisi√ß√µes DELETE bem-sucedidas que n√£o t√™m corpo
            if (response.status === 204) return null;

            throw new TypeError(`Resposta n√£o-JSON recebida do servidor: ${response.statusText}`);
        }

        const data = await response.json();

        if (!response.ok) {
            // Se o servidor retornou JSON com um erro (por exemplo, detail do FastAPI)
            const errorMessage = data.detail || `Erro HTTP! Status: ${response.status}`;
            throw new Error(errorMessage);
        }

        return data;

    } catch (error) {
        console.error(`Erro na requisi√ß√£o API para ${endpoint}:`, error);
        // Propaga o erro para que possa ser capturado na UI
        throw error;
    }
}
```

**Passo 2: Conectar `api.js` no `index.html`**
√â importante conect√°-lo **ANTES** de `app.js`, pois `app.js` usar√° as suas fun√ß√µes.
```html
<!-- index.html -->
<body>
    <!-- ... -->
    <script src="api.js"></script>
    <script src="app.js"></script>
</body>
```

**Passo 3: Refatorar `app.js`**
Agora, vamos reescrever as nossas fun√ß√µes usando o novo `apiRequest`.
```javascript
// app.js

// const API_BASE_URL = ...; // Esta linha pode ser removida, agora est√° em api.js

// ...

async function fetchAndDisplayFleet() {
    try {
        fleetList.innerHTML = '<li>Carregando telemetria...</li>';
        const ships = await apiRequest('/spaceships'); // <-- Usamos nosso wrapper!

        fleetList.innerHTML = '';
        if (ships.length === 0) {
            fleetList.innerHTML = '<li>N√£o h√° nenhuma nave no registro.</li>';
            return;
        }

        ships.forEach(ship => { /* ... restante do c√≥digo de exibi√ß√£o ... */ });
    } catch (error) {
        fleetList.innerHTML = `<li>üî¥ Erro ao carregar a frota: ${error.message}</li>`;
    }
}

async function createShip(event) {
    event.preventDefault();
    const shipData = { /* ... coleta de dados do formul√°rio ... */ };

    try {
        createStatusMessage.textContent = 'Enviando comando para lan√ßamento...';
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(shipData)
        };
        const newShip = await apiRequest('/spaceships', options); // <-- Usamos nosso wrapper!

        createStatusMessage.textContent = `üöÄ Lan√ßamento bem-sucedido! ID atribu√≠do √† nave: ${newShip.id}`;
        createShipForm.reset();
        fetchAndDisplayFleet();
    } catch (error) {
        createStatusMessage.textContent = `üî¥ Erro: ${error.message}`;
    }
}

// Reescreva as outras fun√ß√µes (fetchShipById, deleteShip) de forma an√°loga!
```
Agora, toda a l√≥gica de tratamento de erros de rede, verifica√ß√£o de `response.ok` e parsing de JSON est√° num √∫nico lugar, e o c√≥digo em `app.js` tornou-se muito mais limpo e leg√≠vel.

---

#### **4. Exibi√ß√£o de Erros ao Usu√°rio**
Uma boa interface n√£o deve apenas registar o erro na consola, mas tamb√©m mostr√°-lo ao utilizador de forma compreens√≠vel.

**Exemplo: Melhoria de `createShip`**
O nosso c√≥digo j√° faz isso: `createStatusMessage.textContent = ...`. Mas podemos fazer ainda melhor, criando uma fun√ß√£o universal para exibir notifica√ß√µes.

**Adicionando em `app.js`:**
```javascript
// app.js
function showNotification(message, isError = false) {
    const notificationArea = document.getElementById('create-status-message'); // ou outro elemento
    notificationArea.textContent = message;
    notificationArea.style.color = isError ? 'red' : 'green';
}

// Usando em createShip:
async function createShip(event) {
    // ...
    try {
        // ...
        const newShip = await apiRequest('/spaceships', options);
        showNotification(`üöÄ Lan√ßamento bem-sucedido! ID: ${newShip.id}`);
        // ...
    } catch (error) {
        showNotification(`üî¥ Erro: ${error.message}`, true);
    }
}
```
Agora temos um mecanismo unificado para exibir tanto mensagens de sucesso quanto erros.

---

#### **Quiz para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. O bloco `.catch()` em uma promessa `fetch` ser√° acionado se...</p>
      <label><input type="radio" name="q1" value="a"> a) O servidor retornou um erro 404 Not Found</label>
      <label><input type="radio" name="q1" value="b"> b) Ocorreu um erro de rede (por exemplo, sem internet)</label>
      <label><input type="radio" name="q1" value="c"> c) O servidor retornou um erro 500 Internal Server Error</label>
    </div>
    <div class="question">
      <p>2. Por que √© necess√°ria uma fun√ß√£o de tratamento centralizada para requisi√ß√µes API?</p>
      <label><input type="radio" name="q2" value="a"> a) Para evitar a duplica√ß√£o de c√≥digo de tratamento de erros e tornar a l√≥gica da UI mais limpa</label>
      <label><input type="radio" name="q2" value="b"> b) Para que todas as requisi√ß√µes sejam enviadas simultaneamente</label>
      <label><input type="radio" name="q2" value="c"> c) √â um requisito do padr√£o Fetch API</label>
    </div>
    <div class="question">
      <p>3. `response.headers.get('content-type')` √© usado para...</p>
      <label><input type="radio" name="q3" value="a"> a) Definir o cabe√ßalho na requisi√ß√£o de sa√≠da</label>
      <label><input type="radio" name="q3" value="b"> b) Verificar o tipo de conte√∫do na resposta recebida do servidor</label>
      <label><input type="radio" name="q3" value="c"> c) Obter todos os tipos de conte√∫do dispon√≠veis</label>
    </div>
    <div class="question">
      <p>4. `throw new Error(...)` dentro de `try...catch` ou `.then()` √© usado para...</p>
      <label><input type="radio" name="q4" value="a"> a) Interromper a execu√ß√£o de todo o JavaScript na p√°gina</label>
      <label><input type="radio" name="q4" value="b"> b) "Falhar" a promessa e passar o controle para o bloco `.catch()` mais pr√≥ximo</label>
      <label><input type="radio" name="q4" value="c"> c) Exibir uma mensagem em `alert`</label>
    </div>
    <div class="question">
      <p>5. Por que √© importante exibir os erros para o usu√°rio, e n√£o apenas no console?</p>
      <label><input type="radio" name="q5" value="a"> a) Porque a maioria dos usu√°rios n√£o olha o console</label>
      <label><input type="radio" name="q5" value="b"> b) Para que a interface seja compreens√≠vel e previs√≠vel</label>
      <label><input type="radio" name="q5" value="c"> c) Ambas as op√ß√µes est√£o corretas</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'b', q2: 'a', q3: 'b', q4: 'b', q5: 'c' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';
```
for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>


---

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ fortaleceu seu Centro de Controle de Miss√µes, criando protocolos de emerg√™ncia robustos.

- üõ°Ô∏è Voc√™ entende a diferen√ßa entre erros de rede, de cliente e de servidor.
- ‚öôÔ∏è Voc√™ criou uma fun√ß√£o `apiRequest` centralizada para lidar com todas as requisi√ß√µes, evitando duplica√ß√£o de c√≥digo.
- üì° Sua interface agora √© capaz de informar corretamente o usu√°rio sobre os erros, tornando-a mais amig√°vel e confi√°vel.

**Escudos de emerg√™ncia levantados!** Mas o que √© melhor: cadeias `.then()` ou o moderno `async/await`? No pr√≥ximo cap√≠tulo, analisaremos ambas as abordagens e entenderemos quando usar cada uma.

> **üìå Verifica√ß√£o:**

> - Verifique se o seu c√≥digo em `app.js` foi refatorado com sucesso e usa a nova fun√ß√£o `apiRequest`.
> - Tente parar o servidor FastAPI e clique no bot√£o "Solicitar Dados". Voc√™ dever√° ver um erro de conex√£o na p√°gina.
> - Tente criar uma nave com dados inv√°lidos. Voc√™ dever√° ver uma mensagem de erro de valida√ß√£o que veio do FastAPI.

> **‚ö†Ô∏è Se houver erros:**

> - `apiRequest is not defined`: Certifique-se de que voc√™ conectou `api.js` em `index.html` **antes** de `app.js`.
> - Verifique o console do navegador para outras ocorr√™ncias de erros de sintaxe em JavaScript.