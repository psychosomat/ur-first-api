# **Capítulo 3.4: Operações CRUD para Naves Espaciais**
**Tempo de estudo:** 1 hora

---

#### **1. CRUD: Ciclo Completo de Gerenciamento de Missões Espaciais**
Até agora, apenas lemos dados (`Read`). Mas um verdadeiro Centro de Controle de Missões deve ser capaz de tudo:

- **C**reate (Criar): Lançar um novo satélite em órbita.
- **R**ead (Ler): Solicitar o status de uma nave existente.
- **U**pdate (Atualizar): Corrigir uma órbita ou atualizar software.
- **D**elete (Excluir): Remover um satélite antigo da órbita.

Essas quatro operações — **CRUD** — formam a base da maioria das APIs. Neste capítulo, implementaremos o ciclo completo para gerenciar nossa frota.

---

#### **2. Create: Lançando uma Nova Nave (POST)**
Para criar uma nova nave espacial, usaremos o método `POST`. Os dados para a nova nave serão transmitidos no corpo da requisição em formato JSON.

**Passo 1: Criando um novo modelo Pydantic para dados de entrada**
Por que é necessário um novo modelo? Porque ao criar uma nave, não sabemos seu `id` — ele deve ser atribuído pelo servidor.

**Adicione este modelo ao `main.py`:**
```python
# main.py
from pydantic import BaseModel, Field

class SpaceshipCreate(BaseModel):
    """Modelo para criar uma nova nave (sem ID)."""
    name: str = Field(..., min_length=3, max_length=50)
    type: str
    launch_year: int = Field(..., gt=1950)
    status: str
```
Este modelo é quase idêntico a `Spaceship`, mas será usado para **validação de dados de entrada**.

**Passo 2: Implementando o endpoint `POST /spaceships`**
```python
# main.py
import random # Adicione esta importação no início do arquivo

# ... restante do código ...

@app.post("/spaceships", response_model=Spaceship, status_code=201)
def create_spaceship(ship: SpaceshipCreate):
    """
    Adiciona uma nova nave espacial ao registro.
    """
    # Geramos um novo ID exclusivo para a nave
    new_id = max(db_spaceships.keys() or [0]) + 1

    # Criamos um objeto de nave, correspondente ao modelo completo Spaceship
    new_ship = Spaceship(id=new_id, **ship.dict())

    # Salvamos em nossa "base de dados"
    db_spaceships[new_id] = new_ship.dict()

    return new_ship
```
**Decifrando:**

- `@app.post(...)`: Usamos o decorador para requisições `POST`.
- `status_code=201`: Indicamos que, em caso de criação bem-sucedida, deve-se retornar o status `201 Created`.
- `ship: SpaceshipCreate`: Aí está a mágica! O FastAPI pegará automaticamente o corpo da requisição (JSON), o validará de acordo com o modelo `SpaceshipCreate` e o passará para a função como um objeto `ship`.
- `new_id = ...`: Lógica simples para gerar um novo ID.
- `**ship.dict()`: "Desempacotamos" os dados do modelo `ship` recebido para o nosso modelo completo.
- `response_model=Spaceship`: A resposta corresponderá ao modelo completo, incluindo o `id`.

---

#### **3. Update: Correção de Rota (PUT)**
Para uma atualização completa de um recurso existente, o método `PUT` é usado.

**Implementando o endpoint `PUT /spaceships/{ship_id}`:**
```python
# main.py
from fastapi import FastAPI, HTTPException # Atualize a importação

# ... restante do código ...

@app.put("/spaceships/{ship_id}", response_model=Spaceship)
def update_spaceship(ship_id: int, ship_update: SpaceshipCreate):
    """
    Atualiza completamente os dados de uma nave espacial.
    """
    if ship_id not in db_spaceships:
        raise HTTPException(status_code=404, detail="Nave espacial não encontrada")

    updated_ship = Spaceship(id=ship_id, **ship_update.dict())
    db_spaceships[ship_id] = updated_ship.dict()

    return updated_ship
```

- `ship_update: SpaceshipCreate`: Usamos novamente nosso modelo para validação dos dados de entrada.
- `HTTPException`: Se uma nave com tal `id` não for encontrada, "lançamos" uma exceção padrão do FastAPI, que se transformará em uma bela resposta JSON com o código `404`.

---

#### **4. Delete: Desorbitando (DELETE)**
Para excluir um recurso, o método `DELETE` é usado. Geralmente, tal endpoint não retorna um corpo de resposta.

**Implementando o endpoint `DELETE /spaceships/{ship_id}`:**
```python
# main.py
from fastapi import FastAPI, HTTPException, Response, status # Atualize a importação

# ... restante do código ...

@app.delete("/spaceships/{ship_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_spaceship(ship_id: int):
    """
    Exclui uma nave espacial do registro.
    """
    if ship_id not in db_spaceships:
        raise HTTPException(status_code=404, detail="Nave espacial não encontrada")

    del db_spaceships[ship_id]

    # Retorna uma resposta vazia com status 204
    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

- `status_code=status.HTTP_204_NO_CONTENT`: Nós explicitamente indicamos o status `204 No Content`.
- `del db_spaceships[ship_id]`: Excluímos o registro do nosso dicionário.
- `return Response(...)`: Retornamos uma resposta vazia, pois o cliente não precisa de dados sobre o objeto excluído.

---

#### **5. Testando o Ciclo Completo em `/docs`**
Seu `uvicorn` deve ter sido reiniciado.

1.  **Abra `http://127.0.0.1:8000/docs`**. Agora você tem o conjunto completo de operações CRUD!
2.  **POST:** Expanda o endpoint `POST /spaceships`, clique em "Try it out", preencha o corpo JSON (por exemplo, crie o "Telescópio Espacial James Webb") e clique em "Execute". Você deve receber uma resposta `201` com os dados do novo telescópio.
3.  **GET:** Agora execute `GET /spaceships`. Seu novo telescópio deve aparecer na lista.
4.  **PUT:** Use o ID do novo telescópio para atualizar seus dados via `PUT /spaceships/{ship_id}`. Por exemplo, altere seu status.
5.  **DELETE:** Use o mesmo ID para excluir o telescópio via `DELETE /spaceships/{ship_id}`. Você deve receber uma resposta vazia com status `204`.
6.  **Verificação:** Execute `GET /spaceships` novamente para confirmar que o telescópio foi excluído da lista.

---

#### **Questionário para Consolidação**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>

<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Qual método HTTP é usado para criar um novo recurso?</p>
      <label><input type="radio" name="q1" value="a"> a) GET</label>
      <label><input type="radio" name="q1" value="b"> b) PUT</label>
      <label><input type="radio" name="q1" value="c"> c) POST</label>
    </div>
    <div class="question">
      <p>2. O código de status de sucesso padrão para a operação `DELETE` é:</p>
      <label><input type="radio" name="q2" value="a"> a) 200 OK</label>
      <label><input type="radio" name="q2" value="b"> b) 204 No Content</label>
      <label><input type="radio" name="q2" value="c"> c) 404 Not Found</label>
    </div>
    <div class="question">
      <p>3. Como o FastAPI obtém dados do corpo de uma requisição POST?</p>
      <label><input type="radio" name="q3" value="a"> a) Através da variável global `$_POST`</label>
      <label><input type="radio" name="q3" value="b"> b) Automaticamente, se um modelo Pydantic for especificado no argumento da função</label>
      <label><input type="radio" name="q3" value="c"> c) É necessário ler manualmente o fluxo `request.body`</label>
    </div>
    <div class="question">
      <p>4. `raise HTTPException(status_code=404)` é usado para:</p>
      <label><input type="radio" name="q4" value="a"> a) Gerar um erro fatal do servidor (500)</label>
      <label><input type="radio" name="q4" value="b"> b) Retornar uma resposta HTTP de erro correta ao cliente</label>
      <label><input type="radio" name="q4" value="c"> c) Registrar o erro em um arquivo</label>
    </div>
    <div class="question">
      <p>5. Por que criamos um modelo `SpaceshipCreate` separado para a criação de um recurso (`POST`)?</p>
      <label><input type="radio" name="q5" value="a"> a) Porque o objeto a ser criado ainda não possui um `id`</label>
      <label><input type="radio" name="q5" value="b"> b) Porque o FastAPI exige nomes de modelos diferentes para cada endpoint</label>
      <label><input type="radio" name="q5" value="c"> c) Para acelerar a validação</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'b', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;
```
if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

---

**🚀 Resumo do Capítulo:**

Você implementou o ciclo completo de **CRUD** e transformou sua API de um simples "painel de informações" em um completo **Centro de Controle de Frota**!

- ✅ **C**reate: `POST /spaceships` para lançar novas naves.
- ✅ **R**ead: `GET /spaceships` e `GET /spaceships/{id}` para obter dados.
- ✅ **U**pdate: `PUT /spaceships/{id}` para atualizar missões.
- ✅ **D**elete: `DELETE /spaceships/{id}` para desativar naves.

**Sua frota está sob controle total!** No próximo capítulo, veremos como o FastAPI gerou automaticamente para nós um "manual de operações" detalhado – a documentação interativa do Swagger.

> **📌 Verificação:**

> - Todos os 5 endpoints (`GET` (2), `POST`, `PUT`, `DELETE`) estão visíveis e funcionando em `/docs`.
> - Você pode criar, ler, atualizar e excluir um recurso com sucesso.
> - Ao solicitar um ID inexistente, um erro `404` é retornado.

> **⚠️ Se houver erros:**

> - `NameError`: Verifique se você importou `HTTPException`, `Response`, `status`.
> - `KeyError`: Provavelmente, você está tentando acessar um ID que já foi excluído.
> - Funcionamento incorreto de `PUT` ou `POST`: Certifique-se de estar usando o modelo Pydantic correto no argumento da função (`SpaceshipCreate`).