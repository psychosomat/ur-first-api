# **Cap√≠tulo 5.6: Exibi√ß√£o de Dados via Blade + Fetch**
**Tempo de estudo:** 50 minutos

---

### **1. Abordagem H√≠brida: O Melhor de Dois Mundos**

Podemos construir uma p√°gina de duas maneiras:

1.  **Renderiza√ß√£o Completa no Servidor (SSR):** Laravel gera todo o HTML, incluindo a lista de planetas. Para qualquer atualiza√ß√£o (exclus√£o, adi√ß√£o), a p√°gina √© completamente recarregada.
2.  **Renderiza√ß√£o Completa no Cliente (CSR):** Laravel entrega um "esqueleto" HTML vazio, e o JavaScript solicita todos os dados da API e os renderiza no cliente. (Esta √© a abordagem Single Page Application - SPA).

**Nossa escolha ‚Äî a abordagem h√≠brida:**

-   **Primeira carga (SSR):** Laravel entrega imediatamente a p√°gina com a lista de planetas j√° pronta. Isso √© r√°pido e bom para SEO. O usu√°rio v√™ o conte√∫do imediatamente.
-   **A√ß√µes subsequentes (CSR):** O JavaScript intercepta as a√ß√µes do usu√°rio (cliques de bot√µes) e interage com a API, atualizando apenas as partes necess√°rias da p√°gina, sem recarga completa.

> üí° **Analogia Espacial:**

> Ao entrar na ponte de comando, voc√™ recebe imediatamente o mapa de navega√ß√£o principal, impresso no Centro de Controle da Miss√£o (SSR). Ele j√° est√° em suas m√£os, n√£o h√° necessidade de esperar. Mas ent√£o voc√™ ativa o "modo ao vivo" em seu tablet (CSR), e ele come√ßa a receber atualiza√ß√µes dos sat√©lites em tempo real, redesenhando os objetos em seu mapa.

---

### **2. Passo 1: Prepara√ß√£o da P√°gina**

Trabalharemos com nossa p√°gina de lista de planetas `resources/views/planets/index.blade.php`. Ela j√° √© capaz de exibir dados passados do controlador. Agora adicionaremos a ela elementos de controle que funcionar√£o via JS.

**Adicione um bot√£o "Atualizar lista" e um cont√™iner para notifica√ß√µes:**
```html
    <div class="controls">
        <h2>Lista de todos os planetas conhecidos</h2>
        <button id="refresh-btn">Atualizar via API</button>
    </div>
    <div id="notification-area" class="notification"></div>
    <hr>
    {{-- Esta div ser√° nosso cont√™iner para atualiza√ß√£o din√¢mica --}}
    <div id="planet-list-container" class="planet-list">
        {{-- Inclui a view "filha" que renderiza a lista inicial --}}
        @include('planets.partials.list', ['planets' => $planets])
    </div>
```

Observe `@include('planets.partials.list', ...)`. Extra√≠mos a l√≥gica de exibi√ß√£o da lista para um arquivo separado e reutiliz√°vel.

---

### **Passo 2: Cria√ß√£o de uma View "Parcial" Reutiliz√°vel (Partial)**

Extrair partes repetidas para arquivos separados √© uma boa pr√°tica.

Crie o arquivo `resources/views/planets/partials/list.blade.php`:

```blade
@forelse($planets as $planet)
    <div class="planet-card" id="planet-card-{{ $planet->id }}">
        <h3>{{ $planet->name }}</h3>
        <p>Sistema Solar: {{ $planet->solar_system }}</p>
        <p>Di√¢metro: {{ number_format($planet->size_km, 0, '.', ' ') }} km</p>
        <a href="{{ route('planets.show', $planet) }}">Saber mais &rarr;</a>
        <button class="delete-btn" data-id="{{ $planet->id }}" data-url="{{ route('api.planets.destroy', $planet) }}">
            Desativar
        </button>
    </div>
@empty
    <p>N√£o h√° nenhum planeta no banco de dados.</p>
@endforelse
```

-   **Importante:** Observe que a URL para o bot√£o de exclus√£o agora √© gerada para a rota da API: `route('api.planets.destroy', $planet)`. Para isso, certifique-se de que em `routes/api.php` voc√™ tenha um recurso nomeado: `Route::apiResource('planets', ...)->name('api.planets');`

---

### **Passo 3: Escrita de JavaScript para Atualiza√ß√£o Din√¢mica**

Agora o mais interessante. Criaremos um JavaScript que, ao clicar em um bot√£o, solicitar√° uma lista atualizada de planetas da API e a redesenhar√°.

Crie o arquivo `public/js/planet-manager.js` e inclua-o em `layouts/app.blade.php`.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refresh-btn');
    const planetListContainer = document.getElementById('planet-list-container');
    const notificationArea = document.getElementById('notification-area');

    // Fun√ß√£o para exibir notifica√ß√µes
    function showNotification(message, isError = false) {
        notificationArea.textContent = message;
        notificationArea.className = isError ? 'notification error' : 'notification success';
        setTimeout(() => {
            notificationArea.textContent = '';
            notificationArea.className = 'notification';
        }, 3000);
    }

    // Fun√ß√£o para renderizar um √∫nico cart√£o de planeta
    function createPlanetCardHtml(planet) {
        // IMPORTANTE: Geramos o mesmo HTML que em nossa view parcial
        return `
            <div class="planet-card" id="planet-card-${planet.id}">
                <h3>${planet.name}</h3>
                <p>Sistema Solar: ${planet.solar_system}</p>
                <p>Di√¢metro: ${new Intl.NumberFormat().format(planet.size_km)} km</p>
                <a href="/planets/${planet.id}">Saber mais &rarr;</a>
                <button class="delete-btn" data-id="${planet.id}" data-url="/api/planets/${planet.id}">
                    Desativar (JS)
                </button>
            </div>
        `;
    }

    // Fun√ß√£o para solicitar e redesenhar a lista de planetas
    async function fetchAndRenderPlanets() {
        showNotification('Solicitando novos dados de sat√©lites orbitais...');
        try {
            const response = await fetch('/api/planets', {
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) {
                throw new Error('Erro de rede ao obter dados.');
            }

            const planets = await response.json(); // Laravel por padr√£o retornar√° { data: [...] } para um recurso paginado

            planetListContainer.innerHTML = ''; // Limpa a lista antiga

            if (planets.data.length === 0) {
                planetListContainer.innerHTML = '<p>N√£o h√° nenhum planeta no banco de dados.</p>';
            } else {
                planets.data.forEach(planet => {
                    const cardHtml = createPlanetCardHtml(planet);
                    planetListContainer.innerHTML += cardHtml;
                });
            }
            showNotification('Dados atualizados com sucesso!', false);
        } catch (error) {
            console.error('Erro ao atualizar a lista de planetas:', error);
            showNotification(error.message, true);
        }
    }

    // Adiciona o manipulador de eventos ao bot√£o
    if (refreshBtn) {
        refreshBtn.addEventListener('click', fetchAndRenderPlanets);
    }

    // A l√≥gica de exclus√£o do cap√≠tulo anterior pode ser movida para c√°,
    // para que todo o JS esteja em um s√≥ lugar.
});
```

---

### **3. Verifica√ß√£o Final**

1.  **Inicie o servidor** (`php artisan serve` ou certifique-se de que o Herd esteja funcionando).
2.  **Recrie o banco de dados,** se necess√°rio: `php artisan migrate:fresh --seed`.
3.  **Abra a p√°gina `/planets`** no navegador.
    -   Voc√™ deve ver imediatamente a lista de planetas, gerada pelo servidor.
4.  **Clique no bot√£o "Atualizar via API"**.
    -   Voc√™ ver√° uma notifica√ß√£o de carregamento.
    -   A lista deve desaparecer por um momento e reaparecer, mas desta vez ser√° gerada por JavaScript com base nos dados obtidos da API.

Voc√™ implementou com sucesso o modelo h√≠brido!

---

### **Quiz para Fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. O que √© uma abordagem de renderiza√ß√£o h√≠brida (SSR + CSR)?</p>
      <label><input type="radio" name="q1" value="a"> a) Primeiro, uma p√°gina vazia √© renderizada, depois o JS carrega todo o conte√∫do</label>
      <label><input type="radio" name="q1" value="b"> b) O servidor entrega uma p√°gina totalmente pronta, e ela nunca muda no cliente</label>
      <label><input type="radio" name="q1" value="c"> c) O servidor entrega uma p√°gina pronta para um carregamento inicial r√°pido, e as atualiza√ß√µes subsequentes ocorrem no cliente via JS</label>
    </div>
    <div class="question">
      <p>2. Qual √© a principal vantagem da renderiza√ß√£o inicial no servidor (SSR)?</p>
      <label><input type="radio" name="q2" value="a"> a) Redu√ß√£o da carga no servidor</label>
      <label><input type="radio" name="q2" value="b"> b) Renderiza√ß√£o r√°pida do conte√∫do inicial para o usu√°rio e boa indexa√ß√£o SEO</label>
      <label><input type="radio" name="q2" value="c"> c) Simplifica√ß√£o do c√≥digo JavaScript</label>
    </div>
    <div class="question">
      <p>3. Por que `@include('planets.partials.list')` √© usado no exemplo?</p>
      <label><input type="radio" name="q3" value="a"> a) √â um requisito do Blade para loops</label>
      <label><input type="radio" name="q3" value="b"> b) Para reutiliza√ß√£o de c√≥digo e separa√ß√£o da l√≥gica de exibi√ß√£o da lista</label>
      <label><input type="radio" name="q3" value="c"> c) Para carregamento ass√≠ncrono de parte da p√°gina</label>
    </div>
    <div class="question">
      <p>4. No c√≥digo JavaScript, duplicamos a estrutura HTML do cart√£o. Qual seria uma maneira mais avan√ßada de evitar isso?</p>
      <label><input type="radio" name="q4" value="a"> a) Solicitar √† API n√£o JSON, mas sim HTML j√° renderizado para um √∫nico cart√£o</label>
      <label><input type="radio" name="q4" value="b"> b) Usar motores de template JavaScript (como Mustache, Handlebars) ou frameworks (Vue, React)</label>
      <label><input type="radio" name="q4" value="c"> c) Ambas as op√ß√µes est√£o corretas</label>
    </div>
    <div class="question">
      <p>5. Por que √© importante que a API (`/api/planets`) e o c√≥digo JavaScript (`createPlanetCardHtml`) gerem dados/HTML consistentes?</p>
      <label><input type="radio" name="q5" value="a"> a) Caso contr√°rio, o usu√°rio ver√° um "salto" ou mudan√ßa na interface ao atualizar via API</label>
      <label><input type="radio" name="q5" value="b"> b) Isso √© exigido pela especifica√ß√£o da Fetch API</label>
      <label><input type="radio" name="q5" value="c"> c) Caso contr√°rio, o Laravel retornar√° um erro 500</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'c', q2: 'b', q3: 'b', q4: 'c', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Quest√£o ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

**üöÄ Parab√©ns pela conclus√£o do Cap√≠tulo 5!**

Voc√™ percorreu um longo caminho, desde os fundamentos do Blade at√© a cria√ß√£o de p√°ginas h√≠bridas interativas. Voc√™ aprendeu a:

-   Criar e usar templates e layouts Blade.
-   Organizar rotas da web e controladores para opera√ß√µes CRUD.
-   Proteger formul√°rios da web e requisi√ß√µes AJAX com tokens CSRF.
-   Integrar JavaScript para intera√ß√£o din√¢mica com a API sem recarregar a p√°gina.

**Seu Centro de Controle de Voo est√° totalmente funcional, seguro e interativo.** Voc√™ est√° pronto para a pr√≥xima grande etapa ‚Äî comparar esta abordagem com outros frameworks e aprender as melhores pr√°ticas para produ√ß√£o.