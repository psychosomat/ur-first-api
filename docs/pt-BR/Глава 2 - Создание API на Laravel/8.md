# **Cap√≠tulo 2.8: Teste de API**
**Tempo de estudo:** 1 hora

---

#### **1. Por que os testes s√£o necess√°rios?**

Imagine que voc√™ construiu uma nave espacial. Antes de envi√°-la para Marte, voc√™ realiza milhares de verifica√ß√µes na Terra. Testes em programa√ß√£o s√£o a mesma coisa. Eles:

-   **D√£o confian√ßa:** Voc√™ pode alterar o c√≥digo, e se os testes passarem ‚Äî significa que voc√™ n√£o quebrou nada.
-   **Economizam tempo:** Em vez de "clicar" manualmente em tudo no Postman ap√≥s cada altera√ß√£o, voc√™ executa um √∫nico comando, e ele verifica tudo para voc√™ em segundos.
-   **Servem como documenta√ß√£o:** Bons testes mostram como sua API deve funcionar.

---

#### **2. Configurando o "Laborat√≥rio" de Teste**

Laravel torna a configura√ß√£o de testes incrivelmente simples. Por padr√£o, ele usa uma configura√ß√£o separada para n√£o afetar seu banco de dados principal.

**Banco de dados para testes:**
Por padr√£o, Laravel usa um banco de dados **em mem√≥ria** (`:memory:`). Esta √© a maneira mais r√°pida, porque n√£o h√° necessidade de escrever nada no disco. O banco de dados √© criado antes dos testes e destru√≠do depois deles. Nem precisamos configurar nada para isso!

**Cria√ß√£o de arquivo de teste:**
Vamos criar um arquivo especial para testes relacionados a planetas.

```bash
php artisan make:test PlanetApiTest
```

Este comando criar√° o arquivo `tests/Feature/PlanetApiTest.php`. A palavra `Feature` significa que vamos testar a funcionalidade como um todo (por exemplo, "o usu√°rio pode criar um planeta?"), e n√£o uma pequena classe individual.

---

#### **3. Anatomia de um teste: Prepara√ß√£o, A√ß√£o, Verifica√ß√£o**

Abra `tests/Feature/PlanetApiTest.php`. Dentro dele, escreveremos nosso primeiro teste. Um bom teste sempre consiste em tr√™s partes (Arrange, Act, Assert).

```php
<?php

namespace Tests\Feature;

use App\Models\Planet; // N√£o se esque√ßa de importar o modelo
use Illuminate\Foundation\Testing\RefreshDatabase; // Ferramenta crucial!
use Tests\TestCase;

class PlanetApiTest extends TestCase
{
    // Este trait "magicamente" limpa e recria
    // nosso banco de dados de teste antes de cada teste.
    // Isso garante que os testes n√£o afetem uns aos outros.
    use RefreshDatabase;

    /**
     * Teste: o endpoint para obter a lista de planetas funciona corretamente.
     * Os nomes dos testes devem ser significativos!
     */
    public function test_can_get_all_planets(): void
    {
        // 1. PREPARA√á√ÉO (Arrange)
        // Criamos 3 planetas falsos em nosso banco de dados de teste
        // usando a factory que criamos anteriormente.
        Planet::factory()->count(3)->create();

        // 2. A√á√ÉO (Act)
        // Simulamos uma requisi√ß√£o GET real para nossa API.
        $response = $this->getJson('/api/planets');

        // 3. VERIFICA√á√ÉO (Assert)
        // Verificamos se tudo correu como deveria.
        $response->assertStatus(200); // Esperamos que o servidor responda "200 OK"
        $response->assertJsonCount(3); // Esperamos que haja exatamente 3 planetas na resposta
    }
}
```
**Pontos-chave:**

-   `use RefreshDatabase`: Este trait √© seu melhor amigo. Ele garante que cada teste comece com uma "folha em branco", com um banco de dados vazio.
-   `Planet::factory()`: As factories s√£o ideais para criar dados de teste.
-   `$this->getJson()`: Este √© um m√©todo especial do Laravel para enviar requisi√ß√µes de API dentro dos testes.
-   `assert...()`: Estas s√£o "asser√ß√µes" ou "verifica√ß√µes". Se pelo menos uma delas n√£o for satisfeita, o teste falhar√°.

---

#### **4. Testando opera√ß√µes b√°sicas (CRUD)**

Vamos escrever testes para criar, atualizar e excluir planetas.

**A. Teste para cria√ß√£o de planeta (POST)**

```php
<?php
public function test_can_create_a_planet(): void
{
    // 1. Prepara√ß√£o: preparamos os dados para o novo planeta
    $planetData = [
        'name' => 'Kepler-186f',
        'description' => 'Primeiro exoplaneta do tamanho da Terra na zona habit√°vel.',
        'size_km' => 14000,
        'solar_system' => 'Kepler-186'
    ];

    // 2. A√ß√£o: enviamos uma requisi√ß√£o POST com os dados
    $response = $this->postJson('/api/planets', $planetData);

    // 3. Verifica√ß√£o
    $response->assertStatus(201); // Esperamos o status "201 Created"
    $response->assertJsonFragment(['name' => 'Kepler-186f']); // Verificamos se o nome criado est√° na resposta

    // A verifica√ß√£o mais importante: os dados realmente foram para o banco de dados?
    $this->assertDatabaseHas('planets', [
        'name' => 'Kepler-186f'
    ]);
}
```

**B. Teste para exclus√£o de planeta (DELETE)**
```php
<?php
public function test_can_delete_a_planet(): void
{
    // 1. Prepara√ß√£o: criamos o planeta que vamos excluir
    $planet = Planet::factory()->create();

    // 2. A√ß√£o: enviamos uma requisi√ß√£o DELETE
    $response = $this->deleteJson("/api/planets/{$planet->id}");

    // 3. Verifica√ß√£o
    $response->assertStatus(204); // Esperamos "204 No Content" - exclus√£o bem-sucedida

    // Verificamos se o registro realmente desapareceu do banco de dados
    $this->assertDatabaseMissing('planets', [
        'id' => $planet->id
    ]);
}
```

---

#### **5. Testando cen√°rios "ruins"**

Testar casos de sucesso √© bom. Mas √© ainda mais importante testar erros!

**A. Teste para erro de valida√ß√£o**
```php
<?php
public function test_creation_fails_with_invalid_data(): void
{
    // 2. A√ß√£o: enviamos dados intencionalmente incorretos
    $response = $this->postJson('/api/planets', ['name' => '']); // Nome vazio

    // 3. Verifica√ß√£o
    $response->assertStatus(422); // Esperamos "422 Unprocessable Entity"
    $response->assertJsonValidationErrors('name'); // Esperamos que o erro seja especificamente no campo 'name'
}
```

**B. Teste para "n√£o encontrado" (404)**
```php
<?php
public function test_returns_404_for_non_existent_planet(): void
{
    // 2. A√ß√£o: solicitamos um planeta com um ID inexistente
    $response = $this->getJson('/api/planets/99999');

    // 3. Verifica√ß√£o
    $response->assertStatus(404); // Esperamos "404 Not Found"
}
```

---

#### **6. Executando os testes**

Agora que os testes est√£o escritos, execut√°-los √© muito simples. Execute no terminal:

```bash
php artisan test
```

Laravel encontrar√° todos os seus testes e os executar√° um por um. Se tudo ocorrer bem, voc√™ ver√° uma sa√≠da verde. Se algum teste falhar, voc√™ ver√° uma sa√≠da vermelha com uma descri√ß√£o detalhada do erro, o que permitir√° que voc√™ o corrija rapidamente.

**Para executar apenas um arquivo espec√≠fico:**
```bash
php artisan test tests/Feature/PlanetApiTest.php
```

---

#### **8. Cobertura de C√≥digo (Code Coverage)**
**Passo 1: Instala√ß√£o do Xdebug**

Para coletar informa√ß√µes de cobertura de c√≥digo, a extens√£o PHP ‚Äî [Xdebug](https://xdebug.org/wizard) √© necess√°ria.
>Envie seu `php -i` para o wizard e siga as instru√ß√µes.

**Passo 2: Configura√ß√£o de `phpunit.xml`**
```xml
<phpunit ... >
    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">./app</directory>
        </include>
    </coverage>
</phpunit>
```

**Passo 3: Execu√ß√£o com relat√≥rio**
```bash
php artisan test --coverage-html=coverage
```
Relat√≥rio: Abra `coverage/index.html` no navegador

---

#### **9. Integra√ß√£o com Postman**
**Automa√ß√£o via Newman:**

1. Exporte a cole√ß√£o do Postman para `tests/Postman/SpaceApi.postman_collection.json`
2. Instale o Newman:
```bash
npm install -g newman
```
3. Adicione o script em `composer.json`:
```json
"scripts": {
    "test:postman": "newman run tests/Postman/SpaceApi.postman_collection.json"
}
```
4. Execu√ß√£o:
```bash
composer test:postman
```

---

#### **Quiz para fixa√ß√£o**

<style>
    #quiz-container {
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question {
        margin-bottom: 15px;
    }
    .question p {
        font-weight: bold;
        margin-bottom: 10px;
    }
    #quiz-container label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
    }
    #quiz-container button {
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 10px;
    }
    #quiz-container button:hover {
    }
    #quiz-results {
        margin-top: 20px;
        padding: 15px;
        border-radius: 5px;
    }
</style>
<div id="quiz-container">
  <form id="quiz-form">
    <div class="question">
      <p>1. Comando para criar uma classe de teste:</p>
      <label><input type="radio" name="q1" value="a"> a) php artisan make:test</label>
      <label><input type="radio" name="q1" value="b"> b) php artisan generate:test</label>
      <label><input type="radio" name="q1" value="c"> c) php artisan test:create</label>
    </div>
    <div class="question">
      <p>2. O trait RefreshDatabase √© usado para:</p>
      <label><input type="radio" name="q2" value="a"> a) Limpar o BD ap√≥s os testes</label>
      <label><input type="radio" name="q2" value="b"> b) Preencher o BD com dados de teste</label>
      <label><input type="radio" name="q2" value="c"> c) Criar a estrutura do BD</label>
    </div>
    <div class="question">
      <p>3. M√©todo para verificar a estrutura JSON:</p>
      <label><input type="radio" name="q3" value="a"> a) assertJsonFormat()</label>
      <label><input type="radio" name="q3" value="b"> b) assertJsonStructure()</label>
      <label><input type="radio" name="q3" value="c"> c) assertJsonSchema()</label>
    </div>
    <div class="question">
      <p>4. As factories no Laravel s√£o necess√°rias para:</p>
      <label><input type="radio" name="q4" value="a"> a) Gera√ß√£o de dados de teste</label>
      <label><input type="radio" name="q4" value="b"> b) Cria√ß√£o de migra√ß√µes</label>
      <label><input type="radio" name="q4" value="c"> c) Tratamento de erros</label>
    </div>
    <div class="question">
      <p>5. Ferramenta para executar cole√ß√µes Postman a partir da CLI:</p>
      <label><input type="radio" name="q5" value="a"> a) Newman</label>
      <label><input type="radio" name="q5" value="b"> b) Postman CLI</label>
      <label><input type="radio" name="q5" value="c"> c) Artisan</label>
    </div>
    <button type="button" onclick="checkQuizAnswers()">Verificar</button>
  </form>
  <div id="quiz-results" style="display:none;"></div>
</div>

<script>
  function checkQuizAnswers() {
    const correctAnswers = { q1: 'a', q2: 'a', q3: 'b', q4: 'a', q5: 'a' };
    const form = document.getElementById('quiz-form');
    const resultsContainer = document.getElementById('quiz-results');
    let score = 0;
    let resultsHTML = '<h4>Resultados:</h4><ul>';

    for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
      const questionDiv = form.querySelector(`input[name="${question}"]`).closest('.question');
      const labels = questionDiv.querySelectorAll('label');
      labels.forEach(l => {
          l.style.color = 'inherit';
          l.style.fontWeight = 'normal';
          l.style.border = 'none';
      });

      const userAnswer = form.elements[question] ? form.elements[question].value : undefined;

      if (userAnswer) {
        const selectedLabel = form.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
        if (userAnswer === correctAnswer) {
          score++;
          selectedLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:green;">Correto!</span></li>`;
        } else {
          selectedLabel.style.fontWeight = 'bold';
          const correctLabel = form.querySelector(`input[name="${question}"][value="${correctAnswer}"]`).parentElement;
          correctLabel.style.fontWeight = 'bold';
          resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:red;">Incorreto.</span> Resposta correta: <b>${correctAnswer.toUpperCase()}</b></li>`;
        }
      } else {
        resultsHTML += `<li>Pergunta ${question.slice(1)}: <span style="color:orange;">Sem resposta.</span></li>`;
      }
    }

    resultsHTML += `</ul><p><b>Seu resultado: ${score} de ${Object.keys(correctAnswers).length}</b></p>`;
    resultsContainer.innerHTML = resultsHTML;
    resultsContainer.style.display = 'block';
  }
</script>

**üöÄ Resumo do Cap√≠tulo:**

Voc√™ realizou um ciclo completo de testes de pr√©-voo! Agora seu API ir√°:

- ‚úÖ Configurar o ambiente de teste sem esfor√ßo extra
- üõ°Ô∏è Escrever testes seguindo o princ√≠pio "Prepara√ß√£o-A√ß√£o-Verifica√ß√£o".
- üìä Testar tanto cen√°rios de sucesso (CRUD) quanto erros (valida√ß√£o, 404).
- üîÅ Executar testes com um √∫nico comando e ter confian√ßa no seu c√≥digo.

**A nave espacial est√° pronta para o lan√ßamento!** Voc√™ concluiu a se√ß√£o sobre a cria√ß√£o de API com Laravel.

> **üìå Verifica√ß√£o final:**

> 1. Execute `php artisan test`
> 2. Certifique-se de que todos os testes passem (luz verde!)
> 3. Verifique o relat√≥rio de cobertura

> **‚ö†Ô∏è Se os testes falharem:**

> - Verifique o funcionamento da API via Postman
> - Certifique-se de que o BD de teste esteja configurado
> - Use `dd($response->content())` para depura√ß√£o

**Parab√©ns pela conclus√£o do Cap√≠tulo 2!** Voc√™ n√£o apenas criou uma API, mas tamb√©m construiu uma "nave espacial" confi√°vel e testada, pronta para futuras miss√µes.

> **üåå Pr√≥ximos passos:**

> 1. Configura√ß√£o de autentica√ß√£o (Sanctum)
> 2. Documenta√ß√£o da API com Swagger
> 3. Implanta√ß√£o no servidor (Forge, VPS)
> 4. Desenvolvimento do frontend com Vue/React

**Sucesso no lan√ßamento da sua miss√£o espacial! No pr√≥ximo cap√≠tulo, exploraremos a escrita de uma API do zero** üöÄ